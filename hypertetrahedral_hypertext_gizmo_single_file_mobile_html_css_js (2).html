<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Hyper‑Tetra Engine — single‑file mobile</title>
<style>
  :root{
    --bg:#07090c; --fg:#eaf4ff; --muted:#9fb6ca; --accent:#58d5ff; --accent2:#ff7aa8; --ok:#9cff8a; --warn:#ffd35e;
    --edge:#6ea9ff; --faceA:#102132; --faceB:#0f2b28; --faceC:#2a1f36; --faceD:#2f2810;
  }
  html,body{height:100%; background:var(--bg); color:var(--fg); font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;}
  *{box-sizing:border-box}
  #app{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto;}
  header{padding:10px env(safe-area-inset-left) 6px env(safe-area-inset-right); display:flex; align-items:center; gap:8px; border-bottom:1px solid #0e141b; background:#0b0f14cc; backdrop-filter:saturate(1.2) blur(8px);}
  header h1{font-size:14px; font-weight:600; letter-spacing:.3px; margin:0; color:var(--muted)}
  header .pill{margin-left:auto; display:flex; gap:6px}
  .btn{appearance:none; border:1px solid #1d2730; background:#0e141a; color:var(--fg); padding:8px 10px; border-radius:999px; font-size:12px; letter-spacing:.2px}
  .btn:active{transform:scale(.98)}
  .btn.primary{border-color:#0b2f3b; background:#0b1c25; box-shadow:0 0 24px rgba(88,213,255,.35)}
  main{position:relative; overflow:hidden}
  canvas#gl{position:absolute; inset:0; width:100%; height:100%; touch-action:none; outline:none}

  .hud{position:absolute; left:10px; bottom:10px; right:10px; display:flex; gap:8px; pointer-events:none}
  .legend{pointer-events:auto; flex:1; background:#0c1117d0; border:1px solid #171e27; border-radius:14px; padding:10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .legend .chip{display:inline-flex; align-items:center; gap:6px; padding:6px 8px; border-radius:999px; background:#0a1620; border:1px solid #13202c; font-size:11px}
  .legend .dot{inline-size:10px; block-size:10px; border-radius:999px}
  .legend .dot.v{background:var(--accent)}
  .legend .dot.e{background:var(--edge)}
  .legend .dot.f{background:var(--warn)}
  .panel{pointer-events:auto; min-inline-size:46%; max-width:60%; background:#0c1117e0; border:1px solid #17222b; border-radius:14px; padding:10px; font-size:12px; overflow:auto; max-height:40vh}
  .panel h2{margin:.2em 0 .4em; font-size:13px; color:var(--accent)}
  .panel p{margin:.5em 0; color:var(--muted)}
  .panel .grid{display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:6px}
  .panel a{color:var(--accent2); text-decoration:none}
  .panel a:focus,.panel a:hover{text-decoration:underline}
  .toast{position:absolute; inset:auto 12px 60px 12px; background:#0a0f14; border:1px solid #13202c; color:var(--ok); border-radius:10px; padding:8px 10px; font-size:12px; opacity:0; transform:translateY(8px); transition:opacity .25s, transform .25s}
  .toast.show{opacity:1; transform:none}
  .help{position:absolute; top:10px; right:10px; background:#0c1117; border:1px solid #12202b; padding:10px; border-radius:12px; max-width:72ch; font-size:12px; color:var(--muted); display:none}
  .help.show{display:block}
  .tests{position:absolute; top:10px; left:10px; background:#0c1117; border:1px solid #12202b; padding:10px; border-radius:12px; max-width:72ch; font-size:12px; color:var(--muted); display:none}
  .tests.show{display:block}
  @media (prefers-reduced-motion: reduce){ *{scroll-behavior:auto} .btn:active{transform:none} }
</style>
</head>
<body>
<div id="app" aria-live="polite" aria-atomic="true">
  <header>
    <h1>Hyper‑Tetra Engine (vertices · edges · faces · strata)</h1>
    <div class="pill">
      <button id="helpBtn" class="btn">Help</button>
      <button id="testBtn" class="btn">Tests</button>
      <button id="resetBtn" class="btn">Reset</button>
      <button id="muteBtn" class="btn primary">Audio: On</button>
    </div>
  </header>
  <main>
    <canvas id="gl" aria-label="Hypertetrahedron canvas"></canvas>

    <div class="hud">
      <div class="legend" role="group" aria-label="Legend">
        <span class="chip"><span class="dot v"></span> vertex = tetrad node</span>
        <span class="chip"><span class="dot e"></span> edge = strata scrub (1–128)</span>
        <span class="chip"><span class="dot f"></span> face = tri‑mix field</span>
        <span class="chip">tilt = micro‑mod</span>
      </div>
      <aside id="info" class="panel" aria-label="Hypertext panel">
        <h2 id="panelTitle">Tetrad</h2>
        <div class="grid">
          <div><strong>Enhance</strong><br><a href="#" data-jump="E">open</a></div>
          <div><strong>Obsolesce</strong><br><a href="#" data-jump="O">open</a></div>
          <div><strong>Retrieve</strong><br><a href="#" data-jump="R">open</a></div>
          <div><strong>Reverse</strong><br><a href="#" data-jump="V">open</a></div>
        </div>
        <p id="panelBody">Tap <em>vertices</em> to enter nodes; drag an <em>edge</em> to scrub tetra‑slices; pinch/rotate a <em>face</em> to mix triads & scan ranges in the tetrahedral latent space.</p>
      </aside>
    </div>
    <div id="toast" class="toast" role="status"></div>
    <div id="help" class="help">
      <strong>Gestures</strong>
      <ul>
        <li><b>Tap vertex</b>: open tetrad node (E/O/R/V) & jump to mapped strata.</li>
        <li><b>Drag along edge</b>: scrub <b>128</b> tetra‑slices with gliss + vibra.</li>
        <li><b>Pinch + rotate on face</b>: set scan <i>span</i> (pinch) & <i>speed</i> (rotate), add wobble.</li>
        <li><b>Long‑press</b>: confirm + leave glowing trail.</li>
      </ul>
      <p><b>Sound</b> reacts to gesture velocity & zone. Toggle with <i>Audio</i>.</p>
      <p><b>Tip</b>: Tilt your phone—orientation subtly modulates the mix.</p>
    </div>
    <div id="testsPanel" class="tests" aria-label="Tests"></div>
  </main>
  <footer style="padding:8px 10px; color:var(--muted); font-size:11px; border-top:1px solid #0e141b; background:#0b0f14cc;">Single file. Pure Canvas + WebAudio + Vibration. Tetra all the way.</footer>
</div>

<script>
(() => {
  // ===== Utilities =====
  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const now=()=>performance.now();
  const css=(n)=>getComputedStyle(document.documentElement).getPropertyValue(n).trim();

  // ===== Canvas =====
  const canvas=document.getElementById('gl');
  const ctx=canvas.getContext('2d',{alpha:false, desynchronized:true});
  const DPR=Math.min(2,window.devicePixelRatio||1);
  function resize(){ const r=canvas.getBoundingClientRect(); canvas.width=Math.floor(r.width*DPR); canvas.height=Math.floor(r.height*DPR); ctx.setTransform(DPR,0,0,DPR,0,0);} new ResizeObserver(resize).observe(canvas);

  // ===== Audio =====
  let audioOn=true; const AC=new (window.AudioContext||window.webkitAudioContext)();
  const master=AC.createGain(); master.gain.value=.14; master.connect(AC.destination);
  const noiseBuf=(()=>{const len=AC.sampleRate*1.0, b=AC.createBuffer(1,len,AC.sampleRate), d=b.getChannelData(0); for(let i=0;i<len;i++) d[i]=Math.random()*2-1; return b;})()
  const tone=(f=220,type='sine',dur=.12)=>{ if(!audioOn) return; const o=AC.createOscillator(), g=AC.createGain(); o.type=type; o.frequency.value=f; o.connect(g); g.connect(master); const t=AC.currentTime; g.gain.setValueAtTime(.0001,t); g.gain.exponentialRampToValueAtTime(.28,t+.02); g.gain.exponentialRampToValueAtTime(.001,t+dur); o.start(); o.stop(t+dur+.03); }
  const noise=(dur=.18, lp=1800)=>{ if(!audioOn) return; const s=AC.createBufferSource(); s.buffer=noiseBuf; const f=AC.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp; const g=AC.createGain(); s.connect(f); f.connect(g); g.connect(master); const t=AC.currentTime; g.gain.setValueAtTime(.0001,t); g.gain.exponentialRampToValueAtTime(.3,t+.02); g.gain.exponentialRampToValueAtTime(.001,t+dur); s.start(); s.stop(t+dur+.03); }
  const glide=(a=220,b=660,d=.3)=>{ if(!audioOn) return; const o=AC.createOscillator(), g=AC.createGain(); o.type='triangle'; o.connect(g); g.connect(master); const t=AC.currentTime; o.frequency.setValueAtTime(a,t); o.frequency.linearRampToValueAtTime(b,t+d); g.gain.setValueAtTime(.0001,t); g.gain.exponentialRampToValueAtTime(.26,t+.02); g.gain.exponentialRampToValueAtTime(.001,t+d); o.start(); o.stop(t+d+.03); }

  // ===== Haptics =====
  const vibrate=p=>{try{navigator.vibrate&&navigator.vibrate(p)}catch(_){} }
  const haptic={ tapV:()=>vibrate([8,40,8]), edge:()=>vibrate([2,8,2,8,2]), face:()=>vibrate([16,30,16,30,16]), confirm:()=>vibrate([40,60,40]) }

  // ===== Geometry (Tetrahedron) =====
  const V = [ [1,1,1], [-1,-1,1], [-1,1,-1], [1,-1,-1] ]; // regular tetra at origin
  const E = [ [0,1],[0,2],[0,3],[1,2],[1,3],[2,3] ];
  const F = [ [0,1,2], [0,1,3], [0,2,3], [1,2,3] ];
  const FACE_COLORS=[css('--faceA'), css('--faceB'), css('--faceC'), css('--faceD')];
  const EDGE_COLOR=css('--edge'); const VERT_COLOR=css('--accent');
  const TET = ['E','O','R','V']; const LABEL={E:'Enhance',O:'Obsolesce',R:'Retrieve',V:'Reverse'};

  // Strata settings (always tetra, 128 slices parallel to face (1,2,3) from vertex 0)
  const LAYERS = 128; let layerIdx=0, autoRate=0, wobbleAmt=0, rangeScale=1.0;
  function sliceAt(t){ // returns 3 points in 3D for cross‑section plane parallel to base face
    const a=V[1], b=V[2], c=V[3], o=V[0];
    const P1=[o[0]*(1-t)+a[0]*t, o[1]*(1-t)+a[1]*t, o[2]*(1-t)+a[2]*t];
    const P2=[o[0]*(1-t)+b[0]*t, o[1]*(1-t)+b[1]*t, o[2]*(1-t)+b[2]*t];
    const P3=[o[0]*(1-t)+c[0]*t, o[1]*(1-t)+c[1]*t, o[2]*(1-t)+c[2]*t];
    return [P1,P2,P3];
  }

  // Camera & transforms
  let rotX=0.6, rotY=-0.3, rotZ=0, scale=1.25, camDist=5, autoSpin=.00035;
  let tiltX=0, tiltY=0; let trails=[];
  function rotMat(ax,ay,az){ const cx=Math.cos(ax),sx=Math.sin(ax),cy=Math.cos(ay),sy=Math.sin(ay),cz=Math.cos(az),sz=Math.sin(az); return [ cz*cy, cz*sy*sx - sz*cx, cz*sy*cx + sz*sx,  sz*cy, sz*sy*sx + cz*cx, sz*sy*cx - cz*sx,  -sy,  cy*sx,  cy*cx ]; }
  const mul=(m,v)=>{const [x,y,z]=v,s=scale;return[(m[0]*x+m[1]*y+m[2]*z)*s,(m[3]*x+m[4]*y+m[5]*z)*s,(m[6]*x+m[7]*y+m[8]*z)*s]};
  const proj=(p,w,h)=>{const [x,y,z]=p, zz=z+camDist, f=260/zz; return [w*0.5+x*f, h*0.5-y*f, zz]};

  // Picking helpers
  const d2=(a,b)=>Math.hypot(a[0]-b[0],a[1]-b[1]);
  const segD=(p,a,b)=>{ const vx=b[0]-a[0],vy=b[1]-a[1],wx=p[0]-a[0],wy=p[1]-a[1]; const c1=vx*wx+vy*wy; if(c1<=0) return d2(p,a); const c2=vx*vx+vy*vy; if(c2<=c1) return d2(p,b); const t=c1/c2; return Math.hypot(p[0]-(a[0]+t*vx), p[1]-(a[1]+t*vy)); };
  const inTri=(p,a,b,c)=>{ const s=(p,a,b)=>(b[0]-a[0])*(p[1]-a[1])-(b[1]-a[1])*(p[0]-a[0]); const s1=s(p,a,b), s2=s(p,b,c), s3=s(p,c,a); const n=(s1<0)||(s2<0)||(s3<0), pz=(s1>0)||(s2>0)||(s3>0); return !(n&&pz); };

  // Gesture
  const gesture={t0:0,p0:null,p1:null,vIndex:null,eIndex:null,fIndex:null,twoDist:0,twoAngle:0};
  window.addEventListener('deviceorientation', e=>{ if(e && e.beta!=null){ tiltX=clamp((e.beta||0)/90,-1,1); tiltY=clamp((e.gamma||0)/90,-1,1);} }, {passive:true});

  // Hypertext payloads
  const NODE_HTML={
    E:`<b>Enhance</b><br>Amplify capability. <a href="#" data-hop="edge-0">→ morph</a> · <a href="#" data-hop="face-0">▲ field</a>` ,
    O:`<b>Obsolesce</b><br>Quiet prior forms. <a href="#" data-hop="edge-4">→ morph</a> · <a href="#" data-hop="face-1">▲ field</a>` ,
    R:`<b>Retrieve</b><br>Echo past strata. <a href="#" data-hop="edge-3">→ morph</a> · <a href="#" data-hop="face-2">▲ field</a>` ,
    V:`<b>Reverse</b><br>Flip at extremes. <a href="#" data-hop="edge-5">→ morph</a> · <a href="#" data-hop="face-3">▲ field</a>`
  };

  // UI wiring
  const panel=document.getElementById('info');
  const panelTitle=document.getElementById('panelTitle');
  const panelBody=document.getElementById('panelBody');
  const toast=document.getElementById('toast');
  const help=document.getElementById('help');
  const testsPanel=document.getElementById('testsPanel');
  document.getElementById('helpBtn').onclick=()=>help.classList.toggle('show');
  document.getElementById('testBtn').onclick=()=>{ testsPanel.classList.toggle('show'); if(testsPanel.classList.contains('show')) runTests(); };
  document.getElementById('resetBtn').onclick=()=>{ rotX=0.6; rotY=-0.3; rotZ=0; scale=1.25; trails.length=0; setLayer(0); announce('Reset.'); };
  document.getElementById('muteBtn').onclick=(e)=>{ audioOn=!audioOn; e.currentTarget.textContent=audioOn?'Audio: On':'Audio: Off'; announce(audioOn?'Audio enabled.':'Audio muted.'); };
  panel.addEventListener('click',(ev)=>{ const j=ev.target.closest('[data-jump]'); const hop=ev.target.closest('[data-hop]'); if(j){ const key=j.getAttribute('data-jump'); openNode(key); ev.preventDefault(); } if(hop){ const k=hop.getAttribute('data-hop'); if(k.startsWith('edge-')) pulseEdge(parseInt(k.split('-')[1])); else if(k.startsWith('face-')) pulseFace(parseInt(k.split('-')[1])); ev.preventDefault(); } });

  function announce(t){ toast.textContent=t; toast.classList.add('show'); clearTimeout(announce._t); announce._t=setTimeout(()=>toast.classList.remove('show'), 1100); }
  function openNode(key){ panelTitle.textContent=LABEL[key]; panelBody.innerHTML=NODE_HTML[key]; tone(key==='E'?520: key==='O'?280: key==='R'?390: 180,'sine',.14); haptic.tapV(); const map={E:0,O:Math.floor(LAYERS*0.33),R:Math.floor(LAYERS*0.66),V:LAYERS-1}; setLayer(map[key]||0); }
  function pulseEdge(i){ glide(220+80*i,520+40*i,.35); haptic.edge(); trails.push({edge:i,life:1}); announce('Edge morph'); const pairs=[[0,.33],[0,.66],[0,1],[.33,.66],[.33,1],[.66,1]]; const [a,b]=pairs[i]||[0,1]; const t=(Math.sin(performance.now()*0.004)+1)/2; setLayer(Math.round(lerp(a,b,t)*(LAYERS-1))); }
  function pulseFace(i){ noise(.28,1400-200*i); haptic.face(); trails.push({face:i,life:1}); announce('Face field'); setAuto(.5+i*0.2); setRange(1.0+i*0.1); }

  // Input handling
  let pressing=false, longPressTimer=null; const pt=(ev)=>{ const r=canvas.getBoundingClientRect(); if(ev.touches && ev.touches.length){ return Array.from(ev.touches).map(t=>[t.clientX-r.left,t.clientY-r.top]); } return [[ev.clientX-r.left, ev.clientY-r.top]]; };
  canvas.addEventListener('contextmenu', e=>e.preventDefault());
  canvas.addEventListener('pointerdown', e=>{ canvas.setPointerCapture(e.pointerId); pressing=true; const p=pt(e)[0]; startGesture(p); longPressTimer=setTimeout(()=>{ haptic.confirm(); trails.push({mark:[p[0],p[1]],life:1}); announce('Marked.'); }, 650); });
  window.addEventListener('pointermove', e=>{ if(!pressing) return; const p=pt(e)[0]; moveGesture(p); });
  window.addEventListener('pointerup', ()=>{ pressing=false; clearTimeout(longPressTimer); endGesture(); });
  canvas.addEventListener('touchstart', e=>{ if(e.touches.length===2){ const [a,b]=pt(e); gesture.twoDist=Math.hypot(a[0]-b[0],a[1]-b[1]); gesture.twoAngle=Math.atan2(b[1]-a[1], b[0]-a[0]); } }, {passive:true});
  canvas.addEventListener('touchmove', (e)=>{ if(e.touches.length===2 && gesture.fIndex!=null){ const [a,b]=pt(e); const d=Math.hypot(a[0]-b[0],a[1]-b[1]), ang=Math.atan2(b[1]-a[1], b[0]-a[0]); const pinch=(d-gesture.twoDist)/200; const rot=(ang-gesture.twoAngle); scale=clamp(scale+pinch*0.6,0.7,2.0); rotZ+=rot*0.8; noise(.12,1200+400*Math.abs(pinch)); haptic.face(); setRange(scale); setAuto(Math.abs(rot)); e.preventDefault(); } }, {passive:false});

  function startGesture(p){ gesture.t0=now(); gesture.p0=p; gesture.p1=p; pickAt(p); }
  function moveGesture(p){ gesture.p1=p; if(gesture.vIndex!=null){ rotY+=(p[0]-gesture.p0[0])*0.002; rotX+=(p[1]-gesture.p0[1])*0.002; glide(260,420,.18); } else if(gesture.eIndex!=null){ haptic.edge(); glide(260,620,.2); const nx=clamp(p[0]/canvas.clientWidth,0,1); setLayer(Math.round(nx*(LAYERS-1))); } else if(gesture.fIndex!=null){ haptic.face(); noise(.1,1500); wobbleAmt=0.5+0.5*Math.sin(performance.now()*0.003); } else { rotY+=(p[0]-gesture.p0[0])*0.0015; rotX+=(p[1]-gesture.p0[1])*0.0015; } gesture.p0=p; }
  function endGesture(){ const dt=now()-gesture.t0; if(dt<250 && gesture.vIndex!=null){ openNode(TET[gesture.vIndex]); } gesture.vIndex=gesture.eIndex=gesture.fIndex=null; }

  function pickAt(p){ const w=canvas.clientWidth,h=canvas.clientHeight,m=rotMat(rotX,rotY,rotZ); const PV=V.map(v=>proj(mul(m,v),w,h)); for(let i=0;i<PV.length;i++){ if(d2(p,PV[i])<18){ gesture.vIndex=i; haptic.tapV(); return; }} for(let i=0;i<E.length;i++){ const a=PV[E[i][0]],b=PV[E[i][1]]; if(segD(p,a,b)<12){ gesture.eIndex=i; return; }} for(let i=0;i<F.length;i++){ const a=PV[F[i][0]],b=PV[F[i][1]],c=PV[F[i][2]]; if(inTri(p,a,b,c)){ gesture.fIndex=i; return; }} }

  // ==== Layer engine (tetra only) ====
  function setLayer(i){ const prev=layerIdx; layerIdx=Math.max(0,Math.min(LAYERS-1,i|0)); if(prev!==layerIdx && 'vibrate' in navigator) navigator.vibrate(4); document.getElementById('panelTitle').dataset.layer=String(layerIdx+1); }
  function setAuto(amount){ autoRate=Math.min(2.0, Math.max(0.0, amount*4)); }
  function setRange(scale){ rangeScale=Math.min(2.0, Math.max(0.6, scale)); }

  // Render loop
  function draw(){ const w=canvas.clientWidth,h=canvas.clientHeight; if(canvas.width!==Math.floor(w*DPR)) resize(); ctx.fillStyle=css('--bg'); ctx.fillRect(0,0,w,h); rotY+=autoSpin+tiltY*0.0005; rotX+=tiltX*0.0005; const m=rotMat(rotX,rotY,rotZ);
    const PV=V.map(v=>proj(mul(m,v),w,h));
    // faces back-to-front
    const faces=F.map((f,i)=>({i,z:(PV[f[0]][2]+PV[f[1]][2]+PV[f[2]][2])/3})).sort((a,b)=>b.z-a.z);
    for(const fd of faces){ const i=fd.i; const a=PV[F[i][0]],b=PV[F[i][1]],c=PV[F[i][2]]; ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.lineTo(c[0],c[1]); ctx.closePath(); ctx.fillStyle=FACE_COLORS[i]; ctx.fill(); }
    // edges
    ctx.lineWidth=2; ctx.strokeStyle=EDGE_COLOR; for(const e of E){ const a=PV[e[0]],b=PV[e[1]]; ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.stroke(); }
    // vertices
    for(const p of PV){ ctx.beginPath(); ctx.arc(p[0],p[1],6,0,Math.PI*2); ctx.fillStyle=VERT_COLOR; ctx.shadowColor='rgba(88,213,255,.6)'; ctx.shadowBlur=12; ctx.fill(); ctx.shadowBlur=0; }

    // strata triangles (parallel slices)
    const span=Math.floor((LAYERS-1)*(0.25*rangeScale));
    const wobble = wobbleAmt? Math.sin(performance.now()*0.0018)*wobbleAmt : 0;
    if(autoRate>0){ const t=performance.now()*0.001*autoRate; const a=(Math.sin(t)*0.5+0.5)+wobble; const target=Math.max(0,Math.min(LAYERS-1, Math.round(layerIdx - span + (span*2)*a))); setLayer(target); }
    const start=Math.max(0, layerIdx-span), end=Math.min(LAYERS-1, layerIdx+span);
    for(let i=start;i<=end;i+=1){ const t=i/(LAYERS-1); const tri3D=sliceAt(t).map(p=>proj(mul(m,p),w,h)); const alpha = i===layerIdx ? 0.8 : 0.08 + 0.6*(1-Math.abs(i-layerIdx)/(span||1)); ctx.globalAlpha=clamp(alpha,0.08,0.85); ctx.beginPath(); ctx.moveTo(tri3D[0][0],tri3D[0][1]); ctx.lineTo(tri3D[1][0],tri3D[1][1]); ctx.lineTo(tri3D[2][0],tri3D[2][1]); ctx.closePath(); ctx.strokeStyle='rgba(221,231,255,0.9)'; ctx.lineWidth = i===layerIdx ? 3 : 1; ctx.stroke(); ctx.globalAlpha=1; }

    // trails
    trails=trails.filter(t=>(t.life-=0.01)>0);
    for(const t of trails){ if(t.edge!=null){ const e=E[t.edge]; const a=PV[e[0]],b=PV[e[1]]; ctx.globalAlpha=Math.max(0,t.life); ctx.lineWidth=4; ctx.strokeStyle='rgba(88,213,255,.5)'; ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.stroke(); ctx.globalAlpha=1; } else if(t.face!=null){ const f=F[t.face]; const a=PV[f[0]],b=PV[f[1]],c=PV[f[2]]; ctx.globalAlpha=Math.max(0,t.life*0.7); ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.lineTo(c[0],c[1]); ctx.closePath(); ctx.fillStyle='rgba(255,211,94,.22)'; ctx.fill(); ctx.globalAlpha=1; } else if(t.mark){ ctx.globalAlpha=Math.max(0,t.life); ctx.beginPath(); ctx.arc(t.mark[0], t.mark[1], 10+8*(1-t.life), 0, Math.PI*2); ctx.strokeStyle='rgba(156,255,138,.7)'; ctx.lineWidth=2; ctx.stroke(); ctx.globalAlpha=1; } }

    requestAnimationFrame(draw);
  }
  resize(); setLayer(0); draw();

  // Tests
  function runTests(){ const tests=[]; const add=(n,fn)=>{ try{ tests.push({n,ok:!!fn()}); }catch(e){ tests.push({n,ok:false,err:e.message}); } }; add('No duplicate identifiers',()=> typeof FACE_COLORS!=='undefined' && typeof EDGE_COLOR!=='undefined' && typeof VERT_COLOR!=='undefined'); add('Geometry sizes',()=> V.length===4 && E.length===6 && F.length===4); add('Layers count',()=> LAYERS===128); add('SliceAt works',()=> sliceAt(0).length===3 && sliceAt(1).length===3); const el=document.getElementById('testsPanel'); el.innerHTML = `<b>Self‑tests</b><br>${tests.map(t=>`• ${t.ok?'✅':'❌'} ${t.n}${t.err?' — '+t.err:''}`).join('<br>')}`; announce(`${tests.filter(t=>t.ok).length}/${tests.length} tests passed`); }

  // Welcome
  setTimeout(()=>announce('Pure tetrahedral engine: edges scrub 128 strata, faces modulate span/speed.'), 700);
})();
</script>
</body>
</html>
