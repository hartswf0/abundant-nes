<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Hypertetrahedral Hypertext Gizmo — fused with 64‑Layer Media Cube</title>
<style>
  :root{
    --bg:#07090c; --fg:#eaf4ff; --muted:#9fb6ca; --accent:#58d5ff; --accent2:#ff7aa8; --ok:#9cff8a; --warn:#ffd35e;
    --edge:#6ea9ff; --faceA:#102132; --faceB:#0f2b28; --faceC:#2a1f36; --faceD:#2f2810; --glow:0 0 24px rgba(88,213,255,.35);
  }
  html,body{height:100%; background:var(--bg); color:var(--fg); font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;}
  *{box-sizing:border-box}
  #app{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr auto;}
  header{padding:10px env(safe-area-inset-left) 6px env(safe-area-inset-right); display:flex; align-items:center; gap:8px; border-bottom:1px solid #0e141b; background:#0b0f14cc; backdrop-filter:saturate(1.2) blur(8px);}
  header h1{font-size:14px; font-weight:600; letter-spacing:.3px; margin:0; color:var(--muted)}
  header .pill{margin-left:auto; display:flex; gap:6px}
  .btn{appearance:none; border:1px solid #1d2730; background:#0e141a; color:var(--fg); padding:8px 10px; border-radius:999px; font-size:12px; letter-spacing:.2px}
  .btn:active{transform:scale(.98)}
  .btn.primary{border-color:#0b2f3b; background:#0b1c25; box-shadow:var(--glow)}
  main{position:relative; overflow:hidden}
  canvas#gl{position:absolute; inset:0; width:100%; height:100%; touch-action:none; outline:none}
  /* Layer Cube viewport */
  .cubeDock{position:absolute; right:10px; bottom:10px; width:min(46vw,420px); height:min(46vw,320px); border-radius:14px; border:1px solid #17222b; background:#0b0f14e0; backdrop-filter:blur(8px); box-shadow:0 8px 30px rgba(0,0,0,.45); display:grid; grid-template-rows:auto 1fr; overflow:hidden}
  .cubeDock header{display:flex; align-items:center; justify-content:space-between; gap:8px; padding:8px 10px; border-bottom:1px solid #13202c; background:#0c1117}
  .cubeDock header .ttl{font-size:12px; color:#d7eaff}
  .cubeDock header .layer{font-variant-numeric:tabular-nums; font-size:12px; color:#c9a227}
  .cubeDock canvas{width:100%; height:100%; display:block}

  .hud{position:absolute; left:10px; bottom:10px; right:10px; display:flex; gap:8px; pointer-events:none}
  .legend{pointer-events:auto; flex:1; background:#0c1117d0; border:1px solid #171e27; border-radius:14px; padding:10px; display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .legend .chip{display:inline-flex; align-items:center; gap:6px; padding:6px 8px; border-radius:999px; background:#0a1620; border:1px solid #13202c; font-size:11px}
  .legend .dot{inline-size:10px; block-size:10px; border-radius:999px}
  .legend .dot.v{background:var(--accent)}
  .legend .dot.e{background:var(--edge)}
  .legend .dot.f{background:var(--warn)}
  .panel{pointer-events:auto; min-inline-size:46%; max-width:60%; background:#0c1117e0; border:1px solid #17222b; border-radius:14px; padding:10px; font-size:12px; overflow:auto; max-height:40vh}
  .panel h2{margin:.2em 0 .4em; font-size:13px; color:var(--accent)}
  .panel p{margin:.5em 0; color:var(--muted)}
  .panel .grid{display:grid; grid-template-columns:repeat(2, minmax(0,1fr)); gap:6px}
  .panel a{color:var(--accent2); text-decoration:none}
  .panel a:focus,.panel a:hover{text-decoration:underline}
  .toast{position:absolute; inset:auto 12px 60px 12px; background:#0a0f14; border:1px solid #13202c; color:var(--ok); border-radius:10px; padding:8px 10px; font-size:12px; opacity:0; transform:translateY(8px); transition:opacity .25s, transform .25s}
  .toast.show{opacity:1; transform:none}
  .help{position:absolute; top:10px; right:10px; background:#0c1117; border:1px solid #12202b; padding:10px; border-radius:12px; max-width:72ch; font-size:12px; color:var(--muted); display:none}
  .help.show{display:block}
  .tests{position:absolute; top:10px; left:10px; background:#0c1117; border:1px solid #12202b; padding:10px; border-radius:12px; max-width:72ch; font-size:12px; color:var(--muted); display:none}
  .tests.show{display:block}
  @media (prefers-reduced-motion: reduce){ *{scroll-behavior:auto} .btn:active{transform:none} }
</style>
<!-- Importmap for Three.js (module script below) -->
<script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}</script>
</head>
<body>
<div id="app" aria-live="polite" aria-atomic="true">
  <header>
    <h1>Hypertetrahedral Hypertext Gizmo × Layer Strata</h1>
    <div class="pill">
      <button id="helpBtn" class="btn">Help</button>
      <button id="testBtn" class="btn">Tests</button>
      <button id="resetBtn" class="btn">Reset</button>
      <button id="muteBtn" class="btn primary">Audio: On</button>
    </div>
  </header>
  <main>
    <canvas id="gl" aria-label="Hypertetrahedron canvas"></canvas>

    <!-- Docked Layer Cube (latent media space) -->
    <section class="cubeDock" aria-label="Layer Cube Latent Space">
      <header><span class="ttl">Latent Media Strata</span><span id="layerReadout" class="layer">01 / 64</span></header>
      <canvas id="cube"></canvas>
    </section>

    <div class="hud">
      <div class="legend" role="group" aria-label="Legend">
        <span class="chip"><span class="dot v"></span> vertex = tetrad node</span>
        <span class="chip"><span class="dot e"></span> edge = strata scrub</span>
        <span class="chip"><span class="dot f"></span> face = tri‑mix field</span>
        <span class="chip">tilt = micro‑mod</span>
      </div>
      <aside id="info" class="panel" aria-label="Hypertext panel">
        <h2 id="panelTitle">Tetrad</h2>
        <div class="grid">
          <div><strong>Enhance</strong><br><a href="#" data-jump="E">open</a></div>
          <div><strong>Obsolesce</strong><br><a href="#" data-jump="O">open</a></div>
          <div><strong>Retrieve</strong><br><a href="#" data-jump="R">open</a></div>
          <div><strong>Reverse</strong><br><a href="#" data-jump="V">open</a></div>
        </div>
        <p id="panelBody">Tap <em>vertices</em> to enter nodes; drag an <em>edge</em> to scrub strata; pinch/rotate a <em>face</em> to mix triads & modulate the latent media cube.</p>
      </aside>
    </div>
    <div id="toast" class="toast" role="status"></div>
    <div id="help" class="help">
      <strong>Gestures</strong>
      <ul>
        <li><b>Tap vertex</b>: open tetrad node (E/O/R/V) & jump to mapped strata range.</li>
        <li><b>Drag along edge</b>: scrub layers 1–64 (latent media strata) with gliss + vibra.</li>
        <li><b>Pinch + rotate on face</b>: blend triads & wobble strata; pinch = range; rotate = autoplay rate.</li>
        <li><b>Long‑press</b>: confirm + leave glowing trail.</li>
      </ul>
      <p><b>Sound</b> reacts to gesture velocity & zone. Toggle with <i>Audio</i>.</p>
      <p><b>Tip</b>: Tilt your phone—orientation subtly modulates the mix.</p>
    </div>
    <div id="testsPanel" class="tests" aria-label="Tests"></div>
  </main>
  <footer style="padding:8px 10px; color:var(--muted); font-size:11px; border-top:1px solid #0e141b; background:#0b0f14cc;">Single file. Canvas (tetrahedron) + WebAudio + Vibration + Three.js (latents). Fused control surface.</footer>
</div>

<script>
(() => {
  // ===== Utilities =====
  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const now=()=>performance.now();
  const getCss=(name)=>getComputedStyle(document.documentElement).getPropertyValue(name).trim();

  // ===== Canvas & sizing =====
  const canvas = document.getElementById('gl');
  const ctx = canvas.getContext('2d', {alpha:false, desynchronized:true});
  const DPR = Math.min(2, window.devicePixelRatio || 1);
  function resize(){ const r=canvas.getBoundingClientRect(); canvas.width=Math.floor(r.width*DPR); canvas.height=Math.floor(r.height*DPR); ctx.setTransform(DPR,0,0,DPR,0,0); }
  const ro=new ResizeObserver(resize); ro.observe(canvas);

  // ===== Audio =====
  let audioOn = true; const AC = new (window.AudioContext||window.webkitAudioContext)();
  let masterGain = AC.createGain(); masterGain.gain.value=.14; masterGain.connect(AC.destination);
  const noiseBuf = (()=>{ const len=AC.sampleRate*1.0, buf=AC.createBuffer(1,len,AC.sampleRate), d=buf.getChannelData(0); for(let i=0;i<len;i++) d[i]=Math.random()*2-1; return buf; })();
  const tone=(f=220,type='sine',dur=.12)=>{ if(!audioOn) return; const o=AC.createOscillator(), g=AC.createGain(); o.type=type; o.frequency.value=f; o.connect(g); g.connect(masterGain); const t=AC.currentTime; g.gain.setValueAtTime(.0001,t); g.gain.exponentialRampToValueAtTime(.28,t+.02); g.gain.exponentialRampToValueAtTime(.001,t+dur); o.start(); o.stop(t+dur+.03); };
  const noise=(dur=.18, lp=1800)=>{ if(!audioOn) return; const s=AC.createBufferSource(); s.buffer=noiseBuf; const f=AC.createBiquadFilter(); f.type='lowpass'; f.frequency.value=lp; const g=AC.createGain(); s.connect(f); f.connect(g); g.connect(masterGain); const t=AC.currentTime; g.gain.setValueAtTime(.0001,t); g.gain.exponentialRampToValueAtTime(.3,t+.02); g.gain.exponentialRampToValueAtTime(.001,t+dur); s.start(); s.stop(t+dur+.03); };
  const glide=(a=220,b=660,d=.3)=>{ if(!audioOn) return; const o=AC.createOscillator(), g=AC.createGain(); o.type='triangle'; o.connect(g); g.connect(masterGain); const t=AC.currentTime; o.frequency.setValueAtTime(a,t); o.frequency.linearRampToValueAtTime(b,t+d); g.gain.setValueAtTime(.0001,t); g.gain.exponentialRampToValueAtTime(.26,t+.02); g.gain.exponentialRampToValueAtTime(.001,t+d); o.start(); o.stop(t+d+.03); };

  // ===== Haptics =====
  const vibrate = p=>{ try{ navigator.vibrate && navigator.vibrate(p);}catch(_){} };
  const haptic = { tapV:()=>vibrate([8,40,8]), edge:()=>vibrate([2,8,2,8,2]), face:()=>vibrate([16,30,16,30,16]), confirm:()=>vibrate([40,60,40]) };

  // ===== Geometry (Tetrahedron) =====
  const V = [ [1,1,1], [-1,-1,1], [-1,1,-1], [1,-1,-1] ];
  const E = [ [0,1],[0,2],[0,3],[1,2],[1,3],[2,3] ];
  const F = [ [0,1,2], [0,1,3], [0,2,3], [1,2,3] ];
  const COLORS = [getCss('--faceA'), getCss('--faceB'), getCss('--faceC'), getCss('--faceD')];
  const EDGE = getCss('--edge'); const VERT = getCss('--accent');
  const TET = ['E','O','R','V']; const LABEL = {E:'Enhance',O:'Obsolesce',R:'Retrieve',V:'Reverse'};

  // State
  let rotX=0.6, rotY=-0.3, rotZ=0, scale=1.25, camDist=5, autoSpin=.00035;
  let trails=[]; let tiltX=0, tiltY=0; 

  // Math helpers
  function rotMat(ax, ay, az){ const cx=Math.cos(ax), sx=Math.sin(ax), cy=Math.cos(ay), sy=Math.sin(ay), cz=Math.cos(az), sz=Math.sin(az); return [ cz*cy, cz*sy*sx - sz*cx, cz*sy*cx + sz*sx,  sz*cy, sz*sy*sx + cz*cx, sz*sy*cx - cz*sx,  -sy,  cy*sx,  cy*cx ]; }
  const mul=(m,v)=>{const [x,y,z]=v,s=scale;return[(m[0]*x+m[1]*y+m[2]*z)*s,(m[3]*x+m[4]*y+m[5]*z)*s,(m[6]*x+m[7]*y+m[8]*z)*s]};
  const project=(p,w,h)=>{const [x,y,z]=p, zz=z+camDist, f=260/zz; return [w*0.5+x*f, h*0.5-y*f, zz]};
  const dist2=(a,b)=>Math.hypot(a[0]-b[0],a[1]-b[1]);
  const segDist=(p,a,b)=>{const vx=b[0]-a[0],vy=b[1]-a[1],wx=p[0]-a[0],wy=p[1]-a[1],c1=vx*wx+vy*wy; if(c1<=0) return dist2(p,a); const c2=vx*vx+vy*vy; if(c2<=c1) return dist2(p,b); const t=c1/c2; return Math.hypot(p[0]-(a[0]+t*vx), p[1]-(a[1]+t*vy));};
  const insideTri=(p,a,b,c)=>{const s=(p,a,b)=>(b[0]-a[0])*(p[1]-a[1])-(b[1]-a[1])*(p[0]-a[0]); const s1=s(p,a,b), s2=s(p,b,c), s3=s(p,c,a); const hasNeg=(s1<0)||(s2<0)||(s3<0); const hasPos=(s1>0)||(s2>0)||(s3>0); return !(hasNeg&&hasPos);} 

  // Gesture
  const gesture={t0:0,p0:null,p1:null,vIndex:null,eIndex:null,fIndex:null,twoDist:0,twoAngle:0};

  // Orientation
  window.addEventListener('deviceorientation', e=>{ if(e && e.beta!=null){ tiltX=clamp((e.beta||0)/90,-1,1); tiltY=clamp((e.gamma||0)/90,-1,1);} }, {passive:true});

  // Hypertext payloads
  const NODE_HTML={
    E:`<b>Enhance</b><br>Amplify a capability. <a href="#" data-hop="edge-0">→ morph</a> · <a href="#" data-hop="face-0">▲ field</a>` ,
    O:`<b>Obsolesce</b><br>Quiet what came before. <a href="#" data-hop="edge-4">→ morph</a> · <a href="#" data-hop="face-1">▲ field</a>` ,
    R:`<b>Retrieve</b><br>Bring back prior forms. <a href="#" data-hop="edge-3">→ morph</a> · <a href="#" data-hop="face-2">▲ field</a>` ,
    V:`<b>Reverse</b><br>Flip at the extreme. <a href="#" data-hop="edge-5">→ morph</a> · <a href="#" data-hop="face-3">▲ field</a>`
  };

  // UI
  const panel=document.getElementById('info');
  const panelTitle=document.getElementById('panelTitle');
  const panelBody=document.getElementById('panelBody');
  const toast=document.getElementById('toast');
  const help=document.getElementById('help');
  const testsPanel=document.getElementById('testsPanel');
  document.getElementById('helpBtn').onclick=()=>help.classList.toggle('show');
  document.getElementById('testBtn').onclick=()=>{ testsPanel.classList.toggle('show'); if(testsPanel.classList.contains('show')) runTests(); };
  document.getElementById('resetBtn').onclick=()=>{ rotX=0.6; rotY=-0.3; rotZ=0; scale=1.25; trails.length=0; announce('Reset.'); window.LayerCube && LayerCube.setLayer(0); };
  document.getElementById('muteBtn').onclick=(e)=>{ audioOn=!audioOn; e.currentTarget.textContent = audioOn? 'Audio: On' : 'Audio: Off'; announce(audioOn?'Audio enabled.':'Audio muted.'); };
  panel.addEventListener('click',(ev)=>{ const j=ev.target.closest('[data-jump]'); const hop=ev.target.closest('[data-hop]'); if(j){ const key=j.getAttribute('data-jump'); openNode(key); ev.preventDefault(); } if(hop){ const k=hop.getAttribute('data-hop'); if(k.startsWith('edge-')) pulseEdge(parseInt(k.split('-')[1])); else if(k.startsWith('face-')) pulseFace(parseInt(k.split('-')[1])); ev.preventDefault(); } });

  function announce(t){ toast.textContent=t; toast.classList.add('show'); clearTimeout(announce._t); announce._t=setTimeout(()=>toast.classList.remove('show'), 1100); }
  function openNode(key){ panelTitle.textContent=LABEL[key]; panelBody.innerHTML=NODE_HTML[key]; tone(key==='E'?520: key==='O'?280: key==='R'?390: 180,'sine',.14); haptic.tapV(); // map vertices → strata quartiles
    const map={E:0,O:21,R:42,V:63}; window.LayerCube && LayerCube.setLayer(map[key]||0); }
  function pulseEdge(i){ glide(220+80*i,520+40*i,.35); haptic.edge(); trails.push({edge:i,life:1}); announce('Edge morph'); // edge scrub between its two vertex target layers
    const pairs=[[0,21],[0,42],[0,63],[21,42],[21,63],[42,63]]; const [a,b]=pairs[i]||[0,63]; const t=(Math.sin(performance.now()*0.004)+1)/2; window.LayerCube && LayerCube.setLayer(Math.round(a+(b-a)*t)); }
  function pulseFace(i){ noise(.28,1400-200*i); haptic.face(); trails.push({face:i,life:1}); announce('Face field'); // widen range & enable wobble
    window.LayerCube && LayerCube.wobble(i*0.33+0.5); }

  // Input handling
  let pressing=false, longPressTimer=null; const pt=(ev)=>{ const r=canvas.getBoundingClientRect(); if(ev.touches && ev.touches.length){ return Array.from(ev.touches).map(t=>[t.clientX-r.left,t.clientY-r.top]); } return [[ev.clientX-r.left, ev.clientY-r.top]]; };
  canvas.addEventListener('contextmenu', e=>e.preventDefault());
  canvas.addEventListener('pointerdown', e=>{ canvas.setPointerCapture(e.pointerId); pressing=true; const p=pt(e)[0]; startGesture(p); longPressTimer=setTimeout(()=>{ haptic.confirm(); trails.push({mark:[p[0],p[1]],life:1}); announce('Marked.'); }, 650); });
  window.addEventListener('pointermove', e=>{ if(!pressing) return; const p=pt(e)[0]; moveGesture(p); });
  window.addEventListener('pointerup', ()=>{ pressing=false; clearTimeout(longPressTimer); endGesture(); });

  canvas.addEventListener('touchstart', e=>{ if(e.touches.length===2){ const [a,b]=pt(e); gesture.twoDist=Math.hypot(a[0]-b[0],a[1]-b[1]); gesture.twoAngle=Math.atan2(b[1]-a[1], b[0]-a[0]); } }, {passive:true});
  canvas.addEventListener('touchmove', (e)=>{ if(e.touches.length===2 && gesture.fIndex!=null){ const [a,b]=pt(e); const d=Math.hypot(a[0]-b[0],a[1]-b[1]), ang=Math.atan2(b[1]-a[1], b[0]-a[0]); const pinch=(d-gesture.twoDist)/200; const rot=(ang-gesture.twoAngle); scale=clamp(scale+pinch*0.6,0.7,2.0); rotZ+=rot*0.8; noise(.12,1200+400*Math.abs(pinch)); haptic.face(); // pinch sets LayerCube range, rotate sets autoplay speed
      window.LayerCube && LayerCube.setRange(scale); window.LayerCube && LayerCube.setAuto(Math.abs(rot)); e.preventDefault(); } }, {passive:false});

  function startGesture(p){ gesture.t0=now(); gesture.p0=p; gesture.p1=p; pickAt(p); }
  function moveGesture(p){ gesture.p1=p; if(gesture.vIndex!=null){ rotY+=(p[0]-gesture.p0[0])*0.002; rotX+=(p[1]-gesture.p0[1])*0.002; glide(260,420,.18); } else if(gesture.eIndex!=null){ haptic.edge(); glide(260,620,.2); // scrub across full 64
      const nx=(p[0]/canvas.clientWidth); const idx=Math.round(nx*63); window.LayerCube && LayerCube.setLayer(idx); } else if(gesture.fIndex!=null){ haptic.face(); noise(.1,1500); window.LayerCube && LayerCube.wobble(0.5+0.5*Math.sin(performance.now()*0.003)); } else { rotY+=(p[0]-gesture.p0[0])*0.0015; rotX+=(p[1]-gesture.p0[1])*0.0015; }
    gesture.p0=p; }
  function endGesture(){ const dt=now()-gesture.t0; if(dt<250 && gesture.vIndex!=null){ openNode(TET[gesture.vIndex]); } else if(gesture.eIndex!=null){ /* already scrubbed */ } else if(gesture.fIndex!=null){ /* face handled */ } gesture.vIndex=gesture.eIndex=gesture.fIndex=null; }

  function pickAt(p){ const w=canvas.clientWidth,h=canvas.clientHeight,m=rotMat(rotX,rotY,rotZ); const PV=V.map(v=>project(mul(m,v),w,h)); for(let i=0;i<PV.length;i++){ if(dist2(p,PV[i])<18){ gesture.vIndex=i; haptic.tapV(); return; }} for(let i=0;i<E.length;i++){ const a=PV[E[i][0]],b=PV[E[i][1]]; if(segDist(p,a,b)<12){ gesture.eIndex=i; return; }} for(let i=0;i<F.length;i++){ const a=PV[F[i][0]],b=PV[F[i][1]],c=PV[F[i][2]]; if(insideTri(p,a,b,c)){ gesture.fIndex=i; return; }} }

  // Render loop
  function draw(){ const w=canvas.clientWidth,h=canvas.clientHeight; if(canvas.width!==Math.floor(w*DPR)) resize(); ctx.fillStyle=getCss('--bg'); ctx.fillRect(0,0,w,h); rotY+=autoSpin+tiltY*0.0005; rotX+=tiltX*0.0005; const m=rotMat(rotX,rotY,rotZ); const PV=V.map(v=>project(mul(m,v),w,h)); const faceDepth=F.map((f,i)=>({i,z:(PV[f[0]][2]+PV[f[1]][2]+PV[f[2]][2])/3})).sort((a,b)=>b.z-a.z); for(const fd of faceDepth){ const i=fd.i; const a=PV[F[i][0]],b=PV[F[i][1]],c=PV[F[i][2]]; ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.lineTo(c[0],c[1]); ctx.closePath(); ctx.fillStyle=COLORS[i]; ctx.fill(); }
    ctx.lineWidth=2; ctx.strokeStyle=EDGE; for(const e of E){ const a=PV[e[0]],b=PV[e[1]]; ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.stroke(); }
    for(let i=0;i<PV.length;i++){ const p=PV[i]; ctx.beginPath(); ctx.arc(p[0],p[1],6,0,Math.PI*2); ctx.fillStyle=VERT; ctx.shadowColor='rgba(88,213,255,.6)'; ctx.shadowBlur=12; ctx.fill(); ctx.shadowBlur=0; }
    trails=trails.filter(t=>(t.life-=0.01)>0); for(const t of trails){ if(t.edge!=null){ const e=E[t.edge]; const a=PV[e[0]],b=PV[e[1]]; ctx.globalAlpha=Math.max(0,t.life); ctx.lineWidth=4; ctx.strokeStyle='rgba(88,213,255,.5)'; ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.stroke(); ctx.globalAlpha=1; } else if(t.face!=null){ const f=F[t.face]; const a=PV[f[0]],b=PV[f[1]],c=PV[f[2]]; ctx.globalAlpha=Math.max(0,t.life*0.7); ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.lineTo(c[0],c[1]); ctx.closePath(); ctx.fillStyle='rgba(255,211,94,.22)'; ctx.fill(); ctx.globalAlpha=1; } else if(t.mark){ ctx.globalAlpha=Math.max(0,t.life); ctx.beginPath(); ctx.arc(t.mark[0], t.mark[1], 10+8*(1-t.life), 0, Math.PI*2); ctx.strokeStyle='rgba(156,255,138,.7)'; ctx.lineWidth=2; ctx.stroke(); ctx.globalAlpha=1; }} requestAnimationFrame(draw); }
  resize(); draw();

  // Tests
  function runTests(){ const tests=[]; const add=(n,fn)=>{ try{ tests.push({n,ok:!!fn()}); }catch(e){ tests.push({n,ok:false,err:e.message}); } }; add('No duplicate identifiers',()=> typeof COLORS!=='undefined'&&typeof EDGE!=='undefined'&&typeof VERT!=='undefined'); add('Geometry sizes',()=> V.length===4 && E.length===6 && F.length===4); add('LayerCube bridge',()=> typeof window.LayerCube==='object' && typeof LayerCube.setLayer==='function'); const el=document.getElementById('testsPanel'); el.innerHTML = `<b>Self‑tests</b><br>${tests.map(t=>`• ${t.ok?'✅':'❌'} ${t.n}${t.err?' — '+t.err:''}`).join('<br>')}`; announce(`${tests.filter(t=>t.ok).length}/${tests.length} tests passed`); }

  // Welcome
  setTimeout(()=>announce('Fused: vertices/edges/faces now drive the 64‑layer latent cube → try an edge drag'), 700);
})();
</script>

<!-- Three.js latent media strata (compact, module scope) -->
<script type="module">
  import * as THREE from 'three';
  const canvas = document.getElementById('cube');
  const readout = document.getElementById('layerReadout');
  const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
  const DPR = Math.min(devicePixelRatio||1,2); renderer.setPixelRatio(DPR);
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100); camera.position.set(3.6,3.0,3.6); camera.lookAt(0,0,0);
  const resize=()=>{ const r=canvas.getBoundingClientRect(); renderer.setSize(r.width, r.height, false); camera.aspect=r.width/r.height; camera.updateProjectionMatrix();}; new ResizeObserver(resize).observe(canvas);
  const SIZE=2.3, HALF=SIZE/2, COUNT=64; const group=new THREE.Group(); scene.add(group);
  const box = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(SIZE,SIZE,SIZE)), new THREE.LineBasicMaterial({color:0xdde7ff,transparent:true,opacity:.9})); scene.add(box);
  // strata (thin wire planes)
  const seed=777; function mulberry32(a){return function(){var t=a+=0x6D2B79F5;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return((t^t>>>14)>>>0)/4294967296}}; const rand=mulberry32(seed);
  function noise(x,y){ const r=Math.sin(x*2.1+3.1*Math.cos(y*1.7))+Math.cos(y*1.3+2.3*Math.sin(x*1.9)); return r*0.25; }
  function yFor(i){ const t=i/(COUNT-1); return THREE.MathUtils.lerp(HALF-0.01, -HALF+0.01, t); }
  function makeStratum(i){ const g=new THREE.PlaneGeometry(SIZE*0.96,SIZE*0.96, 42,42); const p=g.attributes.position; const t=i/(COUNT-1), amp=THREE.MathUtils.lerp(0.09,0.03,t); for(let j=0;j<p.count;j++){ const x=p.getX(j)/SIZE+10.2, y=p.getY(j)/SIZE+10.2; const z=noise(x+t*2.0,y-t*2.0)*amp; p.setZ(j,z); } p.needsUpdate=true; const edges=new THREE.EdgesGeometry(g); const mat=new THREE.LineBasicMaterial({color:0xdde7ff, transparent:true, opacity:THREE.MathUtils.lerp(0.55,0.08,t)}); const m=new THREE.LineSegments(edges,mat); m.rotation.x=-Math.PI/2; m.position.y=yFor(i); m.userData.i=i; return m; }
  for(let i=0;i<COUNT;i++) group.add(makeStratum(i));
  const scan = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(SIZE*0.985, SIZE*0.02, SIZE*0.985)), new THREE.LineBasicMaterial({ color:0x58d5ff })); scene.add(scan);

  let idx=0, autoplay=0, wob=0.0, rangeScale=1.0; const fall=6;
  function setLayer(i){ const prev=idx; idx=Math.max(0,Math.min(COUNT-1,i|0)); const y=yFor(idx); scan.position.y=y; const pct=idx/(COUNT-1); readout.textContent=`${String(idx+1).padStart(2,'0')} / ${COUNT}`; group.children.forEach(c=>{ const d=Math.abs((c.userData.i||0)-idx); const near=Math.max(0,1-d/fall); c.material.opacity=THREE.MathUtils.lerp(0.08,0.7,near); c.material.color.setHex(d===0?0xffffff:0xdde7ff); }); if(prev!==idx && 'vibrate' in navigator) navigator.vibrate(4); }
  function setAuto(amount){ autoplay = Math.min(2.0, Math.max(0.0, amount*4)); }
  function wobble(amount){ wob = amount; }
  function setRange(scale){ rangeScale = Math.min(2.0, Math.max(0.6, scale)); }

  // animate
  const clock=new THREE.Clock(); function tick(){ requestAnimationFrame(tick); const t=clock.getElapsedTime(); group.rotation.z = Math.sin(t*0.12)*0.02; const a = autoplay>0 ? Math.sin(t*autoplay)*0.5+0.5 : 0; const w = wob>0 ? Math.sin(t*1.8)*wob : 0; if(autoplay>0 || wob>0){ const span = Math.floor((COUNT-1)*(0.25*rangeScale)); const center = idx; const target = Math.max(0, Math.min(COUNT-1, Math.round(center - span + (span*2)*(a*0.5 + 0.5 + w)))); setLayer(target); } renderer.render(scene,camera);} resize(); setLayer(0); tick();

  // expose bridge for the 2D tetra controller
  window.LayerCube = { setLayer, setAuto, wobble, setRange };
</script>
</body>
</html>
