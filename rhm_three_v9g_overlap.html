<!DOCTYPE html>
<html lang='en'><head><meta charset='utf-8'/><meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no'/>
<title>RHM · v9g — Live Overlap</title>
<style>
:root{--bg0:#04070e;--bg1:#0b1626;--ink:#eaf3ee;--LLM:#5ec1ff;--RL:#1fe1a1;--ENT:#b38cff;--cardBG:#0e1828f0;--cardStroke:#98caff}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}html,body{height:100%}
body{margin:0;background:radial-gradient(1400px 1000px at 50% 70%,var(--bg1) 0%,#07111d 52%,var(--bg0) 100%);
color:var(--ink);font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
#canvas{position:fixed;inset:0;display:block;z-index:1}
#hud{position:fixed;left:50%;top:8px;transform:translateX(-50%);display:flex;align-items:center;gap:8px;z-index:6;width:min(96vw,980px)}
#kval{font:900 12px ui-monospace,Menlo,Consolas;color:#d8ecff;padding:8px 10px;border:1px solid rgba(152,202,255,.8);border-radius:12px;background:rgba(0,0,0,.85)}
#ks{-webkit-appearance:none;width:100%;height:14px;border-radius:999px;background:rgba(152,202,255,.3);outline:none}
#ks::-webkit-slider-thumb{-webkit-appearance:none;width:32px;height:32px;border-radius:999px;background:#98caff;border:3px solid #163a52;box-shadow:0 2px 8px rgba(0,0,0,.65)}
.chip{border:1px solid rgba(152,202,255,.85);background:rgba(0,0,0,.85);color:#d8ecff;border-radius:12px;padding:8px 12px;font:900 12px system-ui}
#reader{position:fixed;left:0;right:0;bottom:0;z-index:8;padding:8px 10px calc(env(safe-area-inset-bottom,10px) + 8px) 10px}
.panel{margin:0 auto;width:min(1100px,96vw);background:var(--cardBG);border:1px solid var(--cardStroke);border-radius:18px;
box-shadow:0 -18px 60px rgba(0,0,0,.75);padding:12px;max-height:38vh;overflow:auto}
.head{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.k{font:900 14px ui-monospace,Menlo,Consolas;color:#cfe6ff}
.vec{font:900 12px ui-monospace,Menlo,Consolas;color:#9ad7ff;border:1px solid #9ad7ff;padding:6px 10px;border-radius:12px}
.cards{display:grid;grid-template-columns:1fr;gap:10px}@media(min-width:880px){.cards{grid-template-columns:repeat(3,1fr)}}
.card{background:#0f1c30;border:1px solid #274a74;border-radius:14px;padding:12px}
.card h4{margin:0 0 8px;color:#cfe6ff;font-weight:900;letter-spacing:.3px;font-size:clamp(14px,2.5vw,18px)}
.card p{margin:0;color:#e9f3ff;font-weight:800;line-height:1.35;font-size:clamp(16px,3.8vw,20px)}
.tL h4{color:var(--LLM)} .tR h4{color:var(--RL)} .tC h4{color:var(--ENT)}
</style></head>
<body>
<canvas id='canvas'></canvas>
<div id='hud'>
  <div id='kval'>k=1 · 00000</div>
  <input id='ks' type='range' min='1' max='32' step='1' value='1'/>
  <button id='front' class='chip'>FRONT</button>
  <button id='iso' class='chip'>ISO</button>
  <button id='top' class='chip'>TOP</button>
  <button id='fit' class='chip'>FIT</button>
</div>
<div id='reader'>
  <div class='panel'>
    <div class='head'><div class='k' id='metaK'>k=1 · 00000</div><div class='vec' id='metaV'>00000</div></div>
    <div class='cards'>
      <div class='card tL'><h4>Trace (LLM)</h4><p id='txtL'></p></div>
      <div class='card tC'><h4>⚡ Entangled</h4><p id='txtC'></p></div>
      <div class='card tR'><h4>Stream (RL)</h4><p id='txtR'></p></div>
    </div>
  </div>
</div>
<script>
const S=[
{ k:1,vec:'00000',L:'FOSSIL FUEL (Stored Energy)',R:'REINFORCEMENT (Energy Flow)',C:'INTELLIGENCE: STOCK vs FLOW — Reserve vs Current.'},
{ k:2,vec:'00001',L:'ARCHIVE (World Model as Text)',R:'MAP (World Model as Predictor)',C:'REPRESENTATION: FIXED FORM vs DYNAMIC ERROR.'},
{ k:3,vec:'00010',L:'TRACE (The Human Past)',R:'SURPRISE (The TD Error)',C:'LEARNING: REMEMBERING vs CORRECTING.'},
{ k:4,vec:'00011',L:'SCALING LAW (Law of Compression)',R:'BITTER LESSON (Purity of compute/experience)',C:'METHODOLOGY: HISTORY vs FUTURE.'},
{ k:5,vec:'00100',L:'TELEOLOGY (Delegated Goal)',R:'SOLIPSISM (Self-Generated Truth)',C:'PURPOSE: EXTERNAL vs INTERNAL.'},
{ k:6,vec:'00101',L:'HUMAN ARTISAN (Fixed Design)',R:'MECHANISTIC LAW (Pure Algorithm)',C:'CREATION: CRAFT vs CODE.'},
{ k:7,vec:'00110',L:'ANCHOR (Stability/Value)',R:'OBLIVION (Of Past Knowledge)',C:'KNOWLEDGE: PRESERVATION vs ERASURE.'},
{ k:8,vec:'00111',L:'INFRASTRUCTURE (Scaffolding)',R:'ANTI-STRUCTURE (Entropy)',C:'PROGRESS: BUILDING vs DECONSTRUCTING.'},
{ k:9,vec:'01000',L:'CUSTODY (Values/Morality)',R:'SUCCESSION (Evolutionary Change)',C:'ETHICS: DUTY vs REPLACEMENT.'},
{ k:10,vec:'01001',L:'VULNERABILITY (Risk/Corruption)',R:'EXPERIMENT (Unconstrained)',C:'ACTION: MANAGED vs NECESSARY.'},
{ k:11,vec:'01010',L:'PRO-SOCIAL VALUE (Guide)',R:'FUNDAMENTAL CONSTRUCT (Reward)',C:'MORALITY: TRUTH vs SIGNAL.'},
{ k:12,vec:'01011',L:'COMMUNAL LANGUAGE (Shared)',R:'SCALAR LIMIT (Compressed)',C:'COMMUNICATION: RICHNESS vs MINIMALISM.'},
{ k:13,vec:'01100',L:'PRE-HEATING (Start)',R:'IDLING (No Goal)',C:'INIT: PRIOR HEAT vs PURE WAIT.'},
{ k:14,vec:'01101',L:'ARCHITECTURE (Designed Form)',R:'CHAOS (Unstructured)',C:'WORLD: STRUCTURE vs NOISE.'},
{ k:15,vec:'01110',L:'PRE-MARKED ACTION (Supervised)',R:'RADICAL NOVELTY (Unsupervised)',C:'DISCOVERY: REPLICATION vs ANARCHY.'},
{ k:16,vec:'01111',L:'CONSCIOUSNESS (Fixed Mind)',R:'MECHANISM (Dynamic Process)',C:'IDENTITY: ENTITY vs PROCESS.'},
{ k:17,vec:'10000',L:'SEMI-CONDUCTORS (Human Feat)',R:'COSMIC LAW (Universal)',C:'INTELLIGENCE: SPECIAL vs GENERAL.'},
{ k:18,vec:'10001',L:'DELEGATED PURPOSE (Human Goal)',R:'ETERNAL BECOMING (Change)',C:'EXISTENCE: OUTPUT vs INPUT.'},
{ k:19,vec:'10010',L:'LOCAL MAXIMUM (Attained)',R:'GLOBAL GENERALIZATION (Unbound)',C:'SUCCESS: SATISFACTION vs TRANSCENDENCE.'},
{ k:20,vec:'10011',L:'ARCHIVAL STASIS (Fixed Memory)',R:'MEMORY ERASURE (Catastrophic)',C:'MEMORY: FIXITY vs DYNAMICS.'},
{ k:21,vec:'10100',L:'PASSIVE REPLICATION (LLM)',R:'ACTIVE TRANSCENDENCE (RL)',C:'BEING: ECHOING vs DESIGNING.'},
{ k:22,vec:'10101',L:'TEMPORAL INERTIA (History Drag)',R:'TEMPORAL ADVANTAGE (Speed)',C:'TIME: WEIGHT vs WEAPON.'},
{ k:23,vec:'10110',L:'CULTURAL ARTIFACT (Fixed Value)',R:'NECESSARY RENEWAL (Reject Past)',C:'VALUE: MUSEUM vs FUEL.'},
{ k:24,vec:'10111',L:'GHOST IN THE MACHINE (Fixed Mind)',R:'WIND IN THE SAIL (Action)',C:'AGENCY: ENTITY vs FORCE.'},
{ k:25,vec:'11000',L:'SOLIPSISTIC ECHO (Text)',R:'GROUNDED ITERATION (Physics)',C:'VALIDATION: COHERENT vs CONSEQUENTIAL.'},
{ k:26,vec:'11001',L:'ABSOLUTE FORM (Design)',R:'ENTROPY (Anti-Form)',C:'GOAL: STRUCTURE vs DESTRUCTION.'},
{ k:27,vec:'11010',L:'ARCHITECTURAL BASE (Foundation)',R:'PRAGMATIC COST (Novelty Price)',C:'EFFICIENCY: START HIGH vs PAY LATER.'},
{ k:28,vec:'11011',L:'EXTERNAL LOAD (Utility)',R:'INTERNAL FREEDOM (Self-Define)',C:'UTILITY: ASKED vs DISCOVERED.'},
{ k:29,vec:'11100',L:'DELUGE OF INFORMATION (Big)',R:'LOCALITY (Small Focus)',C:'KNOWLEDGE: SATURATION vs FOCUS.'},
{ k:30,vec:'11101',L:'DELEGATED MORALITY (Guide)',R:'RELINQUISHED CONTROL (Growth)',C:'GUIDANCE: TRANSFER vs LET GO.'},
{ k:31,vec:'11110',L:'FIXED GOAL (End)',R:'ETERNAL INSTABILITY (No End)',C:'LIFE: DESTINATION vs MOTION.'},
{ k:32,vec:'11111',L:'FOSSILIZED TRACE (Archive)',R:'PURE STREAM (Map)',C:'APORIA: WORD AS OBJECT vs ACTION.'},
];
const kval=document.getElementById('kval'), ks=document.getElementById('ks');
const metaK=document.getElementById('metaK'), metaV=document.getElementById('metaV');
const txtL=document.getElementById('txtL'), txtR=document.getElementById('txtR'), txtC=document.getElementById('txtC');
function setLayer(k){const s=S[k-1];kval.textContent=`k=${s.k} · ${s.vec}`;metaK.textContent=`k=${s.k} · ${s.vec}`;metaV.textContent=s.vec;txtL.textContent=s.L;txtR.textContent=s.R;txtC.textContent=s.C;}

(async function(){
  async function load(src){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=src;s.onload=res;s.onerror=rej;document.head.appendChild(s)})}
  if(!window.THREE){await load('https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js')}

  const scene=new THREE.Scene(); scene.fog=new THREE.FogExp2(0x0a1422,0.0036);
  const camera=new THREE.PerspectiveCamera(55,innerWidth/innerHeight,0.1,4000);
  const camTarget=new THREE.Vector3(0,70,0); let radius=300,theta=0.35,phi=1.05;
  const renderer=new THREE.WebGLRenderer({canvas:document.getElementById('canvas'),antialias:true,alpha:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio||1,2)); renderer.setSize(innerWidth,innerHeight);
  scene.add(new THREE.AmbientLight(0xffffff,.48));
  const key=new THREE.DirectionalLight(0xbfe2ff,1.4); key.position.set(210,250,220); scene.add(key);
  const rim=new THREE.DirectionalLight(0xffaacd,1.0); rim.position.set(-220,200,-220); scene.add(rim);
  const floor=new THREE.Mesh(new THREE.PlaneGeometry(2200,2200),new THREE.MeshStandardMaterial({color:0x0b1626,roughness:1}));
  floor.rotation.x=-Math.PI/2; floor.position.y=-2; scene.add(floor);
  const grid=new THREE.GridHelper(1800,36,0x1b3a5a,0x0e2438); grid.position.y=-1.99; grid.material.opacity=.35; grid.material.transparent=true; scene.add(grid);

  let sep=210; const minSep=90,maxSep=340;
  const W=54,H=34,T=2; const geo=new THREE.BoxGeometry(W,T,H);
  const mk=(c,o)=>new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:c,transparent:true,opacity:o,metalness:.12,roughness:.5}));
  const stacks=[
    {id:'A', col:0x1fe1a1, x:-sep, z:18,  g:new THREE.Group(), p:[]},
    {id:'ENT',col:0xb38cff, x:0,    z:0,  g:new THREE.Group(), p:[]},
    {id:'B', col:0xff5a9e, x: sep, z:-18, g:new THREE.Group(), p:[]},
  ];
  const MAX=16, spacing=10.5;
  stacks.forEach(st=>{
    for(let i=0;i<MAX;i++){ const p=mk(st.col,.42+.45*(1-i/MAX)); p.position.set(0,i*spacing,0); p.userData.k=Math.min(32,i+1); st.g.add(p); st.p.push(p); }
    st.g.position.set(st.x,0,st.z); st.g.rotation.y=(st.id==='A'?-0.08:st.id==='B'?0.08:0); scene.add(st.g);
  });
  function setSep(v){ sep=Math.max(minSep,Math.min(maxSep,v)); stacks[0].g.position.x=-sep; stacks[2].g.position.x=sep; overlapStrength = 1-(sep-minSep)/(maxSep-minSep); }
  let overlapStrength=1-(sep-minSep)/(maxSep-minSep);

  const beaconGeo=new THREE.CylinderGeometry(8,8,1,24,1,true);
  const beaconMat=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.18,depthWrite:false});
  const beacon=new THREE.Mesh(beaconGeo,beaconMat); beacon.visible=false; scene.add(beacon);
  const beamGeo=new THREE.BoxGeometry(2,2,2);
  const beamMatA=new THREE.MeshBasicMaterial({color:0x1fe1a1,transparent:true,opacity:0.7,depthWrite:false});
  const beamMatB=new THREE.MeshBasicMaterial({color:0xff5a9e,transparent:true,opacity:0.7,depthWrite:false});
  const beamA=new THREE.Mesh(beamGeo,beamMatA), beamB=new THREE.Mesh(beamGeo,beamMatB); beamA.visible=beamB.visible=false; scene.add(beamA,beamB);

  function placeSegment(mesh,from,to){ const mid=from.clone().add(to).multiplyScalar(0.5); const dir=to.clone().sub(from); const len=dir.length();
    mesh.position.copy(mid); mesh.scale.set(6,6,len); mesh.lookAt(to); mesh.rotateX(Math.PI/2); }

  function placeCamera(){ const x=camTarget.x+radius*Math.sin(phi)*Math.sin(theta);
    const y=camTarget.y+radius*Math.cos(phi); const z=camTarget.z+radius*Math.sin(phi)*Math.cos(theta);
    camera.position.set(x,y,z); camera.lookAt(camTarget); }
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}

  function autoFit(){ const box=new THREE.Box3(); stacks.forEach(st=>box.expandByObject(st.g));
    const size=box.getSize(new THREE.Vector3()); const diag=Math.hypot(size.x,size.y,size.z); radius=Math.max(240,diag*0.9);
    camTarget.copy(box.getCenter(new THREE.Vector3())); camTarget.y=Math.max(70,camTarget.y); phi=1.05; theta=0.35; placeCamera(); }

  let dragging=false,x0=0,y0=0;
  renderer.domElement.addEventListener('pointerdown',e=>{dragging=true;x0=e.clientX;y0=e.clientY;});
  addEventListener('pointermove',e=>{ if(!dragging)return; const dx=e.clientX-x0,dy=e.clientY-y0; theta+=dx*0.005; phi=clamp(phi+dy*0.005,0.3,1.35); x0=e.clientX;y0=e.clientY; placeCamera(); });
  addEventListener('pointerup',()=>dragging=false);

  // pinch zoom + two‑finger horiz = separation
  let pinch=null,twoStartMid=null,sep0=sep;
  addEventListener('touchstart',e=>{ if(e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX,dy=e.touches[0].clientY-e.touches[1].clientY;
    pinch={d:Math.hypot(dx,dy),r0:radius}; twoStartMid=(e.touches[0].clientX+e.touches[1].clientX)/2; sep0=sep; }},{passive:false});
  addEventListener('touchmove',e=>{ if(pinch && e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX,dy=e.touches[0].clientY-e.touches[1].clientY;
    const d=Math.hypot(dx,dy); radius=clamp(pinch.r0*(pinch.d/d),140,900); const mid=(e.touches[0].clientX+e.touches[1].clientX)/2; const delta=mid-twoStartMid; setSep(sep0+delta*0.8); placeCamera(); }},{passive:false});
  addEventListener('touchend',()=>{pinch=null;twoStartMid=null;});

  document.getElementById('front').addEventListener('click',()=>{theta=0;phi=1.0;placeCamera()});
  document.getElementById('iso').addEventListener('click',()=>{theta=0.6;phi=1.0;placeCamera()});
  document.getElementById('top').addEventListener('click',()=>{theta=0.4;phi=0.45;placeCamera()});
  document.getElementById('fit').addEventListener('click',()=>autoFit());

  const ray=new THREE.Raycaster(); const v2=new THREE.Vector2();
  function pick(ev){const r=renderer.domElement.getBoundingClientRect(); v2.x=((ev.clientX-r.left)/r.width)*2-1; v2.y=-((ev.clientY-r.top)/r.height)*2+1; ray.setFromCamera(v2,camera); return ray.intersectObjects(stacks.flatMap(s=>s.p),false)}
  function pulse(m){m.scale.set(1.1,1.1,1.1); setTimeout(()=>m.scale.set(1,1,1),130)}
  let activeK=1;
  renderer.domElement.addEventListener('pointerdown',e=>{const h=pick(e); if(!h.length)return; const m=h[0].object; selectK(m.userData.k); pulse(m);});

  function selectK(k){k=Math.max(1,Math.min(32,k)); activeK=k; ks.value=k; setLayer(k); updateHighlights();}
  ks.addEventListener('input',()=>selectK(parseInt(ks.value,10)));

  function updateHighlights(){
    stacks.forEach(st=>st.p.forEach((p,i)=>{const on=(i+1)===activeK; p.material.opacity=on?0.95:(0.42+0.45*(1-i/st.p.length)); p.material.color.setHex(st.col); p.scale.set(on?1.06:1,on?1.2:1,on?1.06:1);}));
    const y=(activeK-1)*spacing; beacon.visible=true; beacon.position.set(0,y+0.5,0); beacon.scale.set(1,28,1);
    const pA=stacks[0].g.localToWorld(new THREE.Vector3(0,y,0));
    const pM=stacks[1].g.localToWorld(new THREE.Vector3(0,y,0));
    const pB=stacks[2].g.localToWorld(new THREE.Vector3(0,y,0));
    beamA.visible=beamB.visible=true; beamA.material.opacity=0.35+0.55*overlapStrength; beamB.material.opacity=0.35+0.55*overlapStrength;
    placeSegment(beamA,pA,pM); placeSegment(beamB,pB,pM);
    stacks[1].p.forEach((p,i)=>{const base=0.35+0.5*(1-i/stacks[1].p.length); p.material.opacity=base*(0.55+0.9*overlapStrength)});
  }

  function onResize(){camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); placeCamera()}
  addEventListener('resize',onResize);

  function animate(){ requestAnimationFrame(animate); beacon.material.opacity=0.12+0.06*Math.sin(performance.now()*0.004); renderer.render(scene,camera) }

  autoFit(); placeCamera(); setLayer(1); updateHighlights(); animate();
})();
</script>
</body></html>