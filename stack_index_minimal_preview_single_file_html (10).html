<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>VOL‑MEDIA DECKS v15 — Grid of Stacks + Poly Sequencer + Tone/Harmony Packs (Audio-safe)</title>
<style>
  *{margin:0;padding:0;box-sizing:border-box;touch-action:none;-webkit-tap-highlight-color:transparent}
  html,body{height:100%}
  body{background:#000;color:#fff;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
  #canvas{width:100vw;height:100vh;display:block}
  #hud{position:fixed;inset:0;pointer-events:none;z-index:10}
  #viewHUD{position:absolute;top:12px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.6);padding:6px 12px;border-radius:10px;font-weight:800;font-size:13px;border:1px solid rgba(255,255,255,.18)}
  #controls{position:absolute;left:50%;bottom:14px;transform:translateX(-50%);display:flex;gap:8px;pointer-events:auto;flex-wrap:wrap;justify-content:center}
  button.ctrl{appearance:none;border:1px solid rgba(255,255,255,.25);background:rgba(0,0,0,.6);color:#fff;padding:8px 12px;border-radius:10px;font-weight:700;font-size:12px;cursor:pointer}
  button.ctrl:active{transform:translateY(1px)}
  #toast{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,.86);border:1px solid rgba(255,255,255,.2);padding:6px 10px;border-radius:10px;font-size:12px;display:none;z-index:12}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="hud">
  <div id="viewHUD">FRONT</div>
  <div id="controls">
    <button id="btnStart" class="ctrl">▶ Start</button>
    <button id="btnOrbit" class="ctrl">Orbit OFF</button>
    <button id="btnPackPrev" class="ctrl">◀ Pack</button>
    <button id="btnPackNext" class="ctrl">Pack ▶</button>
    <button id="btnHarmony" class="ctrl">Harmony</button>
    <button id="btnShuffle" class="ctrl">Shuffle</button>
    <button id="btnClear" class="ctrl">Clear</button>
  </div>
</div>
<div id="toast"></div>
<script>
(async function(){
  // ===== Load THREE (fallback)
  if(!window.THREE){
    const CDNs=['https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js','https://unpkg.com/three@0.152.2/build/three.min.js'];
    for(const src of CDNs){try{await new Promise((res,rej)=>{const s=document.createElement('script');s.src=src;s.onload=res;s.onerror=rej;document.head.appendChild(s)}); if(window.THREE) break;}catch(e){}}
  }

  // ===== Scene
  const canvas=document.getElementById('canvas');
  const renderer=new THREE.WebGLRenderer({canvas,antialias:true});
  renderer.setSize(innerWidth,innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
  const scene=new THREE.Scene(); scene.background=new THREE.Color(0x000000);
  const camera=new THREE.PerspectiveCamera(58, innerWidth/innerHeight, .1, 4000); camera.position.set(120,80,150);
  const center=new THREE.Vector3(0,12,0);
  const fitLook=()=>camera.lookAt(center); fitLook();
  addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight)});

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff,.28));
  const key=new THREE.PointLight(0x66ddff,1.2,900); key.position.set(0,150,200); scene.add(key);
  const warm=new THREE.PointLight(0xffaa66,.8,800); warm.position.set(140,80,-120); scene.add(warm);
  const rim=new THREE.DirectionalLight(0xffffff,.5); rim.position.set(-120,160,-40); scene.add(rim);

  // HUD + helpers
  const viewHUD=document.getElementById('viewHUD');
  const toastEl=document.getElementById('toast');
  function toast(t){toastEl.textContent=t; toastEl.style.display='block'; clearTimeout(toast._id); toast._id=setTimeout(()=>toastEl.style.display='none',1200);} 

  // ===== Views (declare early)
  const VIEWS=[
    {name:'FRONT',pos:[0,50,170]},
    {name:'ISO L',pos:[-140,90,120]},
    {name:'ISO R',pos:[140,90,120]},
    {name:'TOP',pos:[0,240,0.01]},
    {name:'WIDE',pos:[230,90,0]}
  ];
  let viewIdx=0; const applyView=()=>{ const v=VIEWS[viewIdx%VIEWS.length]; camera.position.set(...v.pos); fitLook(); viewHUD.textContent=v.name; };
  applyView();

  // ===== Sprite helper
  function mkSprite(text){ const cvs=document.createElement('canvas'); const s=256; cvs.width=cvs.height=s; const ctx=cvs.getContext('2d'); ctx.clearRect(0,0,s,s); ctx.fillStyle='rgba(0,0,0,0)'; ctx.fillRect(0,0,s,s); ctx.fillStyle='white'; ctx.font='bold 48px Inter, system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.shadowColor='rgba(0,0,0,0.6)'; ctx.shadowBlur=12; ctx.fillText(text,s/2,s/2); const tex=new THREE.CanvasTexture(cvs); const mat=new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false}); const spr=new THREE.Sprite(mat); spr.scale.set(6,6,1); return spr; }

  // ===== Mini-stack builder (cell visual)
  function makeMiniStack(color, layers=8, spacing=0.6, size=2.4){
    const g=new THREE.Group();
    for(let i=0;i<layers;i++){
      const geo=new THREE.PlaneGeometry(size,size);
      const mat=new THREE.MeshStandardMaterial({color,transparent:true,opacity:0.2,roughness:.6,metalness:.1,side:THREE.DoubleSide,depthWrite:false});
      const m=new THREE.Mesh(geo,mat); m.rotation.x=-Math.PI/2; m.position.y=i*spacing; m.material.emissive=new THREE.Color(color); m.material.emissiveIntensity=.12; g.add(m);
    }
    g.userData.layers=layers; g.userData.size=size; g.userData.spacing=spacing;
    g.userData.pulse=(level)=>{ const L=g.children.length; for(let i=0;i<L;i++){ const p=g.children[i]; const on=i<Math.min(L,Math.ceil(level*L)); p.material.opacity=on?0.75:0.15; p.material.emissiveIntensity=on?0.9:0.1; p.scale.set(on?1.05:1,1,on?1.05:1); }
      if(level>0){ const s=1+level*0.15; g.scale.set(s,1,s); setTimeout(()=>g.scale.set(1,1,1),90); }
    };
    return g;
  }

  // ===== Grid of Stacks (sequencer lanes × steps)
  const GRID={ rows:8, cols:16, gapX:7.5, gapZ:8.5, group:new THREE.Group(), cells:[], cursor:null };
  scene.add(GRID.group);
  const instruments=['Kick','Snr','Hat','Bass','Chord','Lead','Perc','FX'];
  const colors=[0xff8844,0xff6688,0xffff66,0x66ffcc,0x99bbff,0xc47dff,0x88ffaa,0xffffff];

  function buildGrid(){
    GRID.cells.length=0; while(GRID.group.children.length) GRID.group.remove(GRID.group.children[0]);
    const startX=-(GRID.cols-1)*GRID.gapX/2, startZ=-(GRID.rows-1)*GRID.gapZ/2;
    for(let r=0;r<GRID.rows;r++){
      const row=[]; for(let c=0;c<GRID.cols;c++){
        const stack=makeMiniStack(colors[r],8,0.55,2.6);
        stack.position.set(startX + c*GRID.gapX, 0, startZ + r*GRID.gapZ);
        stack.userData.rc=[r,c]; stack.userData.active=0; // 0=off,1..3 velocity
        GRID.group.add(stack); row.push(stack);
      }
      GRID.cells.push(row);
    }
    // step cursor
    GRID.cursor=new THREE.Mesh(new THREE.BoxGeometry(3.2,0.4, GRID.rows*GRID.gapZ + 4), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.1}));
    GRID.cursor.position.set(startX, 0.2, 0);
    GRID.group.add(GRID.cursor);
    // row labels
    for(let r=0;r<instruments.length;r++){
      const label=mkSprite(instruments[r]); label.scale.set(5,5,1); label.position.set(startX-6, 6, startZ + r*GRID.gapZ); GRID.group.add(label);
    }
  }
  buildGrid();

  // ===== Pattern + Harmony
  const pattern=Array.from({length:GRID.rows},()=>Array(GRID.cols).fill(0)); // velocity 0..3
  const scales={
    major:[0,2,4,5,7,9,11],
    minor:[0,2,3,5,7,8,10],
    dorian:[0,2,3,5,7,9,10],
    mixolydian:[0,2,4,5,7,9,10],
    pentMinor:[0,3,5,7,10]
  };
  let root=50; // MIDI-ish base (D3≈50)
  let scaleName='dorian';
  let progression=[0,3,4,5]; // degrees offsets cycling each bar
  const degreeToFreq=(deg,oct=0)=>{ const arr=scales[scaleName]; const idx=((deg%arr.length)+arr.length)%arr.length; const semi=arr[idx]+12*oct; return 440*Math.pow(2,((root-69)+semi)/12); };

  // ===== Audio Engine (poly) — LAZY INIT & SAFE GUARDS
  let AC=null, master=null, reverb=null, wet=null, dry=null;
  async function audioInit(){
    if(AC) return true;
    try{
      const C=window.AudioContext||window.webkitAudioContext; if(!C){ toast('AudioContext unsupported'); return false; }
      AC=new C();
      master=AC.createGain(); master.gain.value=.18; master.connect(AC.destination);
      reverb=AC.createConvolver(); reverb.buffer=(function makeIR(sec=2.2,decay=3){const rate=AC.sampleRate,len=rate*sec,buf=AC.createBuffer(2,len,rate);for(let ch=0;ch<2;ch++){const d=buf.getChannelData(ch);for(let i=0;i<len;i++){d[i]=(Math.random()*2-1)*Math.pow(1-i/len,decay);}}return buf;})();
      wet=AC.createGain(); dry=AC.createGain(); wet.gain.value=.22; dry.gain.value=.78; wet.connect(reverb).connect(master); dry.connect(master);
      return true;
    }catch(err){ console.error(err); toast('Audio init failed'); return false; }
  }

  function mkEnv(){ const e=AC.createGain(); e.gain.value=0; return e; }
  function mkFilter(type='lowpass'){ const f=AC.createBiquadFilter(); f.type=type; f.frequency.value=1200; f.Q.value=0.8; return f; }
  function noiseBuf(){ const b=AC.createBuffer(1, AC.sampleRate*1, AC.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; return b; }

  // Instrument builders (built AFTER audio init)
  function buildKick(){ const o=AC.createOscillator(); o.type='sine'; const g=mkEnv(); const f=mkFilter('lowpass'); o.connect(f).connect(g).connect(dry); o.start(); return {start(v){ const t=AC.currentTime; o.frequency.cancelScheduledValues(t); o.frequency.setValueAtTime(120,t); o.frequency.exponentialRampToValueAtTime(40,t+0.08); g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.9*Math.min(1,v/2), t+0.005); g.gain.exponentialRampToValueAtTime(0.0001, t+0.28); }} }
  function buildSnare(){ const n=AC.createBufferSource(); n.buffer=noiseBuf(); n.loop=true; const g=mkEnv(); const hp=mkFilter('highpass'); hp.frequency.value=1800; n.connect(hp).connect(g).connect(dry); n.start(); return {start(v){ const t=AC.currentTime; g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.7*(v/3+0.5), t+0.005); g.gain.exponentialRampToValueAtTime(0.0001, t+0.18); }} }
  function buildHat(){ const n=AC.createBufferSource(); n.buffer=noiseBuf(); n.loop=true; const g=mkEnv(); const hp=mkFilter('highpass'); hp.frequency.value=6000; n.connect(hp).connect(g).connect(dry); n.start(); return {start(v){ const t=AC.currentTime; g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.4*(0.5+v/3), t+0.002); g.gain.exponentialRampToValueAtTime(0.0001, t+0.06); }} }
  function buildMono(osc='sawtooth',dest=dry){ const o=AC.createOscillator(); o.type=osc; const f=mkFilter('lowpass'); const g=mkEnv(); o.connect(f).connect(g).connect(dest); o.start(); return {o,f,g,start(freq,vel=.6,decay=.2){ const t=AC.currentTime; o.frequency.setTargetAtTime(freq,t,0.02); f.frequency.setTargetAtTime(1000+vel*2500,t,0.03); g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(g.gain.value,t); g.gain.linearRampToValueAtTime(vel, t+0.01); g.gain.exponentialRampToValueAtTime(0.0001, t+decay); }} }
  function buildChord(){ const gain=mkEnv(); gain.connect(wet); const make=(det=0)=>{ const o=AC.createOscillator(); o.type='triangle'; o.detune.value=det; const f=mkFilter('lowpass'); o.connect(f).connect(gain); o.start(); return {o,f}; };
    const a=make(-7), b=make(0), c=make(7); return {start(rootHz,vel=.4){ const t=AC.currentTime; const thirds=[0,3,4]; const r=rootHz; const fA=r*Math.pow(2,thirds[(progressionIdx%thirds.length)]/12); const fB=r*Math.pow(2,7/12); a.o.frequency.setTargetAtTime(fA,t,0.02); b.o.frequency.setTargetAtTime(r,t,0.02); c.o.frequency.setTargetAtTime(fB,t,0.02); [a.f,b.f,c.f].forEach(f=>f.frequency.setTargetAtTime(900+vel*1600,t,0.04)); gain.gain.cancelScheduledValues(t); gain.gain.setValueAtTime(gain.gain.value,t); gain.gain.linearRampToValueAtTime(vel, t+0.03); gain.gain.exponentialRampToValueAtTime(0.0001, t+0.5); }} }

  const rack=[buildKick, buildSnare, buildHat, ()=>buildMono('sawtooth',dry), buildChord, ()=>buildMono('square',dry), ()=>buildMono('triangle',dry), ()=>buildMono('sine',wet)];
  let activeVoices=[]; // LAZY — built on Start
  function buildVoices(){ if(!AC) return; if(activeVoices.length) return; activeVoices=rack.map(f=>f()); }

  // ===== Tone/Harmony packs
  const PACKS=[
    {name:'TAPE', waves:{bass:'sawtooth',lead:'triangle',perc:'square'}, filt:0.8, rev:0.22},
    {name:'FMISH', waves:{bass:'square',lead:'square',perc:'square'}, filt:0.4, rev:0.18},
    {name:'GRAN', waves:{bass:'triangle',lead:'sine',perc:'triangle'}, filt:1.2, rev:0.28},
    {name:'BITDRUM', waves:{bass:'square',lead:'sawtooth',perc:'square'}, filt:0.6, rev:0.12},
    {name:'WAVESET', waves:{bass:'sawtooth',lead:'sawtooth',perc:'triangle'}, filt:1.0, rev:0.25}
  ];
  let packIdx=0; function applyPack(i){ packIdx=((i%PACKS.length)+PACKS.length)%PACKS.length; const P=PACKS[packIdx];
    // adjust synths if present
    if(activeVoices[3]?.o) activeVoices[3].o.type=P.waves.bass;
    if(activeVoices[5]?.o) activeVoices[5].o.type=P.waves.lead;
    if(activeVoices[6]?.o) activeVoices[6].o.type=P.waves.perc;
    if(activeVoices[7]?.o) activeVoices[7].o.type='sine';
    if(AC && wet){ try{ wet.gain.setTargetAtTime(P.rev, AC.currentTime, 0.1); }catch{} }
    toast('Pack: '+P.name);
  }

  // ===== Sequencer
  let bpm=112, swing=0.12; let playing=false; let step=0; let progressionIdx=0;
  function startClock(){ let last=performance.now(); (function loop(){ const beat=60000/bpm; const stepDur=beat/4; const now=performance.now(); if(playing && AC && AC.state==='running'){ if(now-last>=stepDur*((step%2)?(1+swing):(1-swing))){ last=now; tick(); } } requestAnimationFrame(loop); })(); }

  function trig(r,vel){ if(!activeVoices.length) return; const v=Math.max(0,Math.min(3,vel)); const visLevel=v/3; const cell=GRID.cells[r][step]; cell.userData.pulse(visLevel);
    switch(r){
      case 0: activeVoices[0].start(v); break;
      case 1: activeVoices[1].start(v); break;
      case 2: activeVoices[2].start(v); break;
      case 3: { const deg=(step%4)*2 + (progression[progressionIdx%progression.length]); const f=degreeToFreq(deg, -1); activeVoices[3].start(f, 0.35+0.15*v, 0.18+0.04*v); } break;
      case 4: { const deg=progression[progressionIdx%progression.length]; const f=degreeToFreq(deg, 0); activeVoices[4].start(f, 0.35+0.12*v); } break;
      case 5: { const deg=(step%7); const f=degreeToFreq(deg, 1); activeVoices[5].start(f, 0.25+0.2*v, 0.16+0.05*v); } break;
      case 6: { const deg=((step*3)%5); const f=degreeToFreq(deg, 0); activeVoices[6].start(f, 0.18+0.2*v, 0.1+0.05*v); } break;
      case 7: { const f=degreeToFreq((step%5), 2); activeVoices[7].start(f, 0.15+0.2*v, 0.2); } break;
    }
  }

  const moveCursor=()=>{ const x0=-(GRID.cols-1)*GRID.gapX/2; GRID.cursor.position.x = x0 + step*GRID.gapX; };
  function tick(){ step=(step+1)%GRID.cols; if(step%4===0) progressionIdx=(progressionIdx+1)%progression.length; moveCursor(); for(let r=0;r<GRID.rows;r++){ const v=pattern[r][step]; if(v>0) trig(r,v); } }

  // ===== Interaction: tap/hold on cells to toggle/cycle velocity
  const ray=new THREE.Raycaster(); const v2=new THREE.Vector2();
  function pickMeshesAt(x,y){ v2.x=(x/innerWidth)*2-1; v2.y=-(y/innerHeight)*2+1; ray.setFromCamera(v2,camera); const objs=[]; GRID.cells.forEach(row=>row.forEach(s=>objs.push(...s.children))); return ray.intersectObjects(objs); }
  let pressTimer=null; let pressedCell=null;
  canvas.addEventListener('pointerdown',e=>{ const hits=pickMeshesAt(e.clientX,e.clientY); if(!hits.length) return; const mesh=hits[0].object; const cell=mesh.parent; pressedCell=cell; const [r,c]=cell.userData.rc; pressTimer=setTimeout(()=>{ pattern[r][c]=3; cell.userData.active=3; cell.userData.pulse(1); toast(instruments[r]+" @"+(c+1)+" vel3"); },420); });
  addEventListener('pointerup',()=>{ if(!pressedCell) return; clearTimeout(pressTimer); const [r,c]=pressedCell.userData.rc; if(pattern[r][c]===0){ pattern[r][c]=1; } else if(pattern[r][c]===1){ pattern[r][c]=2; } else if(pattern[r][c]===2){ pattern[r][c]=0; } else { /* keep vel3 */ } pressedCell.userData.active=pattern[r][c]; pressedCell.userData.pulse(pattern[r][c]/3); pressedCell=null; });

  // ===== Camera controls
  let orbit=false, theta=0, dist=170; const btnOrbit=document.getElementById('btnOrbit'); const setOrbit=(on)=>{ orbit=!!on; btnOrbit.textContent=orbit?'Orbit ON':'Orbit OFF'; };
  btnOrbit.addEventListener('click',()=>setOrbit(!orbit));
  let drag=null; canvas.addEventListener('pointerdown',e=>{ drag={x:e.clientX,y:e.clientY, yaw:Math.atan2(camera.position.z,camera.position.x), pitch:Math.asin((camera.position.y-50)/dist)}; });
  addEventListener('pointermove',e=>{ if(!drag) return; const dx=e.clientX-drag.x; const dy=e.clientY-drag.y; const yaw=drag.yaw - dx*0.005; const pitch=Math.max(-1.2,Math.min(1.2, drag.pitch - dy*0.003)); const cx=Math.cos(yaw)*dist, cz=Math.sin(yaw)*dist, cy=50+Math.sin(pitch)*70; camera.position.set(cx,cy,cz); fitLook(); });
  addEventListener('pointerup',()=>{ drag=null; });
  let pinch=null; addEventListener('touchstart',e=>{ if(e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX; const dy=e.touches[0].clientY-e.touches[1].clientY; pinch={d:Math.hypot(dx,dy)}; } },{passive:false});
  addEventListener('touchmove',e=>{ if(pinch && e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX; const dy=e.touches[0].clientY-e.touches[1].clientY; const nd=Math.hypot(dx,dy); const k=nd/(pinch.d||1); pinch.d=nd; dist=Math.max(90,Math.min(420, dist/(k||1))); e.preventDefault(); } },{passive:false});
  addEventListener('touchend',()=>{ pinch=null; });

  // ===== Controls
  const btnStart=document.getElementById('btnStart');
  const btnPackPrev=document.getElementById('btnPackPrev');
  const btnPackNext=document.getElementById('btnPackNext');
  const btnHarmony=document.getElementById('btnHarmony');
  const btnShuffle=document.getElementById('btnShuffle');
  const btnClear=document.getElementById('btnClear');

  btnStart.addEventListener('click', async ()=>{ const ok=await audioInit(); if(!ok) return; try{ if(AC.state==='suspended') await AC.resume(); }catch{} buildVoices(); applyPack(packIdx); playing=true; startClock(); toast('Playing'); });
  btnPackPrev.addEventListener('click',()=>{ applyPack(--packIdx); });
  btnPackNext.addEventListener('click',()=>{ applyPack(++packIdx); });
  btnHarmony.addEventListener('click',()=>{ const order=['dorian','mixolydian','minor','major','pentMinor']; const i=(order.indexOf(scaleName)+1)%order.length; scaleName=order[i]; toast('Scale: '+scaleName); });
  btnShuffle.addEventListener('click',()=>{ for(let r=0;r<GRID.rows;r++){ for(let c=0;c<GRID.cols;c++){ pattern[r][c]=Math.random()<0.22? (1+Math.floor(Math.random()*3)) : 0; GRID.cells[r][c].userData.active=pattern[r][c]; GRID.cells[r][c].userData.pulse(pattern[r][c]/3); } } toast('Shuffled'); });
  btnClear.addEventListener('click',()=>{ for(let r=0;r<GRID.rows;r++){ for(let c=0;c<GRID.cols;c++){ pattern[r][c]=0; GRID.cells[r][c].userData.active=0; GRID.cells[r][c].userData.pulse(0); } } toast('Cleared'); });

  // ===== Animation
  function animate(){ requestAnimationFrame(animate); if(orbit){ theta+=0.004; camera.position.x=Math.cos(theta)*dist; camera.position.z=Math.sin(theta)*dist; camera.position.y=60+Math.sin(theta*0.6)*20; fitLook(); } renderer.render(scene,camera); }
  animate();

  // ===== Console tests (added)
  (function tests(){ try{ const results=[]; const ok=(n,p)=>results.push({test:n,pass:!!p});
    ok('THREE loaded', !!window.THREE);
    ok('Grid size matches', GRID.cells.length===GRID.rows && GRID.cells[0].length===GRID.cols);
    ok('Audio NOT ready before Start', AC===null);
    ok('Voices lazy (none before Start)', Array.isArray(activeVoices) && activeVoices.length===0);
    ok('Pattern matrix 8x16', pattern.length===8 && pattern[0].length===16);
    ok('Packs available', Array.isArray(PACKS) && PACKS.length>=5);
    console.table(results);
  }catch(e){} })();
})();
</script>
</body>
</html>
