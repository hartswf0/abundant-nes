<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Temporal Hypertetrahedron — Per-Face Layer Sculptor + Harmonic Engine</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; touch-action:none; }
  </style>
  <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js"}}</script>
</head>
<body>
<script type="module">
import * as THREE from 'three';

// --- Hot-reload / re-run guard ---
if (globalThis.__tetra_cleanup__) {
  try { globalThis.__tetra_cleanup__(); } catch (e) { console.warn('[Tetra] previous cleanup error', e); }
}

(() => { // isolate identifiers
  const instanceId = (globalThis.__tetra_instance_id__ = (globalThis.__tetra_instance_id__ || 0) + 1);

  // ===== Core setup =====
  const scene = new THREE.Scene();
  const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
  const DPR = Math.min(devicePixelRatio || 1, 2);
  renderer.setPixelRatio(DPR);
  renderer.setSize(innerWidth, innerHeight);
  renderer.setClearColor(0x000000, 1);
  renderer.localClippingEnabled = true;
  document.body.appendChild(renderer.domElement);

  let camera; const ORTHO = 3.4;
  function makeCamera(){
    const a = innerWidth/innerHeight;
    camera = new THREE.OrthographicCamera(-ORTHO*a, ORTHO*a, ORTHO, -ORTHO, 0.1, 100);
    camera.position.set(4,4,4); camera.lookAt(0,0,0);
  }
  makeCamera();

  // ===== Root group =====
  const tetra = new THREE.Group();
  scene.add(tetra);

  // ===== Geometry & vertices =====
  const tetGeo = new THREE.TetrahedronGeometry(2.4);
  const basePos = tetGeo.getAttribute('position');
  const uniq = new Map();
  for(let i=0;i<basePos.count;i++){
    const x=basePos.getX(i), y=basePos.getY(i), z=basePos.getZ(i);
    const k=`${x.toFixed(5)},${y.toFixed(5)},${z.toFixed(5)}`; if(!uniq.has(k)) uniq.set(k, new THREE.Vector3(x,y,z));
  }
  const verts = [...uniq.values()]; // 4 unique
  const centroid = verts.reduce((a,b)=> a.add(b.clone()), new THREE.Vector3()).multiplyScalar(1/verts.length);

  // Four faces (choose any 3-of-4)
  const facesIdx = [ [0,1,2], [0,1,3], [0,2,3], [1,2,3] ];
  const faces = facesIdx.map((fi)=>{
    const [i0,i1,i2]=fi; const v0=verts[i0], v1=verts[i1], v2=verts[i2];
    const opp = [0,1,2,3].find(j=> !fi.includes(j));
    const center = new THREE.Vector3().addVectors(v0,v1).add(v2).multiplyScalar(1/3);
    let n = new THREE.Vector3().subVectors(v1,v0).cross(new THREE.Vector3().subVectors(v2,v0)).normalize();
    if(n.dot(new THREE.Vector3().subVectors(centroid, center)) > 0) n.multiplyScalar(-1);
    return { fi, v:[v0.clone(),v1.clone(),v2.clone()], opp, oppV:verts[opp].clone(), center, normal:n };
  });

  // Wireframe
  const tetEdges = new THREE.LineSegments(new THREE.EdgesGeometry(tetGeo), new THREE.LineBasicMaterial({ color:0xEAEAEA, transparent:true, opacity:0.95 }));
  tetra.add(tetEdges);

  // Vertex foci
  const vertexGroup = new THREE.Group();
  for (const v of verts){
    const s = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 16), new THREE.MeshBasicMaterial({ color:0x8888ff }));
    s.position.copy(v); vertexGroup.add(s);
  }
  tetra.add(vertexGroup);

  // ===== Per-face layer systems =====
  const LAYERS = 64;               // keep tests stable
  const EXTRA_SUBDIV = 3;          // extra micro-slices (visual only)
  const faceSystems = [];

  function interpFaceTri(face, t){
    // t=0 at face, t->1 toward opposite vertex
    const a = face.oppV; const [b0,b1,b2] = face.v;
    const p0 = b0.clone().multiplyScalar(1-t).add(a.clone().multiplyScalar(t));
    const p1 = b1.clone().multiplyScalar(1-t).add(a.clone().multiplyScalar(t));
    const p2 = b2.clone().multiplyScalar(1-t).add(a.clone().multiplyScalar(t));
    return [p0,p1,p2];
  }

  function lineTri(p0,p1,p2, opacity, color){
    const g = new THREE.BufferGeometry();
    g.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
      p0.x,p0.y,p0.z, p1.x,p1.y,p1.z,
      p1.x,p1.y,p1.z, p2.x,p2.y,p2.z,
      p2.x,p2.y,p2.z, p0.x,p0.y,p0.z
    ]),3));
    return new THREE.LineSegments(g, new THREE.LineBasicMaterial({ color, transparent:true, opacity }));
  }
  function meshTri(p0,p1,p2){
    const g = new THREE.BufferGeometry();
    g.setAttribute('position', new THREE.BufferAttribute(new Float32Array([p0.x,p0.y,p0.z, p1.x,p1.y,p1.z, p2.x,p2.y,p2.z]),3));
    g.setIndex([0,1,2]); g.computeVertexNormals();
    return new THREE.Mesh(g, new THREE.MeshBasicMaterial({ color:0x000000, transparent:true, opacity:0.0, depthWrite:false, side:THREE.DoubleSide }));
  }

  const facePickMeshes = new THREE.Group();
  tetra.add(facePickMeshes);

  for(let f=0; f<4; f++){
    const face = faces[f];
    const group = new THREE.Group();            // primary 64 controllable slices
    const picks = new THREE.Group();            // pick meshes for primary slices
    const gold = new THREE.Group();             // per-slice gold particles
    const micro = new THREE.Group();            // extra visual micro-slices (redundant triangles)

    const layerObjs = []; const pickMeshes = [];
    for(let i=0;i<LAYERS;i++){
      const t = i/(LAYERS-1);
      const [p0,p1,p2] = interpFaceTri(face, t);
      const op = THREE.MathUtils.lerp(0.9, 0.05, t);
      const tri = lineTri(p0,p1,p2, op, 0xEAEAEA);
      tri.userData = { face:f, layerIndex:i };
      group.add(tri); layerObjs.push(tri);

      const pm = meshTri(p0,p1,p2); pm.userData = { face:f, layerIndex:i };
      picks.add(pm); pickMeshes.push(pm);

      // gold particles
      const N=60, g=new THREE.BufferGeometry(), pts=new Float32Array(N*3);
      for(let k=0;k<N;k++){
        const u=Math.random(), v=Math.random()*(1-u), w=1-u-v;
        const p = new THREE.Vector3().addScaledVector(p0,u).addScaledVector(p1,v).addScaledVector(p2,w);
        pts[k*3]=p.x; pts[k*3+1]=p.y; pts[k*3+2]=p.z;
      }
      g.setAttribute('position', new THREE.BufferAttribute(pts,3));
      const cloud = new THREE.Points(g, new THREE.PointsMaterial({ color:0xC9A227, size:0.014, transparent:true, opacity:0.28, depthWrite:false, blending:THREE.AdditiveBlending }));
      cloud.userData = { face:f, layerIndex:i };
      gold.add(cloud);

      // extra micro-slices between i and i+1 (except after last)
      if(i < LAYERS-1){
        for(let s=1; s<=EXTRA_SUBDIV; s++){
          const ft = i + s/(EXTRA_SUBDIV+1);
          const t2 = ft/(LAYERS-1);
          const [q0,q1,q2] = interpFaceTri(face, t2);
          const op2 = THREE.MathUtils.lerp(0.35, 0.03, t2);
          const tri2 = lineTri(q0,q1,q2, op2, 0x8AA3FF); // subtle bluish micro-lines
          tri2.renderOrder = -1; // draw behind primaries
          micro.add(tri2);
        }
      }
    }

    tetra.add(group); tetra.add(gold); tetra.add(micro); facePickMeshes.add(picks);

    faceSystems.push({ face, group, picks, gold, micro, layerObjs, pickMeshes, idx:0, band:3 });
  }

  // ===== Big face pickers for better selection =====
  const facePickers = new THREE.Group();
  const faceHints = new THREE.Group(); // faint outlines on hover/active
  scene.add(facePickers);
  scene.add(faceHints);
  const HINTS = [];
  for(let f=0; f<4; f++){
    const face = faces[f];
    const inflate = 1.12; // larger than true face for easy targeting
    const offset = 0.04;  // slight lift along normal
    const tri = face.v.map(v=> v.clone().sub(face.center).multiplyScalar(inflate).add(face.center).add(face.normal.clone().multiplyScalar(offset)));

    const g = new THREE.BufferGeometry();
    g.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
      tri[0].x,tri[0].y,tri[0].z,
      tri[1].x,tri[1].y,tri[1].z,
      tri[2].x,tri[2].y,tri[2].z
    ]),3));
    g.setIndex([0,1,2]); g.computeVertexNormals();
    const m = new THREE.MeshBasicMaterial({ color:0x000000, transparent:true, opacity:0.0, side:THREE.DoubleSide });
    const mesh = new THREE.Mesh(g,m); mesh.userData={ face:f };
    facePickers.add(mesh);

    const wg = new THREE.BufferGeometry();
    wg.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
      tri[0].x,tri[0].y,tri[0].z, tri[1].x,tri[1].y,tri[1].z,
      tri[1].x,tri[1].y,tri[1].z, tri[2].x,tri[2].y,tri[2].z,
      tri[2].x,tri[2].y,tri[2].z, tri[0].x,tri[0].y,tri[0].z
    ]),3));
    const wl = new THREE.LineSegments(wg, new THREE.LineBasicMaterial({ color:0x55ccff, transparent:true, opacity:0.0 }));
    wl.visible = true; faceHints.add(wl); HINTS.push(wl);
  }

  // ===== Clip volume (negative space sculpt) =====
  const clipPlanes = faces.map((face, f)=>{
    const n = face.normal.clone();
    const c0 = - n.dot(face.v[0]);
    const plane = new THREE.Plane(n, c0); plane.userData={ face:f, baseC:c0 }; return plane;
  });
  const solidMat = new THREE.MeshStandardMaterial({ color:0x0A0E15, metalness:0.1, roughness:0.9, transparent:true, opacity:0.45, side:THREE.DoubleSide, clippingPlanes:clipPlanes });
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(5,6,7); scene.add(dir);
  const amb = new THREE.AmbientLight(0x404040, 0.7); scene.add(amb);
  const solid = new THREE.Mesh(tetGeo.clone(), solidMat); tetra.add(solid);

  function updateClipPlanes(){
    for(const plane of clipPlanes){
      const f = plane.userData.face; const sys = faceSystems[f]; const face = faces[f];
      const t = sys.idx/(LAYERS-1);
      const p = interpFaceTri(face, t)[0];
      plane.set(face.normal, - face.normal.dot(p));
    }
  }

  // ===== State & Gestures =====
  let activeFace = 0; // controlled face
  let emphasis = 'balanced'; // 'wire' | 'gold' | 'balanced'
  let hueRate = 0.8;
  let autoBreath = false;  // STRICT: no auto movement by default
  let dragStart=null;
  let touch2 = null; // two-finger state
  let touch1 = null; // single-finger state
  let hoverFace = null;
  const vibe = (ms)=> navigator.vibrate && navigator.vibrate(ms);

  function setFaceIndex(faceId, i, cause='program'){
    const sys = faceSystems[faceId];
    const prev = sys.idx; sys.idx = Math.max(0, Math.min(LAYERS-1, i|0));
    if(prev!==sys.idx && cause!=='auto') vibe(6);
    const fall = sys.band;
    sys.layerObjs.forEach(tri=>{
      const d = Math.abs((tri.userData.layerIndex||0) - sys.idx);
      const near = Math.max(0, 1 - d/(fall||1));
      const m = tri.material;
      const baseOp = THREE.MathUtils.lerp(0.06, 0.95, near);
      m.opacity = emphasis==='wire'? baseOp : THREE.MathUtils.lerp(baseOp, baseOp*0.5, emphasis==='gold');
      m.color.setHex(d===0?0xFFFFFF:0xEAEAEA);
      m.needsUpdate=true;
    });
    sys.gold.children.forEach(cl=>{
      const d = Math.abs((cl.userData.layerIndex||0) - sys.idx);
      const near = Math.max(0, 1 - d/(fall||1));
      cl.material.opacity = emphasis==='gold' ? THREE.MathUtils.lerp(0.14, 0.95, near) : THREE.MathUtils.lerp(0.12, 0.6, near);
    });
    updateClipPlanes();
  }
  function setBand(faceId, b){ const sys = faceSystems[faceId]; sys.band = Math.max(0, Math.min(12, Math.round(b))); setFaceIndex(faceId, sys.idx, 'auto'); }
  function cycleEmphasis(){ emphasis = emphasis==='balanced'?'wire': emphasis==='wire'?'gold':'balanced'; faceSystems.forEach((_,f)=> setFaceIndex(f, faceSystems[f].idx,'auto')); }
  function setActiveFace(f){ activeFace = (f+4)%4; vibe(10); highlightActiveFace(); }
  function highlightActiveFace(){ faceSystems.forEach((sys,f)=>{ const strong=(f===activeFace); sys.layerObjs[0].material.color.setHex(strong?0x66CCFF:0xEAEAEA); sys.layerObjs[0].material.opacity = strong?1.0:0.9; }); }

  // Hover feedback
  function setHoverFace(f){
    hoverFace = f;
    for(let i=0;i<HINTS.length;i++){
      const ln = HINTS[i];
      const target = (i===hoverFace) ? 0.6 : (i===activeFace ? 0.35 : 0.0);
      ln.material.opacity = target;
    }
  }

  // Ray helpers
  const raycaster = new THREE.Raycaster();
  const mouseNDC = new THREE.Vector2();
  function faceUnderPointer(x,y){
    mouseNDC.x = (x/innerWidth)*2-1; mouseNDC.y = -(y/innerHeight)*2+1;
    raycaster.setFromCamera(mouseNDC, camera);
    const hits = raycaster.intersectObjects([...facePickers.children, ...facePickMeshes.children], false);
    if(hits.length){ return hits[0].object.userData.face ?? null; }
    return null;
  }

  // Scrub helper
  function scrub(faceId, deltaSteps, power=false){
    const gain = power ? 3 : 1;
    if (!Number.isFinite(deltaSteps) || deltaSteps === 0) return;
    setFaceIndex(faceId, faceSystems[faceId].idx + (deltaSteps*gain), power? 'power' : 'scrub');
  }

  function wheelDeltaToSteps(e){
    const m = e.deltaMode; // 0: pixel, 1: line, 2: page
    let d = e.deltaY;
    if(m===0){ d = Math.sign(d) * Math.min(3, Math.round(Math.abs(d)/80)); }
    else if(m===2){ d = Math.sign(d) * 3; }
    else { d = Math.sign(d); }
    return d|0;
  }

  // Event handlers
  function onWheel(e){
    const f = faceUnderPointer(e.clientX, e.clientY);
    setHoverFace(f);
    if(f!=null) setActiveFace(f);
    const steps = wheelDeltaToSteps(e);
    if(steps!==0) scrub(activeFace, steps, false);
    e.preventDefault();
  }

  function onPointerDown(e){ dragStart = { x:e.clientX, y:e.clientY, t:performance.now(), id:e.pointerId }; }
  function onPointerMove(e){
    setHoverFace(faceUnderPointer(e.clientX, e.clientY));
    if(!dragStart || dragStart.id!==e.pointerId) return;
    const dx=e.clientX-dragStart.x, dy=e.clientY-dragStart.y;
    if(Math.abs(dy)>=18 && Math.abs(dy)>Math.abs(dx)){
      scrub(activeFace, Math.sign(dy), false);
      dragStart.y = e.clientY;
    }
  }
  function onPointerUp(e){
    if(!dragStart) { setHoverFace(null); return; }
    const dt=performance.now()-dragStart.t; const dist=Math.hypot(e.clientX-dragStart.x, e.clientY-dragStart.y);
    if(dt<220 && dist<8){ pickAt(e.clientX, e.clientY); }
    dragStart=null; setHoverFace(null);
  }

  // Touch: per-face authority
  function onTouchStart(e){
    if(e.touches.length===1){
      const t = e.touches[0];
      const f = faceUnderPointer(t.clientX, t.clientY);
      if(f!=null) setActiveFace(f);
      touch1 = { id:0, y:t.clientY, lastY:t.clientY, face: (f!=null?f:activeFace), startT:performance.now() };
    } else if(e.touches.length===2){
      const a=e.touches[0], b=e.touches[1];
      touch2 = { a:{x:a.clientX,y:a.clientY}, b:{x:b.clientX,y:b.clientY}, dist:0, ang:0, lastMidY:(a.clientY+b.clientY)/2, t:performance.now(), long:false };
      touch2.dist = Math.hypot(touch2.a.x-touch2.b.x, touch2.a.y-touch2.b.y);
      touch2.ang = Math.atan2(touch2.b.y-touch2.a.y, touch2.b.x-touch2.a.x);
    }
  }
  function onTouchMove(e){
    if(e.touches.length===1 && touch1){
      const t = e.touches[0];
      const dy = t.clientY - touch1.lastY;
      if(Math.abs(dy) >= 18){ scrub(touch1.face, Math.sign(dy), false); touch1.lastY = t.clientY; }
    } else if(e.touches.length===2 && touch2){
      const a=e.touches[0], b=e.touches[1];
      const midY = (a.clientY+b.clientY)/2;
      const nd = Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY);
      const pinch = (nd - touch2.dist) / 60;
      if(Math.abs(pinch)>0.05){ setBand(activeFace, faceSystems[activeFace].band + pinch*2); touch2.dist = nd; }
      const dMid = midY - touch2.lastMidY;
      if(Math.abs(dMid) >= 18){ scrub(activeFace, Math.sign(dMid), true); touch2.lastMidY = midY; }
      // two-finger long-press toggles sequencer
      if(!touch2.long && performance.now()-touch2.t > 450){ toggleSeq(); touch2.long=true; vibe(20); }
    }
  }
  function onTouchEnd(e){
    if(e.touches.length===0){ touch1=null; touch2=null; }
    else if(e.touches.length===1){ touch2=null; }
  }

  let tapTimes=[];
  function onPointerUpTap(){
    const now=performance.now(); tapTimes = tapTimes.filter(t=> now - t < 420); tapTimes.push(now);
    if(tapTimes.length===2){ autoBreath=!autoBreath; vibe(10);} if(tapTimes.length===3){ cycleEmphasis(); vibe(18); tapTimes=[];}
  }

  // Picking (face, layer, vertex)
  const pickRay = new THREE.Raycaster(); const pickNDC = new THREE.Vector2();
  function pickAt(cx, cy){
    pickNDC.x = (cx/innerWidth)*2-1; pickNDC.y = -(cy/innerHeight)*2+1; pickRay.setFromCamera(pickNDC, camera);
    const candidates = [ ...facePickers.children, ...facePickMeshes.children, ...faceSystems.flatMap(s=> s.pickMeshes), ...vertexGroup.children ];
    const hits = pickRay.intersectObjects(candidates, false);
    if(hits.length){
      const h = hits[0];
      if(h.object.userData.face!=null && h.object.userData.layerIndex==null){ setActiveFace(h.object.userData.face); return; }
      if(h.object.userData.layerIndex!=null){ setActiveFace(h.object.userData.face); setFaceIndex(activeFace, h.object.userData.layerIndex, 'pick'); return; }
      vibe(12);
    }
  }

  // ===== Harmonic Engine + Sequencer =====
  let audioCtx=null; let master=null; let clock=null; let tempo=94; let swing=0.12; let seqRunning=false;
  // simple feedback delay network as spatializer
  let delayL, delayR, fbL, fbR, merger;

  function db(x){ return Math.pow(10, x/20); }

  function bootAudio(){
    if(audioCtx) return;
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
    master = audioCtx.createGain(); master.gain.value = 0.9; master.connect(audioCtx.destination);
    // delays
    delayL = audioCtx.createDelay(); delayR = audioCtx.createDelay();
    delayL.delayTime.value = 0.23; delayR.delayTime.value = 0.31;
    fbL = audioCtx.createGain(); fbR = audioCtx.createGain(); fbL.gain.value = 0.35; fbR.gain.value = 0.33;
    delayL.connect(fbL).connect(delayL); delayR.connect(fbR).connect(delayR);
    merger = audioCtx.createChannelMerger(2);
    delayL.connect(merger, 0, 0); delayR.connect(merger, 0, 1);
    merger.connect(master);
  }

  // musical helpers
  const SCALES = {
    lydian:[0,2,4,6,7,9,11],
    phrygian:[0,1,3,5,7,8,10],
    harmonicMinor:[0,2,3,5,7,8,11],
    octatonic:[0,2,3,5,6,8,9,11]
  };
  const FACE_ROOTS = [48, 52, 55, 60]; // C2, E2, G2, C3
  const FACE_SCALE = ['lydian','harmonicMinor','octatonic','phrygian'];

  function noteFreq(midi){ return 440 * Math.pow(2, (midi-69)/12); }
  function quantize(layerIdx, faceId){
    const scale = SCALES[FACE_SCALE[faceId]]; const root = FACE_ROOTS[faceId];
    const octave = 12 * Math.floor(layerIdx/scale.length);
    const deg = scale[layerIdx % scale.length];
    return root + octave + deg;
  }

  function envHit(t0, node, a=0.002, d=0.12, s=0.0, r=0.18, peak=1.0){
    const g = node.gain; g.cancelScheduledValues(t0); g.setValueAtTime(0.0001, t0); g.linearRampToValueAtTime(peak, t0+a); g.linearRampToValueAtTime(s*peak, t0+a+d); g.exponentialRampToValueAtTime(0.0001, t0+a+d+r);
  }

  function synthFace(faceId, when, step){
    const sys = faceSystems[faceId];
    // map current layer index +/- small wander to midi
    const idx = sys.idx; const midi = quantize(idx + (step%2), faceId);
    const f = noteFreq(midi);
    // different timbre per face
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain(); g.gain.value = 0.0;
    const filt = audioCtx.createBiquadFilter(); filt.type = ['lowpass','bandpass','highpass','notch'][faceId%4]; filt.Q.value = 8;
    o.type = ['sine','square','triangle','sawtooth'][faceId%4];
    o.frequency.value = f;
    // slight face-dependent detune/harmonics
    const det = (faceId-1.5)*3; o.detune.value = det;
    o.connect(filt); filt.connect(g);
    // pan to delays L/R alternating by step parity
    const panTo = (step%2===0) ? delayL : delayR;
    g.connect(panTo);
    envHit(when, g, 0.004, 0.10 + sys.band*0.01, 0.0, 0.18 + (idx/85), 0.65);
    o.start(when); o.stop(when + 0.6);
  }

  // Euclidean rhythm generator (Bjorklund)
  function euclid(pulses, steps){
    const pattern = []; let counts = []; let remainders = [pulses]; let level=0;
    while(true){ counts.push(Math.floor(steps/(remainders[level]||1))); remainders.push(steps % (remainders[level]||1)); steps = remainders[level]; level++; if(remainders[level]<=1) break; }
    counts.push(steps);
    function build(level){ if(level===-1){ pattern.push(0); return; } else if(level===-2){ pattern.push(1); return; }
      build(level-1); for(let i=0;i<counts[level];i++) build(level-2);
    }
    build(level);
    return pattern.slice(0, counts.reduce((a,b)=>a+b,0));
  }

  // per-face tracks derived from geometry state
  function trackForFace(faceId){
    const sys = faceSystems[faceId];
    const density = Math.max(1, Math.min(15, Math.round(3 + sys.band + sys.idx/8)));
    const steps = 16; const pulses = Math.min(steps, density);
    const pat = euclid(pulses, steps);
    return { steps, pat };
  }

  let lastStep = -1; let lookahead = 0.1; let timer=null;
  function scheduleLoop(){
    const now = audioCtx.currentTime; const spb = 60/tempo; // seconds per beat
    const stepDur = spb/2; // 8th-note grid
    const swingPush = (lastStep%2===1) ? swing*stepDur : 0;
    while(clock < now + lookahead){
      const step = Math.floor((clock - 0)/stepDur);
      if(step !== lastStep){
        for(let f=0; f<4; f++){
          const tr = trackForFace(f);
          if(tr.pat[step % tr.steps]) synthFace(f, clock + swingPush, step);
        }
        lastStep = step;
      }
      clock += stepDur;
    }
  }

  function startSeq(){ if(!audioCtx) bootAudio(); if(!audioCtx) return; if(seqRunning) return; clock = audioCtx.currentTime + 0.05; lastStep=-1; seqRunning=true; if(timer) clearInterval(timer); timer = setInterval(scheduleLoop, 25); }
  function stopSeq(){ if(!seqRunning) return; seqRunning=false; if(timer){ clearInterval(timer); timer=null; } }
  function toggleSeq(){ if(!audioCtx || audioCtx.state==='suspended') bootAudio(); if(!audioCtx) return; if(seqRunning) stopSeq(); else startSeq(); }

  // Keyboard convenience (not visible UI): M toggles sequencer, +/- tempo, [ ] swing
  addEventListener('keydown', (e)=>{
    if(e.key==='m' || e.key==='M'){ toggleSeq(); }
    else if(e.key==='+'){ tempo = Math.min(180, tempo+2); }
    else if(e.key==='-'){ tempo = Math.max(40, tempo-2); }
    else if(e.key==='['){ swing = Math.max(0, swing-0.02); }
    else if(e.key===']'){ swing = Math.min(0.4, swing+0.02); }
  });

  // ===== Visual loop =====
  let t0=0; let animId=0;
  function animate(){
    animId = requestAnimationFrame(animate);
    t0 += 0.005;
    const hue = (Math.sin(t0*hueRate)+1)*0.5;
    tetEdges.material.color.setHSL(hue, 0.6, 0.7);
    const sys = faceSystems[activeFace]; sys.layerObjs[sys.idx].material.color.setHSL((hue+0.5)%1, 0.8, 0.8);
    if(seqRunning){ // pulse outlines on sequencer beats
      const pulse = 0.55 + 0.4*Math.max(0, Math.sin(audioCtx.currentTime*tempo*0.2));
      for(let i=0;i<HINTS.length;i++){ HINTS[i].material.opacity = (i===activeFace? Math.max(HINTS[i].material.opacity, 0.4) : HINTS[i].material.opacity*0.98); HINTS[i].material.linewidth = 1; }
      tetEdges.material.opacity = pulse;
    }
    renderer.render(scene, camera);
  }

  // Init
  faceSystems.forEach((_,f)=> setFaceIndex(f, 0, 'auto'));
  setActiveFace(0); updateClipPlanes(); animate();
  function onResize(){ renderer.setSize(innerWidth, innerHeight); makeCamera(); }
  addEventListener('resize', onResize);

  // Attach input listeners
  addEventListener('wheel', onWheel, { passive:false });
  addEventListener('pointerdown', onPointerDown);
  addEventListener('pointermove', onPointerMove);
  addEventListener('pointerup', onPointerUp, { passive:true });
  addEventListener('touchstart', onTouchStart, { passive:true });
  addEventListener('touchmove', onTouchMove, { passive:true });
  addEventListener('touchend', onTouchEnd, { passive:true });
  addEventListener('pointerup', onPointerUpTap);

  // ===== Self-tests (console-only) =====
  (function selfTests(){
    try{
      console.assert(verts.length===4, '4 unique vertices');
      console.assert(faces.length===4, '4 faces');
      const outwardOK = faces.every(f=> f.normal.dot(new THREE.Vector3().subVectors(centroid, f.center)) < 0);
      console.assert(outwardOK, 'Normals outward');
      console.assert(faceSystems.length===4 && faceSystems.every(fs=> fs.layerObjs.length===64), '4 face systems × 64 layers');
      console.assert(faceSystems.every(fs=> fs.micro.children.length>0), 'Extra micro-slices present');
      const f0 = 0; const pTest = interpFaceTri(faceSystems[f0].face, faceSystems[f0].idx/(LAYERS-1))[0];
      const dist = clipPlanes[f0].distanceToPoint(pTest); console.assert(Math.abs(dist) < 1e-4, 'Clip plane correct');
      console.assert(facePickers.children.length===4, '4 big face pickers');
      // Harmonic Engine bootstrap
      bootAudio(); console.assert(audioCtx && master, 'Audio booted');
      const nA = noteFreq(60); console.assert(Math.abs(nA-261.625565) < 1.0, 'noteFreq approx C4');
      const tr = trackForFace(0); console.assert(tr.steps===16 && tr.pat.length>0, 'Track generated');
      // Transport
      stopSeq(); startSeq(); console.assert(seqRunning, 'Sequencer running'); stopSeq(); console.assert(!seqRunning, 'Sequencer stopped');
      console.log(`[Harmonic Engine v${instanceId}] self-tests passed`);
    }catch(err){ console.warn('[Harmonic Engine] self-test issue', err); }
  })();

  // ===== Cleanup for hot reload =====
  globalThis.__tetra_cleanup__ = () => {
    try { cancelAnimationFrame(animId); } catch {}
    try { removeEventListener('wheel', onWheel); } catch {}
    try { removeEventListener('pointerdown', onPointerDown); } catch {}
    try { removeEventListener('pointermove', onPointerMove); } catch {}
    try { removeEventListener('pointerup', onPointerUp, { passive:true }); } catch {}
    try { removeEventListener('touchstart', onTouchStart, { passive:true }); } catch {}
    try { removeEventListener('touchmove', onTouchMove, { passive:true }); } catch {}
    try { removeEventListener('touchend', onTouchEnd, { passive:true }); } catch {}
    try { removeEventListener('pointerup', onPointerUpTap); } catch {}
    try { removeEventListener('resize', onResize); } catch {}
    try { if (timer) clearInterval(timer); } catch {}
    try { if (audioCtx) audioCtx.close(); } catch {}
    try { renderer.domElement && renderer.domElement.remove(); } catch {}
  };
})();
</script>
</body>
</html>
