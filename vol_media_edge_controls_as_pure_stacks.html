<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>VOL-MEDIA — Tight Stacks (Ocean Trap)</title>
<style>
  :root{
    --void:#07080d; --foam:#e6f6ff; --ice:#bfe6ff; --glow:#7fd7ff;
    --bar-thickness:18px;      /* thicker lines */
    --bar-gap:0px;             /* zero spacing */
    --chip-size:96px;          /* touch target */
    --edge-pad:8px;            /* compact edge padding */
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color:transparent; touch-action:none; user-select:none}
  html,body{height:100%; margin:0; padding:0}
  body{background:radial-gradient(1200px 780px at 50% 35%, #0f1628 0%, var(--void) 64%); overflow:hidden; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif}
  canvas#scene{position:fixed; inset:0; display:block; z-index:1}

  /* EDGE ALLEYS — NO BOXES. Pure rails. */
  .edge{position:fixed; display:flex; gap:0; pointer-events:auto; z-index:10; isolation:isolate; background:transparent}
  #bottomEdge{left:0; right:0; bottom:0; height:calc(var(--chip-size) + var(--edge-pad)*2); justify-content:center; padding:var(--edge-pad) 8px}
  #rightEdge{right:0; top:50%; transform:translateY(-50%); width:calc(var(--chip-size) + var(--edge-pad)*2); flex-direction:column; align-items:center; padding:8px var(--edge-pad)}

  /* CHIP — only bars (layers). */
  .chip{width:var(--chip-size); height:var(--chip-size); margin:0; position:relative; cursor:pointer; background:transparent; will-change:transform}
  .chip::after{content:""; position:absolute; inset:-10px; border-radius:24px}

  /* LAYERS — dense bars with NO GAP */
  .chip .layers{position:absolute; inset:6px; display:flex; flex-direction:column; justify-content:flex-end; gap:var(--bar-gap)}
  .chip .lay{
    height:var(--bar-thickness); border-radius:9px;
    background:linear-gradient(90deg, rgba(170,235,255,.92), rgba(255,255,255,.98));
    filter:drop-shadow(0 0 10px rgba(120,200,255,.5));
    box-shadow:inset 0 -1px 2px rgba(0,0,0,.18);
    opacity:.9; transform:translateZ(0); transition:none;
  }
  .chip.on .lay{opacity:1}

  /* Per-chip visual intensity (from drag velocity) */
  .chip{ --intensity: 0; }
  .chip .lay{ filter: drop-shadow(0 0 calc(6px + var(--intensity)*10px) rgba(127,215,255,.8)) }

  /* Hit flash */
  @keyframes flash{ 0%{opacity:.35; filter:brightness(1)} 50%{opacity:1; filter:brightness(2.8) drop-shadow(0 0 22px #fff)} 100%{opacity:.4; filter:brightness(1)} }
  .chip.hit .lay{ animation:flash .22s ease-out }

  /* Zone marker (tiny notch that slides) */
  .chip .zoneMarker{position:absolute; left:50%; transform:translateX(-50%); width:42%; height:4px; border-radius:2px; background:rgba(255,255,255,.9); box-shadow:0 0 10px rgba(255,255,255,.6); opacity:.9}

  /* Echo glyph (kept) */
  .chip .echo{ position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:22px; opacity:0; color:#e9f7ff; text-shadow:0 0 22px rgba(180,230,255,.7); pointer-events:none }
  .chip:active .echo{opacity:.9}

  @media (max-width:760px){ :root{ --chip-size:92px; --bar-thickness:20px } }
</style>
</head>
<body>
  <canvas id="scene"></canvas>
  <div id="bottomEdge" class="edge" aria-hidden="true"></div>
  <div id="rightEdge" class="edge" aria-hidden="true"></div>

<script>
(()=>{
  /* ============== CANVAS ============== */
  const canvas=document.getElementById('scene');
  const ctx=canvas.getContext('2d');
  const DPR=Math.max(1,devicePixelRatio||1);
  let W=0,H=0;
  function resize(){ W=innerWidth; H=innerHeight; canvas.width=W*DPR; canvas.height=H*DPR; canvas.style.width=W+'px'; canvas.style.height=H+'px'; ctx.setTransform(DPR,0,0,DPR,0,0); }
  addEventListener('resize',resize,{passive:true}); resize();

  /* ============== HAPTICS ============== */
  const vibe=(p)=>{ try{ navigator.vibrate && navigator.vibrate(p) }catch{} };
  const hapticTick=()=>vibe(5);
  const hapticBeat=()=>vibe([2,8,2]);
  const hapticStrong=()=>vibe([6,12,6]);

  /* ============== AUDIO CORE ============== */
  let audioCtx=null, masterGain=null, reverbBus=null, reverbSend=null;
  const AC=(window.AudioContext||window.webkitAudioContext);
  function ensureAudio(){
    if(audioCtx) return;
    audioCtx=new AC({latencyHint:'interactive'});
    masterGain=audioCtx.createGain(); masterGain.gain.value=0.38; masterGain.connect(audioCtx.destination);
    // simple feedback "reverb" (Brian Eno style wash)
    const delay=audioCtx.createDelay(1.2); delay.delayTime.value=0.28;
    const fb=audioCtx.createGain(); fb.gain.value=0.45;
    const tone=audioCtx.createBiquadFilter(); tone.type='lowpass'; tone.frequency.value=4200; tone.Q.value=0.3;
    delay.connect(fb); fb.connect(tone); tone.connect(delay);
    reverbBus=audioCtx.createGain(); reverbBus.gain.value=0.28; reverbBus.connect(masterGain);
    reverbSend=audioCtx.createGain(); reverbSend.gain.value=0.22; reverbSend.connect(delay); delay.connect(reverbBus);
  }
  const click=()=>{ if(!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='triangle'; o.frequency.value=740; g.gain.value=0.12; g.gain.exponentialRampToValueAtTime(0.001,audioCtx.currentTime+0.05); o.connect(g); g.connect(masterGain); o.start(); o.stop(audioCtx.currentTime+0.05); };

  /* ============== COLORS & STATE ============== */
  const COLORS=[["#66a6ff","#89f7fe"],["#f093fb","#f5576c"],["#4facfe","#00f2fe"],["#43e97b","#38f9d7"],["#fa709a","#fee140"],["#30cfd0","#330867"],["#a8edea","#fed6e3"],["#ff9a9e","#fecfef"]];
  const state={ gridSizes:[16,8,4,2], gridIdx:1, cols:8, rows:8, baseCell:32, cam:{phi:0.2*Math.PI, theta:0.22*Math.PI}, playing:false, t:0, bpm:122, playhead:0, selection:null, focus:{tx:0,tz:0,sx:0,sz:0,scale:1,targetScale:1,lerp:0.16}, aimInflate:40, chips:{} };

  function makeCell(r){ return{ on:Math.random()<0.35, vel:0.8, density:0.9, len:1.0, pitch:0, pan:(r-3.5)/3.5, lum:1.0, sep:1.0, layers:0.7, halo:1.0, twist:0.12, speed:1.0, _phase:0 }; }
  function makeGrid(cols){ const g=[]; for(let r=0;r<state.rows;r++){ const row=[]; for(let c=0;c<cols;c++){ row.push(makeCell(r)); } g.push(row); } return g; }
  let grid=makeGrid(state.cols);

  /* ============== CHIPS ============== */
  const $=id=>document.getElementById(id);
  function buildLayers(el,n=12,lit=6){
    const need=n-el.children.length;
    for(let i=0;i<need;i++){ const d=document.createElement('div'); d.className='lay'; el.appendChild(d); }
    const kids=[...el.children];
    kids.forEach((k,i)=>{ const visible=i<n; k.style.display = visible ? 'block' : 'none'; k.style.opacity = (i>=n-lit) ? '1' : '.5'; });
  }
  function makeChip(icon,layers=12,lit=6){
    const c=document.createElement('div'); c.className='chip';
    c.innerHTML=`<div class="layers"></div><div class="zoneMarker" style="bottom:6px"></div><div class="echo">${icon}</div>`;
    buildLayers(c.querySelector('.layers'),layers,lit);
    return c;
  }

  const bottomEdge=$('bottomEdge'); const rightEdge=$('rightEdge');
  const playChip=makeChip('▶',8,2), tempoChip=makeChip('⏱',10,6), densityChip=makeChip('⬚',10,7), pitchChip=makeChip('♪',10,5), lengthChip=makeChip('↔',10,6);
  bottomEdge.append(playChip,tempoChip,densityChip,pitchChip,lengthChip);
  const gridChip=makeChip('⊞',8,6), lumChip=makeChip('☀',10,7), sepChip=makeChip('⇅',10,6), haloChip=makeChip('◉',10,5), twistChip=makeChip('↺',10,6), speedChip=makeChip('⚡',10,7);
  rightEdge.append(gridChip,lumChip,sepChip,haloChip,twistChip,speedChip);

  /* ============== DRAG ENGINE (tight, low-latency) ============== */
  function attachTightDrag(chip, get, set, {min=0, max=1, zones=12, scale=1, snap=null}={}){
    let grabbing=false, sy=0, start=0, lastZone=-1, lastY=0, lastT=0;
    const L=chip.querySelector('.layers'); const marker=chip.querySelector('.zoneMarker');
    const setVisual=(v)=>{ const norm=(v-min)/(max-min); const z=Math.max(0,Math.min(zones-1,Math.round(norm*(zones-1)))); if(z!==lastZone){ lastZone=z; hapticTick(); } const lit=Math.max(1,z+1); buildLayers(L,zones,lit); const zoneHeight=(chip.clientHeight-12)/zones; marker.style.bottom=(6+z*zoneHeight)+"px"; };
    chip.addEventListener('pointerdown',e=>{ ensureAudio(); grabbing=true; sy=e.clientY; start=get(); lastY=sy; lastT=performance.now(); chip.setPointerCapture(e.pointerId); setVisual(start); hapticTick(); click(); e.preventDefault(); });
    chip.addEventListener('pointermove',e=>{ if(!grabbing) return; const dy=sy-e.clientY; let v=start+dy*scale; v=Math.max(min,Math.min(max,v)); if(snap){ v=Math.round(v/snap)*snap; } set(v); const now=performance.now(); const vy=(lastY-e.clientY)/Math.max(1,(now-lastT)); const intensity=Math.min(1,Math.abs(vy)*14); chip.style.setProperty('--intensity', intensity.toFixed(3)); lastY=e.clientY; lastT=now; setVisual(v); },{passive:false});
    const end=()=>{ if(!grabbing) return; grabbing=false; chip.style.setProperty('--intensity','0'); };
    chip.addEventListener('pointerup',end); chip.addEventListener('pointercancel',end);
  }

  // Wire controls
  playChip.addEventListener('pointerdown',()=>{ ensureAudio(); state.playing=!state.playing; buildLayers(playChip.querySelector('.layers'),8,state.playing?8:1); playChip.classList.toggle('on',state.playing); hapticStrong(); click(); });
  attachTightDrag(tempoChip, ()=>state.bpm, v=>state.bpm=Math.round(v), {min:60,max:200,zones:16,scale:0.8,snap:1});
  attachTightDrag(densityChip, ()=>state.chips.density??0.9, v=>{state.chips.density=v; if(state.selection){ grid[state.selection.r][state.selection.c].density=v; }}, {min:0,max:1,zones:12,scale:1/140,snap:0.01});
  attachTightDrag(pitchChip, ()=>state.chips.pitch??0, v=>{ state.chips.pitch=v; if(state.selection){ grid[state.selection.r][state.selection.c].pitch=v; if(audioCtx) trig(state.selection.r,grid[state.selection.r][state.selection.c]); }}, {min:-24,max:24,zones:25,scale:0.22,snap:1});
  attachTightDrag(lengthChip, ()=>state.chips.length??1.0, v=>{ state.chips.length=v; if(state.selection){ grid[state.selection.r][state.selection.c].len=v; }}, {min:0.08,max:3.0,zones:14,scale:0.012,snap:0.02});
  gridChip.addEventListener('pointerdown',()=>{ state.gridIdx=(state.gridIdx+1)%state.gridSizes.length; const n=state.gridSizes[state.gridIdx]; state.cols=n; grid=makeGrid(state.cols); buildLayers(gridChip.querySelector('.layers'),8,8-state.gridIdx); state.focus.targetScale=1; hapticStrong(); click(); });
  attachTightDrag(lumChip, ()=>state.chips.lum??1.0, v=>{ state.chips.lum=v; if(state.selection){ grid[state.selection.r][state.selection.c].lum=v; }}, {min:0.2,max:2.6,zones:14,scale:0.01,snap:0.02});
  attachTightDrag(sepChip, ()=>state.chips.sep??1.0, v=>{ state.chips.sep=v; if(state.selection){ grid[state.selection.r][state.selection.c].sep=v; }}, {min:0.3,max:2.6,zones:14,scale:0.01,snap:0.02});
  attachTightDrag(haloChip, ()=>state.chips.halo??1.0, v=>{ state.chips.halo=v; if(state.selection){ grid[state.selection.r][state.selection.c].halo=v; }}, {min:0,max:2.2,zones:12,scale:0.012,snap:0.02});
  attachTightDrag(twistChip, ()=>state.chips.twist??0.12, v=>{ state.chips.twist=v; if(state.selection){ grid[state.selection.r][state.selection.c].twist=v; }}, {min:-2,max:2,zones:16,scale:0.012,snap:0.02});
  attachTightDrag(speedChip, ()=>state.chips.speed??1.0, v=>{ state.chips.speed=v; if(state.selection){ grid[state.selection.r][state.selection.c].speed=v; }}, {min:0.25,max:4,zones:16,scale:0.018,snap:0.01});

  /* ============== SYNTH ENGINES (Ocean/Trap/Eno-ish) ============== */
  function envGain(time,a=0.005,d=0.08,s=0.0,r=0.2,peak=0.8){ const g=audioCtx.createGain(); g.gain.setValueAtTime(0,time); g.gain.linearRampToValueAtTime(peak,time+a); g.gain.linearRampToValueAtTime(peak*s,time+a+d); g.gain.exponentialRampToValueAtTime(0.0001, time+a+d+r); return g; }

  function volumeGlide(freq,len=1.4,vel=0.8,pan=0){ if(!audioCtx) return; const o=audioCtx.createOscillator(); const g=envGain(audioCtx.currentTime,0.01,0.08,0,len,0.35*vel); const p=audioCtx.createStereoPanner(); o.type='sine'; o.frequency.setValueAtTime(freq,audioCtx.currentTime); o.frequency.exponentialRampToValueAtTime(Math.max(40,freq*0.45),audioCtx.currentTime+len); p.pan.value=pan; o.connect(g); g.connect(p); p.connect(masterGain); g.connect(reverbSend); o.start(); o.stop(audioCtx.currentTime+len+0.1); }

  // 808-ish kick
  function kick(){ if(!audioCtx) return; const t=audioCtx.currentTime; const o=audioCtx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(120,t); o.frequency.exponentialRampToValueAtTime(42,t+0.22); const g=envGain(t,0.001,0.05,0,0.3,1.2); g.connect(masterGain); g.connect(reverbSend); o.connect(g); o.start(t); o.stop(t+0.32); }
  // Snare/Clap blend
  function snare(){ if(!audioCtx) return; const t=audioCtx.currentTime; const noise=audioCtx.createBufferSource(); const buf=audioCtx.createBuffer(1, audioCtx.sampleRate*0.25, audioCtx.sampleRate); const d=buf.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,2); } noise.buffer=buf; const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1900; bp.Q.value=0.8; const g=envGain(t,0.001,0.05,0,0.18,0.9); noise.connect(bp); bp.connect(g); g.connect(masterGain); g.connect(reverbSend); noise.start(t); noise.stop(t+0.2); }
  // Hats
  function hat(){ if(!audioCtx) return; const t=audioCtx.currentTime; const noise=audioCtx.createBufferSource(); const buf=audioCtx.createBuffer(1, audioCtx.sampleRate*0.05, audioCtx.sampleRate); const d=buf.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1); } noise.buffer=buf; const hp=audioCtx.createBiquadFilter(); hp.type='highpass'; hp.frequency.value=6000; const g=envGain(t,0.001,0.01,0,0.05,0.6); noise.connect(hp); hp.connect(g); g.connect(masterGain); noise.start(t); noise.stop(t+0.06); }
  // Sub bass note
  function sub(freq){ if(!audioCtx) return; const t=audioCtx.currentTime; const o=audioCtx.createOscillator(); o.type='sine'; const g=envGain(t,0.005,0.12,0.4,0.5,0.8); o.frequency.setValueAtTime(freq,t); o.connect(g); g.connect(masterGain); g.connect(reverbSend); o.start(t); o.stop(t+0.8); }
  // Ocean pad (vocoder-ish formants)
  function oceanPad(){ if(!audioCtx) return; const t=audioCtx.currentTime; const noise=audioCtx.createBufferSource(); const len=audioCtx.sampleRate*1.2; const buf=audioCtx.createBuffer(1,len, audioCtx.sampleRate); const d=buf.getChannelData(0); for(let i=0;i<len;i++){ d[i]=(Math.random()*2-1)*0.6; } noise.buffer=buf; const g=envGain(t,0.8,1.2,0.9,3.5,0.25); const carriers=[340,800,2200]; const sum=audioCtx.createGain(); sum.gain.value=1.0; carriers.forEach((fc,i)=>{ const bp=audioCtx.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=fc; bp.Q.value=3; const lfo=audioCtx.createOscillator(); lfo.type='sine'; lfo.frequency.value=[0.18,0.24,0.31][i]; const lfoGain=audioCtx.createGain(); lfoGain.gain.value=120; lfo.connect(lfoGain); lfoGain.connect(bp.frequency); noise.connect(bp); bp.connect(sum); lfo.start(); }); sum.connect(g); g.connect(reverbSend); g.connect(masterGain); noise.start(t); noise.stop(t+4.0); }

  /* ============== SEQUENCER ============== */
  const scale=[0,3,5,7,10];
  function noteToFreq(n){ return 55*Math.pow(2,n/12); }
  function triggerBeat(step){ // trap-ish
    const barStep=step%16;
    if(barStep===0||barStep===8) kick();
    if([4,12].includes(barStep)) snare();
    if([2,6,10,14].includes(barStep)) hat();
    // Sub bass on 0/8 using scale degrees
    if(barStep===0||barStep===8){ const base=scale[Math.floor(Math.random()*scale.length)]; sub(noteToFreq(12+base-12)); }
    if(barStep===0){ oceanPad(); }
  }

  /* ============== GRID RENDER ============== */
  function spacing(){ const G=Math.max(state.cols,state.rows); const fx=G/state.cols,fz=G/state.rows; return{dx:state.baseCell*fx*1.3,dz:state.baseCell*fz*1.3}; }
  function isoProject(x,y,z){ const {phi,theta}=state.cam; const cy=Math.cos(theta),sy=Math.sin(theta); const cx=Math.cos(phi),sx=Math.sin(phi); let x1=x*cy+z*sy; let z1=-x*sy+z*cy; let y2=y*cx-z1*sx; const f=state.focus; x1-=f.sx; y2-=f.sz; return{x:W*0.5+x1,y:H*0.48+y2,depth:z1}; }
  function cellCenter(c,r){ const {dx,dz}=spacing(); const w=(state.cols-1)*dx; const h=(state.rows-1)*dz; return{x:c*dx-w/2,y:0,z:r*dz-h/2}; }
  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function colorize(hex,sat){ const n=parseInt(hex.slice(1),16); let r=(n>>16)&255,g=(n>>8)&255,b=n&255; const gr=0.3*r+0.59*g+0.11*b; const mix=(t,a,b)=>Math.round(a*(1-t)+b*t); r=mix(1-sat,r,gr); g=mix(1-sat,g,gr); b=mix(1-sat,b,gr); return`rgb(${r},${g},${b})`; }
  function calcLayersFrom(v){ return Math.round(5+v*18); }

  const triggeredStacks=new Set();
  function drawStack(c,r,cell){
    const base=cellCenter(c,r);
    const color=COLORS[r%COLORS.length][0];
    const sel=state.selection&&state.selection.r===r&&state.selection.c===c;
    const p=isoProject(base.x,0,base.z);
    const layers=calcLayersFrom(cell.layers);
    const lum=cell.lum,sep=cell.sep,tw=cell.twist,halo=cell.halo;
    const key=`${c},${r}`; const isTrigger=triggeredStacks.has(key); const wiggle=isTrigger?Math.sin(Date.now()*0.028)*2.0:0;

    ctx.save(); ctx.translate(p.x+wiggle,p.y); ctx.globalAlpha=0.10; ctx.fillStyle=color; roundedRect(-22,-12,44,24,9); ctx.fill(); ctx.restore();

    for(let i=0;i<layers;i++){
      const y=i*(7*sep); const px=isoProject(base.x+Math.sin(i*0.08)*tw*9,-y,base.z);
      ctx.save(); ctx.translate(px.x+wiggle,px.y);
      const layerAlpha=(0.12+i*0.018)*lum; const flash=isTrigger?(1+Math.sin(Date.now()*0.03)*0.6):1;
      ctx.globalAlpha=layerAlpha*flash; ctx.fillStyle=colorize(color,0.96);
      ctx.shadowColor=isTrigger?'#fff':'#7fdcff'; ctx.shadowBlur=(9+i*0.4)*halo*(isTrigger?2.0:1);
      roundedRect(-14,-7,28,14,7); ctx.fill();
      if(sel&&i===layers-1){ ctx.globalAlpha=.95; ctx.strokeStyle='#fff'; ctx.lineWidth=2; roundedRect(-14,-7,28,14,7); ctx.stroke(); }
      ctx.restore();
    }
  }

  /* ============== INTERACTION TO GRID ============== */
  function pickCell(mx,my){ let best=null,bestD=1e9; for(let r=0;r<state.rows;r++){ for(let c=0;c<state.cols;c++){ const P=isoProject(cellCenter(c,r).x,0,cellCenter(c,r).z); const dx=mx-P.x,dy=my-P.y; const d=dx*dx+dy*dy-state.aimInflate*state.aimInflate; if(d<bestD){ bestD=d; best={r,c}; } } } return best; }
  canvas.addEventListener('pointerdown',e=>{ const R=canvas.getBoundingClientRect(); const mx=e.clientX-R.left,my=e.clientY-R.top; const hit=pickCell(mx,my); if(hit){ state.selection=hit; focusOnSelection(); hapticStrong(); click(); e.preventDefault(); }});
  function focusOnSelection(){ if(!state.selection){ state.focus.targetScale=1; return; } const sel=state.selection; const base=cellCenter(sel.c,sel.r); const aX=W*0.5,aY=H*0.58; const p=isoProject(base.x,0,base.z); state.focus.tx+=(p.x-aX); state.focus.tz+=(p.y-aY); state.focus.targetScale=Math.min(2.6,1.0+(16/state.cols)*0.28); }

  /* ============== TRANSPORT/LOOP ============== */
  function update(dt){ if(state.playing){ const bps=state.bpm/60; state.t+=dt*bps*4; // 16th notes
    const globalStep=Math.floor(state.t)%16; if(globalStep!==state.playhead){ state.playhead=globalStep; triggerBeat(globalStep); hapticBeat(); } }
    state.focus.sx+=(state.focus.tx-state.focus.sx)*state.focus.lerp; state.focus.sz+=(state.focus.tz-state.focus.sz)*state.focus.lerp; state.focus.scale+=(state.focus.targetScale-state.focus.scale)*state.focus.lerp; }
  function render(){ ctx.clearRect(0,0,W,H); const side=Math.min(W,H); const cx=W*0.5,cy=H*0.48; const base=side/Math.max(640,side)*state.focus.scale; ctx.save(); ctx.translate(cx,cy); ctx.scale(base,base); ctx.translate(-cx,-cy);
    if(state.cols>1){ const phx=cellCenter(Math.floor(state.playhead/ (16/state.cols)),0).x; const p0=isoProject(phx,-180,cellCenter(0,0).z-180); const p1=isoProject(phx,260,cellCenter(state.cols-1,state.rows-1).z+180); ctx.save(); ctx.globalAlpha=0.18; ctx.strokeStyle='#cfe8ff'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke(); ctx.restore(); }
    const order=[]; for(let r=0;r<state.rows;r++){ for(let c=0;c<state.cols;c++){ order.push({r,c}); } } order.sort((a,b)=>(a.r+a.c)-(b.r+b.c)); order.forEach(({r,c})=>drawStack(c,r,grid[r][c]));
    if(state.selection){ const sel=state.selection; const baseC=cellCenter(sel.c,sel.r); const p=isoProject(baseC.x,0,baseC.z); ctx.save(); ctx.globalAlpha=.55; ctx.strokeStyle='#fff'; ctx.lineWidth=2.6; ctx.beginPath(); ctx.arc(p.x,p.y,36*state.focus.scale,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
    ctx.restore(); }
  let last=performance.now(); function loop(now){ const dt=Math.min(0.05,(now-last)/1000); last=now; update(dt); render(); requestAnimationFrame(loop); } requestAnimationFrame(loop);

  /* ====================== TESTS ====================== */
  (function runTests(){
    const results=[];
    try{ const tmp=document.createElement('div'); tmp.className='layers'; buildLayers(tmp,12,6); results.push({name:'buildLayers >=12', pass: tmp.children.length>=12}); results.push({name:'top bar opaque', pass: tmp.children[tmp.children.length-1].style.opacity==='1'}); }catch(e){ results.push({name:'buildLayers threw', pass:false, err:e}); }
    try{ const chip=makeChip('T',12,6); results.push({name:'makeChip layers ok', pass: !!chip.querySelector('.layers')}); results.push({name:'makeChip marker ok', pass: !!chip.querySelector('.zoneMarker')}); }catch(e){ results.push({name:'makeChip threw', pass:false, err:e}); }
    try{ ensureAudio(); results.push({name:'ensureAudio masterGain', pass: !!masterGain && typeof masterGain.gain==='object'}); }catch(e){ results.push({name:'ensureAudio threw', pass:false, err:e}); }
    try{ const prevAC=audioCtx, prevM=masterGain; audioCtx=null; masterGain=null; volumeGlide(220,0.1,0.5,0); audioCtx=prevAC; masterGain=prevM; results.push({name:'volumeGlide safe no audio', pass:true}); }catch(e){ results.push({name:'volumeGlide safe no audio', pass:false, err:e}); }
    console.log('[VOL-MEDIA tests]', results, `${results.filter(r=>r.pass).length}/${results.length} passed`);
  })();
})();
</script>
</body>
</html>
