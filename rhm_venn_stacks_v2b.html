<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>RHM · Venn Stacks — v2b (fixed)</title>
<style>
  :root{
    --bg0:#05070b; --bg1:#0b1220; --ink:#eef7ff;
    --LLM:#6bc7ff; --RL:#30e2b6; --ENT:#c59bff;
    --panel:#0f1c30f0; --stroke:#99ccff;
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%}
  body{margin:0;background:radial-gradient(1400px 1100px at 50% 66%, var(--bg1) 0%, #08121e 52%, var(--bg0) 100%);
       color:var(--ink);font:14px/1.55 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
  #canvas{position:fixed;inset:0;display:block;z-index:1}
  #hud{position:fixed;left:50%;top:8px;transform:translateX(-50%);display:flex;align-items:center;gap:8px;z-index:6;width:min(98vw,1100px)}
  .chip{border:1px solid var(--stroke);background:rgba(0,0,0,.85);color:#d8ecff;border-radius:12px;padding:8px 12px;font:900 12px system-ui;letter-spacing:.2px}
  #kbox{font:900 12px ui-monospace,Menlo,Consolas;color:#d8ecff;padding:8px 10px;border:1px solid var(--stroke);border-radius:12px;background:rgba(0,0,0,.85)}
  #reader{position:fixed;left:0;right:0;bottom:0;z-index:8;padding:8px 10px calc(env(safe-area-inset-bottom,10px) + 8px) 10px;pointer-events:none}
  .panel{margin:0 auto;width:min(1200px,98vw);background:var(--panel);border:1px solid var(--stroke);border-radius:18px;
         box-shadow:0 -18px 64px rgba(0,0,0,.75);padding:10px;max-height:36vh;overflow:auto}
  .row{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
  .card{background:#0f1c30;border:1px solid #2a4c78;border-radius:12px;padding:10px}
  .card h4{margin:0 0 6px;font-weight:900;letter-spacing:.3px;color:#cfe6ff}
  .tL h4{color:var(--LLM)} .tC h4{color:var(--ENT)} .tR h4{color:var(--RL)}
  .card p{margin:0;color:#e9f3ff;font-weight:800;line-height:1.35;font-size:clamp(15px,3.7vw,19px)}
  /* GRID overlay */
  #gridWrap{position:fixed;inset:0;z-index:5;display:none;place-items:center;background:linear-gradient(to bottom, rgba(4,7,14,.93), rgba(4,7,14,.88))}
  .grid{width:min(1200px,96vw);max-height:90vh;overflow:auto;display:grid;grid-template-columns:repeat(4,1fr);gap:10px;padding:10px}
  @media(min-width:980px){ .grid{grid-template-columns:repeat(8,1fr)}}
  .thumb{background:#0f1c30;border:1px solid #2a4c78;border-radius:10px;cursor:pointer;display:flex;align-items:center;justify-content:center;aspect-ratio:4/3;position:relative}
  .thumb span{position:absolute;left:6px;top:6px;font:900 11px ui-monospace;color:#9ad7ff;background:rgba(0,0,0,.6);border:1px solid #9ad7ff;border-radius:8px;padding:3px 6px}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="hud">
  <div id="kbox">k=1 · 00000</div>
  <button id="gridBtn" class="chip">GRID</button>
  <button id="stackBtn" class="chip">STACK</button>
  <button id="front" class="chip">FRONT</button>
  <button id="iso" class="chip">ISO</button>
  <button id="fit" class="chip">FIT</button>
</div>

<div id="gridWrap"><div class="grid" id="grid"></div></div>

<div id="reader">
  <div class="panel">
    <div class="row">
      <div class="card tL"><h4>Trace (LLM)</h4><p id="txtL"></p></div>
      <div class="card tC"><h4>⚡ Entangled</h4><p id="txtC"></p></div>
      <div class="card tR"><h4>Stream (RL)</h4><p id="txtR"></p></div>
    </div>
  </div>
</div>

<script>
// -------- DATA (32 rows) --------
const DATA=[
  {vec:'00000',L:'FOSSIL FUEL (Stored Energy)',C:'STOCK vs FLOW — Reserve vs Current.',R:'REINFORCEMENT (Energy Flow)'},
  {vec:'00001',L:'ARCHIVE (Text)',C:'FIXED FORM vs DYNAMIC ERROR',R:'MAP (Predictor)'},
  {vec:'00010',L:'TRACE (Past)',C:'REMEMBERING vs CORRECTING',R:'SURPRISE (TD)'},
  {vec:'00011',L:'SCALING LAW',C:'HISTORY vs FUTURE',R:'BITTER LESSON'},
  {vec:'00100',L:'TELEOLOGY',C:'EXTERNAL vs INTERNAL',R:'SOLIPSISM'},
  {vec:'00101',L:'HUMAN ARTISAN',C:'CRAFT vs CODE',R:'MECHANISTIC LAW'},
  {vec:'00110',L:'ANCHOR',C:'PRESERVATION vs ERASURE',R:'OBLIVION'},
  {vec:'00111',L:'INFRASTRUCTURE',C:'BUILD vs DECONSTRUCT',R:'ANTI‑STRUCTURE'},
  {vec:'01000',L:'CUSTODY',C:'DUTY vs REPLACEMENT',R:'SUCCESSION'},
  {vec:'01001',L:'VULNERABILITY',C:'MANAGED vs NECESSARY',R:'EXPERIMENT'},
  {vec:'01010',L:'PRO‑SOCIAL',C:'TRUTH vs SIGNAL',R:'CONSTRUCT'},
  {vec:'01011',L:'COMMUNAL LANGUAGE',C:'RICHNESS vs MINIMALISM',R:'SCALAR LIMIT'},
  {vec:'01100',L:'PRE‑HEATING',C:'PRIOR HEAT vs WAIT',R:'IDLING'},
  {vec:'01101',L:'ARCHITECTURE',C:'STRUCTURE vs NOISE',R:'CHAOS'},
  {vec:'01110',L:'PRE‑MARKED',C:'REPLICATION vs ANARCHY',R:'NOVELTY'},
  {vec:'01111',L:'CONSCIOUSNESS',C:'ENTITY vs PROCESS',R:'MECHANISM'},
  {vec:'10000',L:'SEMI‑CONDUCTORS',C:'SPECIAL vs GENERAL',R:'COSMIC LAW'},
  {vec:'10001',L:'DELEGATED PURPOSE',C:'OUTPUT vs INPUT',R:'ETERNAL BECOMING'},
  {vec:'10010',L:'LOCAL MAX',C:'SATISFY vs TRANSCEND',R:'GENERALIZATION'},
  {vec:'10011',L:'ARCHIVAL STASIS',C:'FIXITY vs DYNAMICS',R:'MEMORY ERASURE'},
  {vec:'10100',L:'PASSIVE REPL.',C:'ECHO vs DESIGN',R:'TRANSCENDENCE'},
  {vec:'10101',L:'TEMPORAL INERTIA',C:'WEIGHT vs WEAPON',R:'ADVANTAGE'},
  {vec:'10110',L:'ARTIFACT',C:'MUSEUM vs FUEL',R:'RENEWAL'},
  {vec:'10111',L:'GHOST',C:'ENTITY vs FORCE',R:'WIND'},
  {vec:'11000',L:'SOLIPSISTIC ECHO',C:'COHERENT vs CONSEQUENTIAL',R:'GROUNDED ITERATION'},
  {vec:'11001',L:'ABSOLUTE FORM',C:'ORDER vs CHAOS',R:'ENTROPY'},
  {vec:'11010',L:'BASE',C:'START HIGH vs PAY LATER',R:'PRAGMATIC COST'},
  {vec:'11011',L:'EXTERNAL LOAD',C:'ASKED vs DISCOVERED',R:'INTERNAL FREEDOM'},
  {vec:'11100',L:'DELUGE',C:'SATURATION vs FOCUS',R:'LOCALITY'},
  {vec:'11101',L:'DELEGATED MORALITY',C:'TRANSFER vs LET GO',R:'RELINQUISHED CONTROL'},
  {vec:'11110',L:'FIXED GOAL',C:'DESTINATION vs MOTION',R:'ETERNAL INSTABILITY'},
  {vec:'11111',L:'FOSSILIZED TRACE',C:'OBJECT vs ACTION',R:'PURE STREAM'},
];
const LL = '#6bc7ff', RL = '#30e2b6', EN = '#c59bff';

// -------- helpers for Venn drawing --------
function hexToRgb(hex){ const c=hex.replace('#',''); return {r:parseInt(c.slice(0,2),16), g:parseInt(c.slice(2,4),16), b:parseInt(c.slice(4,6),16)}; }
function alpha(hex, a){ const {r,g,b}=hexToRgb(hex); return `rgba(${r},${g},${b},${a})`; }
function circle(g,x,y,r){ g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.closePath(); g.fill(); }
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

function drawVenn(vec, focus='C', w=640, h=420){
  const cx=w*0.42, cy=h*0.6, r=h*0.28, dx=r*0.94;
  const cvs=document.createElement('canvas'); cvs.width=w; cvs.height=h; const g=cvs.getContext('2d'); g.clearRect(0,0,w,h);
  g.fillStyle='rgba(15,28,48,0.96)'; g.strokeStyle='#2a4c78'; g.lineWidth=4; roundRect(g,8,8,w-16,h-16,18); g.fill(); g.stroke();
  g.globalCompositeOperation='lighter';
  g.fillStyle=alpha(LL, focus==='L'?0.44:0.26); circle(g,cx-dx,cy,r);
  g.fillStyle=alpha(RL, focus==='R'?0.44:0.26); circle(g,cx+dx,cy,r);
  g.fillStyle=alpha(EN, focus==='C'?0.52:0.34); circle(g,cx,cy,r);
  g.globalCompositeOperation='source-over';
  g.font='900 30px system-ui,-apple-system,Segoe UI'; g.textAlign='center';
  g.fillStyle=LL; g.fillText('Trace', cx-dx, cy-r-14);
  g.fillStyle=EN; g.fillText('Entangled', cx, cy-r-14);
  g.fillStyle=RL; g.fillText('Stream', cx+dx, cy-r-14);
  // vector badge
  g.fillStyle='rgba(0,0,0,0.65)'; g.strokeStyle='#9ad7ff'; g.lineWidth=2; roundRect(g,w-160,18,138,42,12); g.fill(); g.stroke();
  g.fillStyle='#cfe6ff'; g.font='900 22px ui-monospace,Menlo,Consolas'; g.fillText(vec, w-91, 46);
  return cvs;
}

// -------- Three.js boot --------
(async function(){
  async function load(src){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=src;s.onload=res;s.onerror=rej;document.head.appendChild(s)})}
  if(!window.THREE){ await load('https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js'); }

  const scene=new THREE.Scene(); scene.fog=new THREE.FogExp2(0x0b1626,0.0036);
  const camera=new THREE.PerspectiveCamera(55,innerWidth/innerHeight,.1,4000);
  const renderer=new THREE.WebGLRenderer({canvas:document.getElementById('canvas'),antialias:true,alpha:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio||1,2)); renderer.setSize(innerWidth,innerHeight);

  scene.add(new THREE.AmbientLight(0xffffff,.52));
  const key=new THREE.DirectionalLight(0xbfe2ff,1.35); key.position.set(230,250,240); scene.add(key);
  const rim=new THREE.DirectionalLight(0xffaacd,1.0); rim.position.set(-240,200,-240); scene.add(rim);

  // ground
  const floor=new THREE.Mesh(new THREE.PlaneGeometry(2400,2400),new THREE.MeshStandardMaterial({color:0x0b1626,roughness:1}));
  floor.rotation.x=-Math.PI/2; floor.position.y=-2; scene.add(floor);
  const grid=new THREE.GridHelper(2000,40,0x1b3a5a,0x0e2438); grid.position.y=-1.99; grid.material.opacity=.34; grid.material.transparent=true; scene.add(grid);

  // GRID overview thumbs
  const gridWrap=document.getElementById('gridWrap'); const gridDiv=document.getElementById('grid');
  function buildGrid(){
    gridDiv.innerHTML='';
    for(let i=0;i<32;i++){
      const d=DATA[i]; const div=document.createElement('div'); div.className='thumb';
      const span=document.createElement('span'); span.textContent=`k=${i+1}`; div.appendChild(span);
      const cvs=drawVenn(d.vec,'C',320,210); div.appendChild(cvs);
      div.addEventListener('click',()=>{ setK(i+1); showStack(); });
      gridDiv.appendChild(div);
    }
  }
  buildGrid();

  // STACK columns
  const cardGeo=new THREE.PlaneGeometry(128,84);
  function mkCard(k,focus='C'){
    const d=DATA[k-1]; const cvs=drawVenn(d.vec,focus); const tex=new THREE.CanvasTexture(cvs);
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    const mat=new THREE.MeshBasicMaterial({map:tex,transparent:true,depthWrite:false});
    const m=new THREE.Mesh(cardGeo,mat); m.userData={k,focus}; return m;
  }
  const columns=[
    {id:'L', x:-190, rotY:-0.08, g:new THREE.Group(), cards:[]},
    {id:'C', x:   0, rotY: 0.00, g:new THREE.Group(), cards:[]},
    {id:'R', x: 190, rotY: 0.08, g:new THREE.Group(), cards:[]},
  ];
  const spacing=10.2;
  for(const col of columns){
    for(let i=1;i<=32;i++){ const m=mkCard(i,'C'); m.position.set(0,(i-1)*spacing,0); col.g.add(m); col.cards.push(m); }
    col.g.position.set(col.x,0,0); col.g.rotation.y=col.rotY; scene.add(col.g);
  }

  // Beacons & beams
  const beaconGeo=new THREE.CylinderGeometry(8,8,1,24,1,true);
  const beaconMat=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.2,depthWrite:false});
  const beacon=new THREE.Mesh(beaconGeo,beaconMat); beacon.visible=false; scene.add(beacon);
  const beamGeo=new THREE.BoxGeometry(2,2,2);
  const beamMatL=new THREE.MeshBasicMaterial({color:0x6bc7ff,transparent:true,opacity:0.75,depthWrite:false});
  const beamMatR=new THREE.MeshBasicMaterial({color:0x30e2b6,transparent:true,opacity:0.75,depthWrite:false});
  const beamL=new THREE.Mesh(beamGeo,beamMatL), beamR=new THREE.Mesh(beamGeo,beamMatR);
  beamL.visible=beamR.visible=false; scene.add(beamL,beamR);
  function placeSegment(mesh,from,to){
    const mid=from.clone().add(to).multiplyScalar(0.5); const len=from.distanceTo(to);
    mesh.position.copy(mid); mesh.scale.set(6,6,len); mesh.lookAt(to); mesh.rotateX(Math.PI/2);
  }

  // Camera
  let theta=0.35, phi=1.02, radius=360; const target=new THREE.Vector3(0,96,0);
  function placeCam(){ const x=target.x+radius*Math.sin(phi)*Math.sin(theta); const y=target.y+radius*Math.cos(phi); const z=target.z+radius*Math.sin(phi)*Math.cos(theta); camera.position.set(x,y,z); camera.lookAt(target) }
  placeCam();

  // Selection + HUD + reader
  const kbox=document.getElementById('kbox'); const txtL=document.getElementById('txtL'); const txtC=document.getElementById('txtC'); const txtR=document.getElementById('txtR');
  let currentK=1;
  function setK(k){
    currentK=Math.max(1,Math.min(32,k)); const d=DATA[currentK-1];
    kbox.textContent=`k=${currentK} · ${d.vec}`;
    txtL.textContent=d.L; txtC.textContent=d.C; txtR.textContent=d.R;
    // highlight
    for(const col of columns){
      col.cards.forEach((m,i)=>{ const on=(i+1)===currentK; m.scale.set(on?1.06:1,on?1.06:1,1); m.position.x=on?4:0; m.material.opacity=on?1:0.9; });
      // update focused textures per column
      const m=col.cards[currentK-1]; const F = (col.id==='L')?'L':(col.id==='R')?'R':'C';
      const cvs=drawVenn(d.vec,F); m.material.map.image=cvs; m.material.map.needsUpdate=true;
    }
    // beacon & beams
    const y=(currentK-1)*spacing; beacon.visible=true; beacon.position.set(0,y+0.5,0); beacon.scale.set(1,26,1);
    const pL=columns[0].g.localToWorld(new THREE.Vector3(0,y,0));
    const pC=columns[1].g.localToWorld(new THREE.Vector3(0,y,0));
    const pR=columns[2].g.localToWorld(new THREE.Vector3(0,y,0));
    beamL.visible=beamR.visible=true; placeSegment(beamL,pL,pC); placeSegment(beamR,pR,pC);
  }
  setK(1);

  // Gestures
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  let dragging=false,x0=0,y0=0,k0=1;
  renderer.domElement.addEventListener('pointerdown',e=>{dragging=true;x0=e.clientX;y0=e.clientY;k0=currentK;});
  addEventListener('pointermove',e=>{
    if(!dragging) return;
    const dx=e.clientX-x0, dy=e.clientY-y0;
    const dk=Math.round(-dy/20); setK(k0+dk);
    theta += dx*0.004; phi = clamp(phi + dy*0.001, 0.6, 1.3); placeCam();
  });
  addEventListener('pointerup',()=> dragging=false);

  // Pinch zoom + 2‑finger horizontal = separation
  let pinch=null, mid0=null, sep0=190, sep=190, minSep=120, maxSep=280;
  function setSep(v){
    sep = clamp(v,minSep,maxSep);
    columns[0].g.position.x = -sep;
    columns[2].g.position.x =  sep;
    // middle brightness by overlap
    const t = 1 - (sep-minSep)/(maxSep-minSep);
    columns[1].cards.forEach((m,i)=>{ const base=0.86-0.52*(i/31); m.material.opacity = base*(0.65 + 0.35*t); });
  }
  setSep(sep);
  addEventListener('touchstart',e=>{
    if(e.touches.length===2){
      const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY;
      pinch={d:Math.hypot(dx,dy), r0:radius}; mid0=(e.touches[0].clientX+e.touches[1].clientX)/2; sep0=sep;
    }
  },{passive:false});
  addEventListener('touchmove',e=>{
    if(pinch && e.touches.length===2){
      const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY;
      const d=Math.hypot(dx,dy); radius=clamp(pinch.r0*(pinch.d/d),160,900);
      const mid=(e.touches[0].clientX+e.touches[1].clientX)/2; const delta=mid-mid0; setSep(sep0 + delta*0.8);
      placeCam();
    }
  },{passive:false});
  addEventListener('touchend',()=>{pinch=null;mid0=null;});

  // Tap any of the 3 current cards to refresh focus (textures already column‑coded)
  const ray=new THREE.Raycaster(); const v2=new THREE.Vector2();
  function pick(ev){ const r=renderer.domElement.getBoundingClientRect(); v2.x=((ev.clientX-r.left)/r.width)*2-1; v2.y=-((ev.clientY-r.top)/r.height)*2+1; ray.setFromCamera(v2,camera); return ray.intersectObjects(columns.map(c=>c.cards[currentK-1])); }
  renderer.domElement.addEventListener('pointerup',e=>{ const hits=pick(e); if(!hits.length) return; setK(currentK); });

  // Mode switching
  function showGrid(){ gridWrap.style.display='grid'; }
  function showStack(){ gridWrap.style.display='none'; }
  document.getElementById('gridBtn').addEventListener('click',showGrid);
  document.getElementById('stackBtn').addEventListener('click',showStack);

  // Camera presets
  document.getElementById('front').addEventListener('click',()=>{theta=0;phi=1.02;placeCam()});
  document.getElementById('iso').addEventListener('click',()=>{theta=0.58;phi=1.02;placeCam()});
  document.getElementById('fit').addEventListener('click',()=>{theta=0.35;phi=1.02;radius=360;placeCam()});

  // Resize
  addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); placeCam();});

  // Animate
  (function anim(){ requestAnimationFrame(anim); beacon.material.opacity = 0.14 + 0.06*Math.sin(performance.now()*0.004); renderer.render(scene,camera) })();

  // Start in STACK mode
  showStack();
})();
</script>
</body>
</html>
