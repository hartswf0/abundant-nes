<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>VOL‑Stacks — Isometric Sequencer (Single‑File)</title>
<style>
  /* ─────────────────────────────
     CORE SKIN — black void, neon glow, no chrome
     ───────────────────────────── */
  :root{
    --bg:#050507; --ink:#e8e8e8; --muted:#7a7a7a; --hud:#101218;
    --glow:#ffffff; --accent:#89f5ff; --danger:#ff4d6d; --ok:#80ffcc;
    --shadow:0 8px 28px rgba(0,0,0,.55), 0 2px 8px rgba(0,0,0,.3);
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color:transparent; touch-action:none}
  html,body{height:100%}
  body{margin:0; background:var(--bg); color:var(--ink); font:14px/1.2 system-ui,Segoe UI,Inter,Roboto,Helvetica,Arial,sans-serif; overflow:hidden}
  canvas#scene{position:fixed; inset:0; display:block}
  /* HUD is screen-locked */
  #hud{position:fixed; inset:0; pointer-events:none}
  .corner{position:absolute; display:flex; gap:10px; align-items:end; pointer-events:auto}
  .corner.tl{top:10px; left:10px}
  .corner.tr{top:10px; right:10px}
  .corner.bl{bottom:10px; left:10px}
  .corner.br{bottom:10px; right:10px}

  /* Stack buttons in HUD — text-minimal, stack-shaped controls */
  .stackBtn{--w:44px; width:var(--w); height:88px; background:linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.0)); border:1px solid rgba(255,255,255,.18); border-radius:12px; box-shadow:var(--shadow); position:relative; overflow:hidden; display:grid; place-items:end center; padding:6px}
  .stackBtn .layers{position:absolute; inset:8px 6px; display:flex; flex-direction:column; justify-content:flex-end; gap:3px}
  .stackBtn .lay{height:6px; border-radius:3px; background:rgba(255,255,255,.15); filter:drop-shadow(0 0 6px rgba(255,255,255,.15))}
  .stackBtn[data-active="1"]{outline:2px solid var(--accent);}
  .stackBtn .glyph{position:absolute; top:6px; left:6px; font-size:10px; letter-spacing:.08em; color:var(--muted)}
  .stackBtn .legend{position:absolute; bottom:4px; width:100%; text-align:center; font-size:10px; color:#bdbdbd; opacity:.8}
  .stackBtn.accent{border-color:rgba(137,245,255,.55); box-shadow:0 0 0 1px rgba(137,245,255,.35), inset 0 0 24px rgba(137,245,255,.08), var(--shadow)}

  /* Slim bar for transport & tempo */
  .bar{background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.15); border-radius:12px; padding:6px 10px; display:flex; gap:10px; align-items:center; box-shadow:var(--shadow)}
  .iconBtn{width:38px; height:38px; border-radius:10px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06); display:grid; place-items:center; cursor:pointer; user-select:none}
  .iconBtn[data-on="1"]{outline:2px solid var(--ok)}
  .label{font-size:11px; color:#bdbdbd}
  .dial{width:120px; height:10px; border-radius:99px; background:rgba(255,255,255,.08); position:relative}
  .dial .fill{position:absolute; left:0; top:0; bottom:0; width:30%; border-radius:99px; background:linear-gradient(90deg, var(--accent), #fff)}

  /* Selection color pipe — HUD adopts selected color */
  #colorPipe{position:fixed; left:0; right:0; bottom:0; height:3px; background:linear-gradient(90deg, #666, #aaa); opacity:.6; pointer-events:none}

  /* Tiny on-canvas hints (optional) */
  #hint{position:fixed; left:50%; transform:translateX(-50%); bottom:6px; font-size:11px; color:#9aa; letter-spacing:.04em; opacity:.7; pointer-events:none}

  /* Mobile thumb-zone consideration */
  @media (max-width:680px){
    .stackBtn{--w:40px; height:76px}
    .bar{gap:6px}
    .dial{width:96px}
  }
</style>
</head>
<body>
  <canvas id="scene"></canvas>
  <div id="hud" aria-hidden="false">
    <!-- TOP-LEFT: View presets -->
    <div class="corner tl">
      <div class="bar" id="viewBar">
        <div class="iconBtn" data-view="iso" title="ISO">◧</div>
        <div class="iconBtn" data-view="top" title="TOP">▭</div>
        <div class="iconBtn" data-view="low" title="LOW">◩</div>
        <div class="iconBtn" data-view="side" title="SIDE">▮</div>
      </div>
    </div>

    <!-- TOP-RIGHT: Grid density + mode -->
    <div class="corner tr" style="gap:12px">
      <div class="stackBtn accent" id="gridBtn" title="Grid Density">
        <div class="glyph">GRID</div>
        <div class="layers" id="gridLayers"></div>
        <div class="legend" id="gridLegend">16×16</div>
      </div>
      <div class="stackBtn" id="modeBtn" title="Dock Mode">
        <div class="glyph">MODE</div>
        <div class="layers" id="modeLayers"></div>
        <div class="legend" id="modeLegend">GRID</div>
      </div>
    </div>

    <!-- BOTTOM-LEFT: Transport + Tempo -->
    <div class="corner bl">
      <div class="bar">
        <div class="iconBtn" id="playBtn" title="Play/Pause">▶</div>
        <div class="label">Tempo</div>
        <div class="dial" id="tempoDial"><div class="fill"></div></div>
        <div class="label" id="bpmLbl">120 BPM</div>
      </div>
    </div>

    <!-- BOTTOM-RIGHT: Param stacks (contextual) -->
    <div class="corner br" id="dockParams" style="gap:12px"></div>
  </div>
  <div id="colorPipe"></div>
  <div id="hint">tap = select/toggle • drag across grid = scrub playhead • view buttons = fixed angles</div>

<script>
(()=>{
  // ================================================
  // FIXED-VIEW, SQUARE-GRID, HAPTIC SCRUB SEQUENCER
  // + Reliable selection, focus zoom-to-selection, editor mode
  // ================================================
  const canvas = document.getElementById('scene');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, devicePixelRatio||1);
  let W=0,H=0; const resize=()=>{W=innerWidth;H=innerHeight;canvas.width=W*DPR;canvas.height=H*DPR;canvas.style.width=W+'px';canvas.style.height=H+'px';ctx.setTransform(DPR,0,0,DPR,0,0)}; addEventListener('resize',resize,{passive:true}); resize();

  // HAPTICS helper
  const buzz=(p)=>{ try{ if(navigator.vibrate) navigator.vibrate(p||8);}catch{} };

  // Colors
  const ROW_COLORS=['#ff7a7a','#ffd27a','#a6ff7a','#7affdc','#7ab5ff','#c47aff','#ff7ad1','#7aff9d'];

  // State
  const state={
    gridOpts:[16,8,4,2,1],gridIdx:0,cols:16,rows:8,baseCell:28,stackLayers:10,
    cam:{phi:Math.PI*0.2,theta:Math.PI*0.22},
    playing:false,t:0,bpm:120,playhead:0,selection:null,mode:'GRID',
    scrubbing:false,lastScrubCol:-1,
    // Focus (auto-pan/zoom when a stack is selected)
    focus:{tx:0,tz:0, sx:0, sz:0, scale:1, targetScale:1, lerp:0.18},
    editor:false
  };

  // HUD elements
  const gridBtn=document.getElementById('gridBtn');
  const gridLayersEl=document.getElementById('gridLayers');
  const gridLegend=document.getElementById('gridLegend');
  const modeBtn=document.getElementById('modeBtn');
  const modeLayersEl=document.getElementById('modeLayers');
  const modeLegend=document.getElementById('modeLegend');
  const tempoDial=document.getElementById('tempoDial');
  const bpmLbl=document.getElementById('bpmLbl');
  const playBtn=document.getElementById('playBtn');
  const dockParams=document.getElementById('dockParams');
  const colorPipe=document.getElementById('colorPipe');

  // Build HUD layer mini-stacks
  const buildLayers=(el,n=8,lit=4)=>{ el.innerHTML=''; for(let i=0;i<n;i++){ const d=document.createElement('div'); d.className='lay'; if(i>=n-lit) d.style.background='linear-gradient(90deg, var(--accent), #fff)'; el.appendChild(d);} };
  buildLayers(gridLayersEl,6,6); buildLayers(modeLayersEl,6,3);

  // Params
  const PARAMS=[{key:'vel',label:'VEL'},{key:'prob',label:'PRB'},{key:'len',label:'LEN'},{key:'pitch',label:'PIT'},{key:'pan',label:'PAN'},{key:'send',label:'SND'}];

  // Grid data
  function makeGrid(cols){ const g=[]; for(let r=0;r<state.rows;r++){ const row=[]; for(let c=0;c<cols;c++){ row.push({on:Math.random()<0.18, vel:0.7, prob:0.9, len:1, pitch:0, pan:(r-3.5)/3.5, send:0.2}); } g.push(row);} return g; }
  let grid=makeGrid(state.cols);

  // Grid density control
  function setGridByIndex(idx){ state.gridIdx=(idx+state.gridOpts.length)%state.gridOpts.length; const size=state.gridOpts[state.gridIdx]; state.cols=size; grid=makeGrid(state.cols); gridLegend.textContent=(size===1?'1×1':`${size}×${size}`); const lit=1+(5-state.gridIdx); buildLayers(gridLayersEl,6,Math.max(2,Math.min(6,lit))); buzz(15); // reset focus when density changes
    clearFocus(); }

  // Mode toggle
  function toggleMode(){ state.mode=(state.mode==='GRID'?'SOUND':'GRID'); modeLegend.textContent=state.mode; buildLayers(modeLayersEl,6,state.mode==='GRID'?3:5); refreshDockParams(); buzz(10); }

  // Dock params rebuild
  function refreshDockParams(){
    dockParams.innerHTML='';
    const sel=state.selection; const isSel=!!sel; const activeColor=isSel? ROW_COLORS[sel.r%ROW_COLORS.length] : '#e5e5e5';
    colorPipe.style.background=`linear-gradient(90deg, ${activeColor}, #fff)`;
    PARAMS.forEach(p=>{
      const btn=document.createElement('div'); btn.className='stackBtn'; btn.innerHTML=`<div class="glyph">${p.label}</div><div class="layers"></div><div class="legend"></div>`; const layers=btn.querySelector('.layers');
      let v=0.5; if(isSel){ v=grid[sel.r][sel.c][p.key]; }
      const lit=Math.round(1+v*5); buildLayers(layers,6,lit);
      btn.style.borderColor=isSel? activeColor : 'rgba(255,255,255,.18)'; btn.style.boxShadow=isSel?`0 0 0 1px ${activeColor}55, inset 0 0 24px ${activeColor}22, var(--shadow)`:'var(--shadow)';
      let grabbing=false, sy=0, sv=v;
      btn.addEventListener('pointerdown',e=>{ grabbing=true; sy=e.clientY; sv=v; btn.setPointerCapture(e.pointerId); buzz(12); e.preventDefault(); });
      btn.addEventListener('pointermove',e=>{ if(!grabbing) return; const dy=sy-e.clientY; v=Math.max(0,Math.min(1, sv + dy/160)); const lit2=Math.round(1+v*5); buildLayers(layers,6,lit2); if(isSel){ const cell=grid[sel.r][sel.c]; if(p.key==='pitch'){ cell[p.key]=Math.round((v*2-1)*12); } else if(p.key==='pan'){ cell[p.key]=(v*2-1); } else { cell[p.key]=v; } } });
      btn.addEventListener('pointerup',()=>{ if(grabbing) buzz(8); grabbing=false; });
      dockParams.appendChild(btn);
    });
  }

  // Square grid layout helpers
  function gridSize(){ return Math.max(state.cols, state.rows); }
  function spacing(){ const G=gridSize(); const fx=G/state.cols, fz=G/state.rows; return {dx:state.baseCell*fx, dz:state.baseCell*fz}; }

  // Iso projection (fixed angles), focus pan injected
  function isoProject(x,y,z){
    const {phi,theta}=state.cam; const cy=Math.cos(theta), sy=Math.sin(theta); const cx=Math.cos(phi), sx=Math.sin(phi);
    let X=x, Y=y, Z=z; let x1= X*cy + Z*sy; let z1= -X*sy + Z*cy; let y2= Y*cx - z1*sx;
    // Apply focus pan
    x1 -= state.focus.sx; y2 -= state.focus.sz;
    return {x: W*0.5 + x1, y: H*0.5 + y2, depth:z1};
  }

  function cellCenter(c,r){ const {dx,dz}=spacing(); const width=(state.cols-1)*dx; const height=(state.rows-1)*dz; return { x:(c*dx - width/2), y:0, z:(r*dz - height/2) }; }

  // Draw a stack (dim others in editor)
  function drawStack(c,r,cell){
    const base=cellCenter(c,r); const color=ROW_COLORS[r%ROW_COLORS.length]; const isSelected=state.selection && state.selection.r===r && state.selection.c===c;
    const dim = state.editor && !isSelected ? 0.35 : 1.0;
    const baseP=isoProject(base.x, base.y, base.z);
    ctx.save(); ctx.translate(baseP.x, baseP.y); ctx.globalAlpha=0.12*dim; ctx.fillStyle=color; roundedRect(-14,-8,28,16,6); ctx.fill(); ctx.restore();
    const L=state.stackLayers; const lit=cell.on? Math.max(1, Math.round(2 + cell.vel*(L-2))):0;
    for(let i=0;i<L;i++){ const y=i*10; const p=isoProject(base.x, base.y - y, base.z); const w=22,h=10,rads=5; ctx.save(); ctx.translate(p.x,p.y); const active=(i<lit); ctx.globalAlpha=(active?(0.28+i*0.02):0.08) * dim; ctx.fillStyle=color; roundedRect(-w/2,-h/2,w,h,rads); ctx.fill(); if(active){ ctx.shadowColor=color; ctx.shadowBlur=12*dim; } if(isSelected && i===lit-1){ ctx.globalAlpha=0.95; ctx.strokeStyle='#fff'; ctx.lineWidth=1.6; roundedRect(-w/2,-h/2,w,h,rads); ctx.stroke(); } ctx.restore(); }
  }

  function roundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

  // === Reliable selection & haptic scrub ===
  function pickCell(mx,my){
    // Always pick the nearest cell (no miss). Threshold scales with focus.
    let best=null, bestD=1e9;
    for(let r=0;r<state.rows;r++){
      for(let c=0;c<state.cols;c++){
        const base=cellCenter(c,r); const p=isoProject(base.x,0,base.z);
        const d=(mx-p.x)*(mx-p.x)+(my-p.y)*(my-p.y);
        if(d<bestD){ bestD=d; best={r,c, d2:d}; }
      }
    }
    return best; // never null
  }

  canvas.addEventListener('pointerdown',e=>{ const rect=canvas.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top; const hit=pickCell(mx,my); if(hit){ state.scrubbing=true; canvas.setPointerCapture(e.pointerId); handleSelectOrToggle(hit, true); scrubTo(hit.c, true); e.preventDefault(); }});
  canvas.addEventListener('pointermove',e=>{ if(!state.scrubbing) return; const rect=canvas.getBoundingClientRect(); const mx=e.clientX-rect.left, my=e.clientY-rect.top; const hit=pickCell(mx,my); scrubTo(hit.c); });
  addEventListener('pointerup',()=>{ state.scrubbing=false; state.lastScrubCol=-1; });

  function handleSelectOrToggle(hit, allowToggle){
    if(state.selection && state.selection.r===hit.r && state.selection.c===hit.c && allowToggle){ grid[hit.r][hit.c].on=!grid[hit.r][hit.c].on; buzz(16); }
    else { state.selection={r:hit.r,c:hit.c}; buzz(10); enterEditor(); refreshDockParams(); }
  }

  function scrubTo(col, silent){ if(col===state.lastScrubCol) return; state.playhead=col; state.lastScrubCol=col; if(!silent) buzz(4); for(let r=0;r<state.rows;r++){ const cell=grid[r][state.playhead]; if(cell.on) trig(r,cell); } }

  // === Editor / Focus ===
  function clearFocus(){ state.focus.targetScale=1; }
  function focusOnSelection(){
    if(!state.selection){ clearFocus(); return; }
    const sel=state.selection; const base=cellCenter(sel.c, sel.r);
    // project desired screen anchor (lower third center)
    const anchorX=W*0.5; const anchorY=H*0.62;
    const p=isoProject(base.x, 0, base.z);
    // We adjust focus.sx/sz so that p maps to anchor
    // invert simple translation part: sx += (p.x-anchorX) etc in projected space
    state.focus.tx += (p.x - anchorX); state.focus.tz += (p.y - anchorY);
    // Target scale slightly larger for edit clarity
    state.focus.targetScale = Math.min(1.6, 1.0 + (16/state.cols)*0.18);
  }
  function enterEditor(){ state.editor=true; state.mode='SOUND'; modeLegend.textContent='SOUND'; buildLayers(modeLayersEl,6,5); focusOnSelection(); }
  function exitEditor(){ state.editor=false; clearFocus(); }

  // VIEW presets — fixed
  document.getElementById('viewBar').addEventListener('click',(e)=>{
    const v=e.target.getAttribute('data-view'); if(!v) return; if(v==='iso'){ state.cam.theta=Math.PI*0.22; state.cam.phi=Math.PI*0.2; }
    if(v==='top'){ state.cam.theta=0; state.cam.phi=-Math.PI/2+0.12; }
    if(v==='low'){ state.cam.theta=Math.PI*0.22; state.cam.phi=-0.1; }
    if(v==='side'){ state.cam.theta=Math.PI/2; state.cam.phi=0.15; }
    buzz(6);
  });

  // HUD buttons haptics
  gridBtn.addEventListener('pointerdown',e=>{ e.preventDefault(); setGridByIndex(state.gridIdx+1); });
  modeBtn.addEventListener('pointerdown',e=>{ e.preventDefault(); toggleMode(); });
  let dialGrab=false,dialSX=0,dialStart=state.bpm; tempoDial.addEventListener('pointerdown',e=>{ dialGrab=true; dialSX=e.clientX; dialStart=state.bpm; tempoDial.setPointerCapture(e.pointerId); buzz(8); e.preventDefault(); });
  tempoDial.addEventListener('pointermove',e=>{ if(!dialGrab) return; const dx=e.clientX-dialSX; state.bpm=Math.round(Math.max(50,Math.min(200,dialStart+dx*0.6))); bpmLbl.textContent=`${state.bpm} BPM`; tempoDial.querySelector('.fill').style.width=`${(state.bpm-50)/(200-50)*100}%`; });
  addEventListener('pointerup',()=>{ if(dialGrab) buzz(6); dialGrab=false; },{passive:true});
  playBtn.addEventListener('pointerdown',()=>{ state.playing=!state.playing; playBtn.dataset.on=state.playing?'1':'0'; if(state.playing) ensureAudio(); buzz(12); });

  // Audio
  const AC=(window.AudioContext||window.webkitAudioContext); let audioCtx=null, master=null, reverb=null; function ensureAudio(){ if(audioCtx) return; audioCtx=new AC(); master=audioCtx.createGain(); master.gain.value=0.22; master.connect(audioCtx.destination); reverb=audioCtx.createDelay(0.5); reverb.delayTime.value=0.22; reverb.connect(master); }
  function trig(row,cell){ if(!audioCtx) return; if(Math.random()>cell.prob) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); const p=audioCtx.createStereoPanner(); const base=[48,50,52,53,55,57,59,60][row%8]; const freq=440*Math.pow(2, ((base+cell.pitch)-69)/12); o.frequency.value=freq; g.gain.value=0; const v=cell.vel*(cell.on?1:0); const now=audioCtx.currentTime; const len=0.08+cell.len*0.24; g.gain.setTargetAtTime(v, now, 0.004); g.gain.setTargetAtTime(0.0001, now+len, 0.07); p.pan.value=cell.pan; o.type=row%2?'square':'sine'; o.connect(g); g.connect(p); p.connect(master); p.connect(reverb); o.start(); o.stop(now+len+0.25); }

  // Tick & Render
  function update(dt){
    // playhead advance
    if(state.playing){ const bps=state.bpm/60; state.t+=dt*bps; const nextCol=Math.floor(state.t)%state.cols; if(nextCol!==state.playhead){ state.playhead=nextCol; buzz(2); for(let r=0;r<state.rows;r++){ const cell=grid[r][state.playhead]; if(cell.on) trig(r,cell); } } }
    // focus easing
    state.focus.sx += (state.focus.tx - state.focus.sx) * state.focus.lerp; state.focus.sz += (state.focus.tz - state.focus.sz) * state.focus.lerp; state.focus.scale += (state.focus.targetScale - state.focus.scale)* state.focus.lerp;
  }

  function render(){ ctx.clearRect(0,0,W,H);
    // Keep grid square; base scale by min dimension then focus scale
    const minSide=Math.min(W,H); const cx=W*0.5, cy=H*0.5; const baseScale=minSide/Math.max(640, minSide) * state.focus.scale; ctx.save(); ctx.translate(cx,cy); ctx.scale(baseScale,baseScale); ctx.translate(-cx,-cy);

    const order=[]; for(let r=0;r<state.rows;r++) for(let c=0;c<state.cols;c++) order.push({r,c}); order.sort((a,b)=>(a.r+a.c)-(b.r+b.c));

    // Playhead blade
    const phx=cellCenter(state.playhead,0).x; const p0=isoProject(phx,-120, cellCenter(0,0).z-120); const p1=isoProject(phx,220, cellCenter(state.cols-1,state.rows-1).z+120); ctx.save(); ctx.globalAlpha= state.editor ? 0.06 : 0.12; ctx.strokeStyle='#9ef'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke(); ctx.restore();

    order.forEach(({r,c})=> drawStack(c,r, grid[r][c]));

    ctx.restore();

    // Selection HUD halo
    if(state.selection){ const sel=state.selection; const base=cellCenter(sel.c,sel.r); const p=isoProject(base.x,0,base.z); ctx.save(); ctx.globalAlpha=0.3; ctx.strokeStyle='#fff'; ctx.lineWidth=1.8; ctx.beginPath(); ctx.arc(p.x,p.y,24*state.focus.scale,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
  }

  let last=performance.now(); function loop(now){ const dt=Math.min(0.05,(now-last)/1000); last=now; update(dt); render(); requestAnimationFrame(loop);} requestAnimationFrame(loop);

  // Public interactions to exit editor (tap background outside grid)
  canvas.addEventListener('dblclick', ()=>{ exitEditor(); buzz(12); });

  refreshDockParams();
})();
</script>
</body>
</html>
