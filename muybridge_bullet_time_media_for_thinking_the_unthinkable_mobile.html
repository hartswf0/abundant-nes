<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>Muybridge Bullet Time — Media for Thinking the Unthinkable</title>
<style>
  /* --- RESET & TOKENS --- */
  *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  :root{
    --bg:#0b0d10;          /* deep night */
    --ink:#eaf2ff;         /* high-contrast text */
    --sub:#a7b5c7;         /* secondary text */
    --ui:#38bdf8;          /* electric cyan */
    --ok:#34d399;          /* mint */
    --warn:#f59e0b;        /* amber */
    --bad:#fb7185;         /* rose */
    --edge:#0f172a;        /* frame edge */
    --glass:rgba(8,12,18,.82);
    --glass-2:rgba(8,12,18,.94);
    --ring:0 0 0 2px var(--ui) inset,0 0 .8rem rgba(56,189,248,.45);
    --shadow:0 10px 30px rgba(0,0,0,.45);
    --pass:#10b981; --fail:#ef4444;
  }
  html,body{height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Inter,Roboto,Arial,sans-serif;overflow:hidden}
  #stage{position:fixed;inset:0}

  /* --- HUD --- */
  .hud{position:fixed;z-index:12;display:flex;gap:.5rem;align-items:center}
  #hud-left{top:.75rem;left:.75rem}
  #hud-right{top:.75rem;right:.75rem}
  .pill{background:var(--glass-2);border:1px solid #1e293b;border-radius:12px;padding:.5rem .7rem;backdrop-filter:blur(6px);box-shadow:var(--shadow)}
  .pill b{letter-spacing:.04em}
  .dot{width:.5rem;height:.5rem;border-radius:99px;display:inline-block;margin-right:.4rem;background:var(--ok);box-shadow:0 0 .6rem rgba(52,211,153,.6)}
  #cam-readout{font-weight:800;font-variant-numeric:tabular-nums;letter-spacing:.1em;border:2px solid var(--ui);color:var(--ui);}

  /* --- SEQUENCE BAR --- */
  #timeline{position:fixed;left:50%;transform:translateX(-50%);bottom:6.75rem;width:min(92vw,880px);height:64px;background:var(--glass-2);border:1px solid #1f2937;border-radius:14px;padding:.5rem;z-index:12;display:grid;grid-template-columns:repeat(var(--count),1fr);gap:.35rem}
  .frame{position:relative;border:1px solid #334155;border-radius:10px;display:flex;align-items:center;justify-content:center;color:#7a8aa3;font-size:.7rem;user-select:none}
  .frame::before{content:"";position:absolute;inset:0;border-radius:10px;box-shadow:inset 0 0 0 1px #111827}
  .frame.active{background:#0ea5e9;border-color:#0ea5e9;color:#001018;transform:translateY(-2px);box-shadow:var(--ring)}
  .frame.captured{background:#0b1320;border-color:#3b516b}
  .frame:focus-visible{outline:2px solid var(--ui)}

  /* --- CONTROL TRAY --- */
  #tray{position:fixed;left:50%;transform:translateX(-50%);bottom:1rem;width:min(92vw,880px);display:flex;gap:.6rem;z-index:12}
  .btn{flex:1;background:var(--glass);border:1px solid #1f2937;border-radius:14px;padding:.9rem 1rem;color:var(--ink);font-weight:700;text-align:center;letter-spacing:.02em}
  .btn:active{transform:scale(.98)}
  .btn.primary{border-color:var(--ui);color:#001018;background:linear-gradient(#7dd3fc,#38bdf8)}
  .btn.toggle.on{background:linear-gradient(#34d399,#10b981);border-color:#10b981;color:#001810}

  /* --- MINI OSCILLOSCOPE (stride & capture signals) --- */
  #scope-wrap{position:fixed;left:50%;transform:translateX(-50%);bottom:calc(6.75rem + 74px);width:min(92vw,880px);height:80px;border-radius:12px;border:1px solid #1f2937;overflow:hidden;background:linear-gradient(180deg,rgba(10,18,26,.85),rgba(6,10,16,.95));backdrop-filter:blur(6px);z-index:12}
  #scope{width:100%;height:100%;display:block}
  #scope-label{position:absolute;top:.3rem;left:.5rem;color:var(--sub);font-size:.7rem}

  /* --- DEBUG PANEL --- */
  #debug{position:fixed;right:.75rem;bottom:calc(6.75rem + 170px);background:var(--glass-2);border:1px solid #1f2937;border-radius:12px;padding:.6rem .7rem;z-index:12;min-width:190px}
  #debug h3{font-size:.8rem;margin-bottom:.3rem;color:var(--sub)}
  #debug label{display:flex;justify-content:space-between;align-items:center;font-size:.8rem;margin:.25rem 0}
  #debug input[type="checkbox"]{width:22px;height:22px}
  #fps{font-variant-numeric:tabular-nums}

  /* --- TESTS PANEL --- */
  #tests{position:fixed;left:.75rem;bottom:calc(6.75rem + 170px);z-index:13}
  #tests .pill{display:flex;gap:.5rem;align-items:center}
  .badge{border-radius:999px;padding:.15rem .5rem;font-weight:800;font-size:.7rem}
  .pass{background:rgba(16,185,129,.15);color:var(--pass);border:1px solid rgba(16,185,129,.45)}
  .fail{background:rgba(239,68,68,.15);color:var(--fail);border:1px solid rgba(239,68,68,.45)}

  /* --- ACCESSIBILITY --- */
  [aria-live]{position:fixed;left:-9999px}

  /* --- 3D helpers --- */
  .legend{position:fixed;top:3.2rem;left:.75rem;color:var(--sub);font-size:.75rem;z-index:12}

  @media (max-width:560px){
    .btn{padding:.85rem .8rem;font-size:.9rem}
    #timeline{height:56px}
    .frame{font-size:.62rem}
    #debug{min-width:170px}
  }
</style>
</head>
<body>
  <div id="stage" aria-label="3D simulation canvas"></div>

  <!-- HUD Left: mode + help -->
  <div id="hud-left" class="hud">
    <div class="pill" id="mode-pill" aria-live="polite"><span class="dot" id="rec-dot"></span><b id="mode-label">REC · BULLET TIME</b></div>
  </div>
  
  <!-- HUD Right: active camera readout -->
  <div id="hud-right" class="hud">
    <div class="pill" id="cam-readout" aria-live="polite">CAM 01</div>
  </div>

  <!-- Legend / quick gestures -->
  <div class="legend">Swipe = scrub · Tap frame = jump · Long‑press = play/pause · 2‑finger tap = toggle debug</div>

  <!-- Mini Oscilloscope: surfaces invisible stride & triggers -->
  <div id="scope-wrap" role="group" aria-label="stride & capture scope">
    <canvas id="scope"></canvas>
    <div id="scope-label">Stride (sin) · Capture triggers (ticks)</div>
  </div>

  <!-- Sequence timeline -->
  <div id="timeline" style="--count:24" role="list" aria-label="camera frames"></div>

  <!-- Controls tray -->
  <div id="tray" role="toolbar" aria-label="controls">
    <button id="play" class="btn primary" aria-pressed="true">⏸︎ Pause</button>
    <button id="speed" class="btn toggle">Speed 1×</button>
    <button id="regen" class="btn">Rebuild 24◦</button>
    <button id="debug-toggle" class="btn toggle">Debug OFF</button>
  </div>

  <!-- Debug toggles -->
  <section id="debug" hidden>
    <h3>Debug / Calibration</h3>
    <label>Camera IDs <input id="dg-ids" type="checkbox" checked></label>
    <label>Capture Rays <input id="dg-rays" type="checkbox" checked></label>
    <label>Tripwire Line <input id="dg-wire" type="checkbox" checked></label>
    <label>Active Frustum <input id="dg-frustum" type="checkbox"></label>
    <label>Grid Floor <input id="dg-grid" type="checkbox" checked></label>
    <label>Sepia Backdrop <input id="dg-sepia" type="checkbox" checked></label>
    <label>Horse Trail <input id="dg-trail" type="checkbox"></label>
    <div style="margin-top:.35rem;color:var(--sub);font-size:.75rem">FPS <span id="fps">—</span></div>
  </section>

  <!-- Tests -->
  <div id="tests">
    <div class="pill">
      <span id="tests-status" class="badge fail">0/0</span>
      <button id="run-tests" class="btn" style="padding:.35rem .6rem;min-width:unset;">Run Tests</button>
    </div>
  </div>

  <div id="aria" aria-live="polite"></div>

  <!-- Use ES Modules with resilient loader to avoid 'THREE is not defined' -->
  <script type="module">
  // Resilient dynamic import for three.module.js
  async function loadThree(){
    const urls = [
      'https://unpkg.com/three@0.152.2/build/three.module.js',
      'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js',
      'https://esm.run/three@0.152.2'
    ];
    for(const url of urls){
      try { const m = await import(url); return m; } catch(e){ /* try next */ }
    }
    throw new Error('Failed to load three.module.js from all sources');
  }

  (async () => {
    let THREE;
    try { THREE = await loadThree(); } catch (err) {
      showFatal(`THREE failed to load. Offlining the sim.\\n\\nReason: ${err.message}`);
      setupBareTests(false);
      return;
    }

    // --- State ---
    let scene, renderer, horse, currentFrame = 0;
    let isPlaying = true; let playSpeed = 1; let speedIdx = 1; const speeds=[0.5,1,2,4];
    const STATE = { COUNT:24, RADIUS:18, capturePhase:0, touch:{x:0, active:false}, debug:true };
    const rigs = []; // {camera, stand, label, ray, frustum}
    let lastT=0, fpsAvg=60, ticks=0;

    // --- Boot ---
    const stage = document.getElementById('stage');
    const timeline = document.getElementById('timeline');
    const scopeCanvas = document.getElementById('scope');
    const scopeCtx = scopeCanvas.getContext('2d');
    const camReadout = document.getElementById('cam-readout');
    const ariaLive = document.getElementById('aria');

    function boot(){
      scene = new THREE.Scene();
      setBackdrop(true);
      renderer = new THREE.WebGLRenderer({antialias:true,powerPreference:'high-performance'});
      renderer.setPixelRatio(Math.min(devicePixelRatio,2));
      renderer.setSize(innerWidth, innerHeight);
      renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      stage.appendChild(renderer.domElement);

      addLights();
      addGround();

      buildCameras(STATE.COUNT);
      buildTimeline(STATE.COUNT);
      buildHorse();
      buildTripwire();

      bindUI();
      onResize();
      requestAnimationFrame(tick);
    }

    function setBackdrop(sepia){
      scene.background = new THREE.Color(sepia?0xd8d8d0:0x0b0d10);
      scene.fog = sepia? new THREE.Fog(0xd8d8d0, 40, 100) : new THREE.Fog(0x0b0d10, 50, 140);
    }

    function addLights(){
      const amb = new THREE.AmbientLight(0xffffff, .65); scene.add(amb);
      const sun = new THREE.DirectionalLight(0xfffef0, 1.25); sun.position.set(25,40,15);
      sun.castShadow=true; sun.shadow.mapSize.set(2048,2048);
      const s = 35; Object.assign(sun.shadow.camera, {left:-s,right:s,top:s,bottom:-s,near:1,far:150});
      scene.add(sun);
    }

    let gridHelper, tripwire;
    function addGround(){
      const g = new THREE.PlaneGeometry(120,120);
      const m = new THREE.MeshLambertMaterial({color:0x203040, side:THREE.DoubleSide});
      const ground = new THREE.Mesh(g,m); ground.rotation.x = -Math.PI/2; ground.receiveShadow=true; scene.add(ground);
      gridHelper = new THREE.GridHelper(120, 60, 0x1f2a37, 0x15202b); gridHelper.position.y=.02; scene.add(gridHelper);
    }

    function buildTripwire(){
      const geo = new THREE.PlaneGeometry(0.08, 60);
      const mat = new THREE.MeshBasicMaterial({color:0xf59e0b, side:THREE.DoubleSide});
      tripwire = new THREE.Mesh(geo, mat); tripwire.rotation.x = -Math.PI/2; tripwire.position.set(0,.03,0);
      scene.add(tripwire);
    }

    function buildCameras(n){
      // clear old
      rigs.splice(0); // keep array ref
      // remove previous stands
      [...scene.children].forEach(o=>{ if(o.userData && o.userData.kind==='stand'){ scene.remove(o) } });

      const startA = -Math.PI*0.42, endA = Math.PI*0.42, span=endA-startA;
      for(let i=0;i<n;i++){
        const t = i/(n-1); const ang = startA + span*t;
        const x = Math.sin(ang)*STATE.RADIUS; const z = Math.cos(ang)*STATE.RADIUS;
        const cam = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, .5, 120);
        cam.position.set(x,3.6,z); cam.lookAt(0,1.6,0);

        // Stand group
        const group = new THREE.Group(); group.userData.kind='stand';
        const post = new THREE.Mesh(new THREE.CylinderGeometry(.1,.12,4), new THREE.MeshLambertMaterial({color:0x0f141a}));
        post.position.y=2; post.castShadow=true; group.add(post);
        const box = new THREE.Mesh(new THREE.BoxGeometry(.42,.32,.32), new THREE.MeshLambertMaterial({color:0x1b232e}));
        box.position.y=4; box.castShadow=true; group.add(box);

        // ID plate (sprite)
        const tex = labelTexture(i+1); const spr = new THREE.Sprite(new THREE.SpriteMaterial({map:tex}));
        spr.position.y=5; spr.scale.set(1.2,1.2,1); group.add(spr);

        // capture ray visual
        const rayGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,4,0), new THREE.Vector3(0,1.6,-STATE.RADIUS)]);
        const ray = new THREE.Line(rayGeo, new THREE.LineBasicMaterial({color:0x38bdf8, transparent:true, opacity:.65}));
        ray.position.set(0,0,0); group.add(ray);

        group.position.set(x,0,z); group.lookAt(0,0,0); scene.add(group);

        rigs.push({camera:cam, stand:group, label:spr, ray, frustum:makeFrustumHelper(cam)});
      }
    }

    function labelTexture(num){
      const c=document.createElement('canvas'); c.width=c.height=256; const ctx=c.getContext('2d');
      ctx.fillStyle='#0b1220'; ctx.fillRect(0,0,256,256);
      ctx.fillStyle='#eaf2ff'; ctx.font='bold 150px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(String(num).padStart(2,'0'),128,136);
      return new THREE.CanvasTexture(c);
    }

    function makeFrustumHelper(cam){
      const helper = new THREE.CameraHelper(cam); helper.visible=false; scene.add(helper); return helper;
    }

    function buildTimeline(n){
      timeline.style.setProperty('--count', n);
      timeline.innerHTML='';
      for(let i=0;i<n;i++){
        const d=document.createElement('button'); d.className='frame'; d.role='listitem'; d.textContent=String(i+1).padStart(2,'0');
        d.addEventListener('click',()=>jump(i));
        d.addEventListener('keydown',e=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); jump(i); }});
        timeline.appendChild(d);
      }
    }

    function buildHorse(){
      horse = new THREE.Group(); const mat=new THREE.MeshLambertMaterial({color:0x0c1117});
      const body=new THREE.Mesh(new THREE.BoxGeometry(4,1.8,1.3),mat); body.position.y=1.8; body.castShadow=true; horse.add(body);
      const neck=new THREE.Mesh(new THREE.BoxGeometry(1.2,2.2,1),mat); neck.position.set(2.2,2.5,0); neck.rotation.z=.5; neck.castShadow=true; horse.add(neck);
      const head=new THREE.Mesh(new THREE.BoxGeometry(1.2,1.2,.9),mat); head.position.set(3.2,3.8,0); head.rotation.z=.2; head.castShadow=true; horse.add(head);
      const earG=new THREE.ConeGeometry(.15,.4,5); const e1=new THREE.Mesh(earG,mat); e1.position.set(3.5,4.5,.3); e1.castShadow=true; horse.add(e1);
      const e2=e1.clone(); e2.position.z=-.3; horse.add(e2);

      const legG=new THREE.CylinderGeometry(.15,.12,2);
      const legs=[
        { x:1.5, z: .5, phase:0, name:'frontLeft' },
        { x:1.5, z:-.5, phase:Math.PI, name:'frontRight' },
        { x:-1.3,z: .5, phase:Math.PI*.6, name:'backLeft' },
        { x:-1.3,z:-.5, phase:Math.PI*1.6, name:'backRight' }
      ];
      horse.legs=[]; legs.forEach(L=>{ const l=new THREE.Mesh(legG,mat); l.position.set(L.x,1,L.z); l.userData={baseX:L.x,baseZ:L.z,phase:L.phase,name:L.name}; l.castShadow=true; horse.add(l); horse.legs.push(l); });

      const tail=new THREE.Mesh(new THREE.CylinderGeometry(.1,.05,1.5),mat); tail.position.set(-2.5,2,0); tail.rotation.z=-.8; tail.castShadow=true; horse.add(tail);

      const torso=new THREE.Mesh(new THREE.BoxGeometry(.8,1.8,.8),mat); torso.position.set(-.3,3.5,0); torso.castShadow=true; horse.add(torso);
      const rh=new THREE.Mesh(new THREE.SphereGeometry(.4),mat); rh.position.set(-.3,4.7,0); rh.castShadow=true; horse.add(rh);

      horse.position.set(-20,0,0); scene.add(horse);
    }

    function setActiveVisuals(){
      // Update timeline classes
      const frames=[...document.querySelectorAll('.frame')];
      frames.forEach((f,i)=>{ f.classList.toggle('active',i===currentFrame); f.classList.toggle('captured', i<=currentFrame); });
      // Scale active stand
      rigs.forEach((r,i)=>{ const s=i===currentFrame?1.18:1.0; r.stand.scale.set(s,s,s); r.frustum.visible = STATE.debug && document.getElementById('dg-frustum').checked && i===currentFrame; });
      camReadout.textContent = `CAM ${String(currentFrame+1).padStart(2,'0')}`;
    }

    function updateHorse(phase){
      const stride = phase * Math.PI*2; // 0..2π
      horse.legs.forEach(leg=>{
        const lp = stride + leg.userData.phase; const lift = Math.max(0, Math.sin(lp))*1.35; leg.position.y = 1 + lift; leg.rotation.z = Math.sin(lp)*.3; leg.position.x = leg.userData.baseX + Math.cos(lp)*.5;
      });
      horse.children[0].position.y = 1.8 + Math.sin(stride)*.24; // body bob
      horse.children[0].rotation.z = Math.sin(stride)*.1; horse.children[0].rotation.x = Math.cos(stride*2)*.05;
      horse.position.x = -20 + phase*40; // traverse track
    }

    function drawScope(t){
      const w=scopeCanvas.width, h=scopeCanvas.height; scopeCtx.clearRect(0,0,w,h);
      // grid
      scopeCtx.globalAlpha=.6; scopeCtx.strokeStyle='#0f172a'; scopeCtx.beginPath();
      for(let x=0;x<w;x+=Math.max(8, w/32)){ scopeCtx.moveTo(x,0); scopeCtx.lineTo(x,h); } scopeCtx.stroke();
      scopeCtx.globalAlpha=1;
      // stride sin
      scopeCtx.beginPath(); scopeCtx.lineWidth=2; scopeCtx.strokeStyle='#7dd3fc';
      for(let x=0;x<w;x++){
        const p = ( (currentFrame/STATE.COUNT) + x/w ) % 1; const y = (Math.sin(p*Math.PI*2)*.45+.5)*h; if(x===0) scopeCtx.moveTo(0,y); else scopeCtx.lineTo(x,y);
      } scopeCtx.stroke();
      // capture ticks (one per frame)
      scopeCtx.fillStyle='#f59e0b'; for(let i=0;i<STATE.COUNT;i++){ const x=i*(w/STATE.COUNT); scopeCtx.fillRect(x-1,0,2,h); }
    }

    function jump(i){ currentFrame = ( (i%STATE.COUNT)+STATE.COUNT )%STATE.COUNT; setActiveVisuals(); ariaLive.textContent=`Jumped to camera ${currentFrame+1}`; }

    function togglePlay(){ isPlaying = !isPlaying; document.getElementById('play').textContent = isPlaying? '⏸︎ Pause':'▶︎ Play'; document.getElementById('play').classList.toggle('primary', isPlaying); document.getElementById('play').setAttribute('aria-pressed', String(isPlaying)); }

    function cycleSpeed(){ speedIdx=(speedIdx+1)%speeds.length; playSpeed=speeds[speedIdx]; document.getElementById('speed').textContent = `Speed ${playSpeed}\u00d7`; }

    function rebuild(){ buildCameras(STATE.COUNT); buildTimeline(STATE.COUNT); setActiveVisuals(); }

    // --- Input / UI ---
    function bindUI(){
      document.getElementById('play').addEventListener('click', togglePlay);
      document.getElementById('speed').addEventListener('click', cycleSpeed);
      document.getElementById('regen').addEventListener('click', rebuild);
      document.getElementById('debug-toggle').addEventListener('click', ()=>{ STATE.debug=!STATE.debug; toggleDebug(STATE.debug); });

      ['dg-ids','dg-rays','dg-wire','dg-frustum','dg-grid','dg-sepia','dg-trail'].forEach(id=>{
        const el=document.getElementById(id); el.addEventListener('change', applyDebugFlags);
      });

      // Gestures: swipe to scrub, long-press to toggle play, 2-finger tap for debug
      let longTimer=null; let fingers=0;
      stage.addEventListener('touchstart',e=>{
        fingers=e.touches.length; const x0 = e.touches[0].clientX; STATE.touch.active=true; STATE.touch.x=x0; longTimer=setTimeout(()=>{togglePlay();},500);
      },{passive:true});
      stage.addEventListener('touchmove',e=>{
        if(!STATE.touch.active) return; const x=e.touches[0].clientX; const dx=x-STATE.touch.x; if(Math.abs(dx)>8){ clearTimeout(longTimer); const step = dx>0?1:-1; jump(currentFrame+step); STATE.touch.x=x; }
      },{passive:true});
      stage.addEventListener('touchend',e=>{
        if(longTimer) clearTimeout(longTimer); if(fingers===2){ STATE.debug=!STATE.debug; toggleDebug(STATE.debug); }
        STATE.touch.active=false; fingers=0;
      });

      // Resize
      addEventListener('resize', onResize);
    }

    function toggleDebug(show){
      document.getElementById('debug').hidden = !show; document.getElementById('debug-toggle').classList.toggle('on', show); applyDebugFlags();
    }

    function applyDebugFlags(){
      const ids = document.getElementById('dg-ids').checked;
      const rays = document.getElementById('dg-rays').checked;
      const wire = document.getElementById('dg-wire').checked;
      const grid = document.getElementById('dg-grid').checked;
      const sepia = document.getElementById('dg-sepia').checked;

      rigs.forEach(r=>{ r.label.visible = ids; r.ray.visible = rays; });
      tripwire.visible = wire; gridHelper.visible = grid; setBackdrop(sepia);
    }

    function onResize(){
      renderer.setSize(innerWidth, innerHeight);
      rigs.forEach(r=>{ r.camera.aspect=innerWidth/innerHeight; r.camera.updateProjectionMatrix(); });
      scopeCanvas.width = scopeCanvas.clientWidth * devicePixelRatio; scopeCanvas.height = scopeCanvas.clientHeight * devicePixelRatio;
    }

    // --- Main Loop ---
    function tick(t){
      requestAnimationFrame(tick); ticks++;
      const dt = (t-lastT)/1000 || 0; lastT=t; fpsAvg = fpsAvg*0.9 + Math.min(1/dt,120)*0.1; document.getElementById('fps').textContent = `${fpsAvg.toFixed(0)}`;

      if(isPlaying){ STATE.capturePhase += dt*0.3*playSpeed; currentFrame = Math.floor(STATE.capturePhase*STATE.COUNT)%STATE.COUNT; }

      const phase = currentFrame/STATE.COUNT; updateHorse(phase);
      setActiveVisuals(); drawScope(t);

      const cam = rigs[currentFrame]?.camera || rigs[0].camera; renderer.render(scene, cam);
    }

    // ---------- TESTS ----------
    const TESTS = [
      { name:'THREE loaded', fn:()=> typeof THREE.Scene === 'function' },
      { name:'Scene booted', fn:()=> !!scene && !!renderer },
      { name:'Built camera rigs', fn:()=> rigs.length === STATE.COUNT },
      { name:'Timeline frames', fn:()=> document.querySelectorAll('.frame').length === STATE.COUNT },
      { name:'Render ticking', fn:()=> ticks > 10 }
    ];

    function runTests(){
      let pass=0; for(const t of TESTS){ try{ if(t.fn()){ pass++; } }catch(e){} }
      const badge=document.getElementById('tests-status');
      badge.textContent = `${pass}/${TESTS.length}`;
      badge.classList.toggle('pass', pass===TESTS.length);
      badge.classList.toggle('fail', pass!==TESTS.length);
    }

    document.getElementById('run-tests').addEventListener('click', runTests);

    // Kickoff
    boot();

    // Auto-run tests after short warmup
    setTimeout(runTests, 1200);

  })();

  // --- Fatal error helper & bare tests when THREE missing ---
  function showFatal(msg){
    const div=document.createElement('div');
    div.style.cssText='position:fixed;inset:auto 1rem 1rem 1rem;background:rgba(15,23,42,.95);color:#fff;border:1px solid #334155;border-radius:12px;padding:12px 14px;z-index:9999;box-shadow:0 10px 30px rgba(0,0,0,.5)';
    div.innerHTML = `<b>Simulation disabled</b><br><small>${msg}</small>`;
    document.body.appendChild(div);
  }
  function setupBareTests(ok){
    const badge=document.getElementById('tests-status');
    badge.textContent = ok? '1/1' : '0/1';
    badge.classList.toggle('pass', ok);
    badge.classList.toggle('fail', !ok);
    document.getElementById('run-tests').addEventListener('click', ()=>{});
  }
  </script>
</body>
</html>
