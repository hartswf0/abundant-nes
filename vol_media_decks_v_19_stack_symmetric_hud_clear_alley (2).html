<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>VOL‑MEDIA DECKS v19 — Stack‑Symmetric HUD (Clear Alley)</title>
<style>
  /* ======= GLOBAL ======= */
  *{margin:0;padding:0;box-sizing:border-box;touch-action:none;-webkit-tap-highlight-color:transparent}
  html,body{height:100%}
  :root{
    --ink:#fff; --bg:#000; --glass:rgba(0,0,0,.55); --line:rgba(255,255,255,.18);
    --pad:10px; --rad:12px; --gap:8px; --safe-alley:240px; /* RESERVED: middle-bottom negative space */
  }
  body{background:var(--bg);color:var(--ink);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;overflow:hidden}
  #canvas{width:100vw;height:100vh;display:block}

  /* ======= HUD LAYOUT (edge‑docked; center‑bottom alley hidden by default) ======= */
  #hud{position:fixed;inset:0;pointer-events:none;z-index:10}
  /* Alley rail now optional (hidden by default after feedback) */
  #alley{display:none}
  #alleyRail{display:none}

  /* Left + Right vertical docks (screen‑fixed) */
  .dock{position:absolute;top:10px;bottom:10px;display:flex;flex-direction:column;gap:var(--gap);pointer-events:auto}
  #dockL{left:10px;align-items:flex-start}
  #dockR{right:10px;align-items:flex-end}

  .stack{display:grid;grid-auto-rows:38px;gap:var(--gap);padding:var(--pad);background:var(--glass);backdrop-filter:blur(6px);border:1px solid var(--line);border-radius:var(--rad)}
  .cap{font-weight:800;font-size:12px;opacity:.85;letter-spacing:.08em}

  /* Square mini‑buttons (symmetric card vibe) */
  .mini{width:38px;height:38px;border-radius:10px;border:1px solid var(--line);background:rgba(0,0,0,.55);display:grid;place-items:center;font-weight:900;font-size:13px;cursor:pointer;user-select:none}
  .mini:active{transform:translateY(1px)}
  .mini[aria-pressed="true"]{outline:2px solid rgba(255,255,255,.35)}

  /* Context micro‑panel for a selected cell (stacks near stack) */
  #cellHUD{position:absolute;pointer-events:auto;z-index:20;display:none}
  #cellHUD .panel{display:grid;grid-template-columns:repeat(5,42px);gap:8px;padding:8px;background:var(--glass);border:1px solid var(--line);border-radius:12px;backdrop-filter:blur(8px)}
  #cellHUD .mini{width:42px;height:42px;border-radius:10px}

  /* Top view badge */
  #viewHUD{position:absolute;top:10px;left:50%;transform:translateX(-50%);background:var(--glass);padding:6px 12px;border-radius:10px;font-weight:800;font-size:12px;border:1px solid var(--line)}

  /* Toast (fixed, single definition — duplicate removed) */
  #toast{
    position:fixed;bottom:10px;left:50%;transform:translateX(-50%);
    background:rgba(0,0,0,.86);border:1px solid rgba(255,255,255,.2);
    padding:6px 10px;border-radius:10px;font-size:12px;display:none;z-index:12;
  }

  /* Newspaper mode toggle */
  body.mono, body.mono #hud{filter:grayscale(100%)}

  /* Responsive clamps */
  @media (max-width:420px){:root{--safe-alley:200px} .mini{width:34px;height:34px}}
  
  /* ======= Alley-as-Stacks: rails + cascading panels ======= */
  #alley{display:none} /* keep debug box opt-in (toggle with key 'a') */
  #alleyRail{position:absolute;left:50%;bottom:10px;transform:translateX(-50%);
    display:flex;gap:8px;pointer-events:auto;z-index:12}
  #alleyRail .mini{width:44px;height:44px}

  #cascade{position:absolute;inset:0;pointer-events:none;z-index:11}
  .stackPanel{position:absolute;bottom:64px; /* lives above alley rail */
    display:grid;grid-template-columns:repeat(5,48px);gap:8px;padding:10px;
    background:var(--glass);border:1px solid var(--line);border-radius:14px;
    backdrop-filter:blur(8px);pointer-events:auto;opacity:0;transform:translateY(8px) scale(.98);
    transition:opacity .14s ease, transform .14s ease}
  .stackPanel.on{opacity:1;transform:translateY(0) scale(1)}
  .stackPanel .mini{width:48px;height:48px;border-radius:12px}
  .stackPanel .cap{grid-column:1/-1;text-align:center;font-size:12px;opacity:.8;margin-bottom:2px}
  .crumbs{grid-column:1/-1;display:flex;gap:6px;justify-content:center;margin-bottom:2px}
  .crumb{font-size:11px;padding:4px 8px;border:1px solid var(--line);border-radius:999px;opacity:.75}

  /* Mobile orientation-aware scaling */
  @media (orientation:portrait){
    :root{--safe-alley:200px}
    #alleyRail .mini{width:40px;height:40px}
    .stackPanel{grid-template-columns:repeat(4,48px)}
  }
  @media (max-width:420px){
    .stackPanel{grid-template-columns:repeat(4,44px)}
    .stackPanel .mini{width:44px;height:44px}
  }
</style>
</head>
<body>
<canvas id="canvas" aria-label="VOL‑MEDIA grid"></canvas>
<div id="hud" aria-hidden="false">
  <div id="viewHUD">FRONT</div>

  <!-- LEFT DOCK: density, packs, presets -->
  <div id="dockL" class="dock">
    <div class="stack" id="densityStack" aria-label="Density">
      <div class="cap">DENS</div>
      <div class="mini" data-density="16" title="16×16">16</div>
      <div class="mini" data-density="8"  title="8×8">8</div>
      <div class="mini" data-density="4"  title="4×4">4</div>
      <div class="mini" data-density="2"  title="2×2">2</div>
      <div class="mini" data-density="1"  title="1×1 mega">1</div>
    </div>

    <div class="stack" id="packStack" aria-label="Packs">
      <div class="cap">PACK</div>
      <div class="mini" data-pack="prev" title="Prev">◀</div>
      <div class="mini" data-pack="next" title="Next">▶</div>
    </div>

    <div class="stack" id="presetStack" aria-label="Preset">
      <div class="cap">PRE</div>
      <div class="mini" data-pre="BASIC">B</div>
      <div class="mini" data-pre="HOUSE">H</div>
      <div class="mini" data-pre="DNB">D</div>
    </div>
  </div>

  <!-- RIGHT DOCK: transport & camera -->
  <div id="dockR" class="dock">
    <div class="stack" id="transportStack" aria-label="Transport">
      <div class="cap">PLAY</div>
      <div class="mini" id="btnStart" title="Play/Pause">▶</div>
      <div class="mini" id="btnOrbit" title="Orbit">○</div>
      <div class="mini" id="btnFit" title="Fit">□</div>
      <div class="mini" id="btnZoomIn" title="Zoom In">＋</div>
      <div class="mini" id="btnZoomOut" title="Zoom Out">－</div>
      <div class="mini" id="btnPaper" title="Newspaper mode">N</div>
    </div>

    <div class="stack" id="viewStack" aria-label="Views">
      <div class="cap">VIEW</div>
      <div class="mini" data-view="0" title="Front">F</div>
      <div class="mini" data-view="1" title="Iso L">L</div>
      <div class="mini" data-view="2" title="Iso R">R</div>
      <div class="mini" data-view="3" title="Top">T</div>
      <div class="mini" data-view="4" title="Wide">W</div>
    </div>
  </div>

  <!-- Optional, currently hidden alley rail & cascade container -->
  <div id="alleyRail" style="display:none"></div>
  <div id="cascade" style="display:none"></div>

  <!-- Contextual cell tuner (appears near selected stack) -->
  <div id="cellHUD"><div class="panel" id="cellPanel"></div></div>
</div>
<div id="toast" role="status" aria-live="polite"></div>

<script>
(async function(){
  /* ===== THREE loader (fallbacks) ===== */
  if(!window.THREE){
    const CDNs=['https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js','https://unpkg.com/three@0.152.2/build/three.min.js'];
    for(const src of CDNs){ try{ await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=src; s.onload=res; s.onerror=rej; document.head.appendChild(s); }); if(window.THREE) break; }catch(e){} }
  }
  if(!window.THREE){ alert('WebGL/THREE required.'); return; }

  const canvas=document.getElementById('canvas');
  const renderer=new THREE.WebGLRenderer({canvas,antialias:true,alpha:false,powerPreference:'high-performance'});
  const DPR=Math.min(devicePixelRatio||1,2); renderer.setPixelRatio(DPR); renderer.setSize(innerWidth,innerHeight);
  const scene=new THREE.Scene(); scene.background=new THREE.Color(0x000000);
  const camera=new THREE.PerspectiveCamera(58, innerWidth/innerHeight, .1, 5000);
  const camTarget=new THREE.Vector3(0,8,0);
  function look(){ camera.lookAt(camTarget); }

  /* ===== Lights (reduced glow; depth safe) ===== */
  scene.add(new THREE.AmbientLight(0xffffff,.26));
  const key=new THREE.PointLight(0x66ddff,1.1,1200); key.position.set(0,160,260); scene.add(key);
  const warm=new THREE.PointLight(0xffaa66,.8,900); warm.position.set(180,100,-160); scene.add(warm);
  const rim=new THREE.DirectionalLight(0xffffff,.45); rim.position.set(-140,180,-40); scene.add(rim);

  /* ===== HUD helpers ===== */
  const toastEl=document.getElementById('toast');
  function toast(t){ toastEl.textContent=t; toastEl.style.display='block'; clearTimeout(toast._id); toast._id=setTimeout(()=>toastEl.style.display='none',1100); }
  function buzz(ms=8){ if('vibrate' in navigator) try{ navigator.vibrate(ms); }catch{} }

  /* ===== Sprite helper (minimal labels; can be hidden) ===== */
  function mkSprite(text){
    const cvs=document.createElement('canvas'); const s=256; cvs.width=cvs.height=s; const ctx=cvs.getContext('2d');
    ctx.clearRect(0,0,s,s); ctx.fillStyle='rgba(0,0,0,0)'; ctx.fillRect(0,0,s,s); ctx.fillStyle='white'; ctx.font='bold 46px Inter, system-ui';
    ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.shadowColor='rgba(0,0,0,0.55)'; ctx.shadowBlur=12; ctx.fillText(text,s/2,s/2);
    const tex=new THREE.CanvasTexture(cvs); const mat=new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false});
    const spr=new THREE.Sprite(mat); spr.scale.set(5.2,5.2,1); return spr;
  }

  /* ===== Mini‑stack builder (symmetric squares) ===== */
  function makeMiniStack(color, layers=8, spacing=0.55, size=2.6){
    const g=new THREE.Group(); g.renderOrder=1;
    for(let i=0;i<layers;i++){
      const geo=new THREE.PlaneGeometry(size,size);
      const mat=new THREE.MeshStandardMaterial({color,transparent:true,opacity:0.18,roughness:.65,metalness:.08,side:THREE.DoubleSide,depthWrite:false});
      const m=new THREE.Mesh(geo,mat); m.rotation.x=-Math.PI/2; m.position.y=i*spacing; m.material.emissive=new THREE.Color(color); m.material.emissiveIntensity=.09; g.add(m);
    }
    g.userData.pulse=(level)=>{
      const L=g.children.length; for(let i=0;i<L;i++){
        const p=g.children[i]; const on=i<Math.min(L,Math.ceil(level*L));
        p.material.opacity=on?0.72:0.12; p.material.emissiveIntensity=on?0.6:0.08; p.scale.set(on?1.04:1,1,on?1.04:1);
      }
      if(level>0){ const s=1+level*0.12; g.scale.set(s,1,s); setTimeout(()=>g.scale.set(1,1,1),90); }
    };
    return g;
  }

  /* ===== Grid model ===== */
  const GRID={ rows:8, cols:16, gapX:7.2, gapZ:8.0, origin:new THREE.Vector3(), group:new THREE.Group(), cells:[], labels:[], cursor:null };
  scene.add(GRID.group);
  const instruments=['Kick','Snr','Hat','Bass','Chord','Lead','Perc','FX'];
  const colors=[0xff8844,0xff6688,0xffff66,0x66ffcc,0x99bbff,0xc47dff,0x88ffaa,0xffffff];

  function autoSpacing(){
    const w=innerWidth, h=innerHeight; const baseX=7.2, baseZ=8.0;
    const scale=Math.min(Math.max(Math.min(w/960, h/620), 0.85), 1.35);
    GRID.gapX=baseX*scale; GRID.gapZ=baseZ*scale;
  }

  function refreshLayout(){
    const startX=-(GRID.cols-1)*GRID.gapX/2, startZ=-(GRID.rows-1)*GRID.gapZ/2; GRID.origin.set(startX,0,startZ);
    for(let r=0;r<GRID.rows;r++) for(let c=0;c<GRID.cols;c++){
      const stack=GRID.cells[r]?.[c]; if(!stack) continue; stack.position.set(startX + c*GRID.gapX, 0, startZ + r*GRID.gapZ);
    }
    GRID.labels.forEach((lbl,r)=> lbl.position.set(startX-8.0,6,startZ + r*GRID.gapZ));
    if(GRID.cursor){ GRID.cursor.position.set(startX, 0.2, 0); GRID.cursor.scale.set(1,1,(GRID.rows*GRID.gapZ + 4)/(GRID.cursor.geometry.parameters.depth||1)); }
    fitCameraToGrid();
  }

  function buildGrid(){
    GRID.cells.length=0; GRID.labels.length=0; while(GRID.group.children.length) GRID.group.remove(GRID.group.children[0]);
    autoSpacing();
    const startX=-(GRID.cols-1)*GRID.gapX/2, startZ=-(GRID.rows-1)*GRID.gapZ/2; GRID.origin.set(startX,0,startZ);
    for(let r=0;r<GRID.rows;r++){
      const row=[]; for(let c=0;c<GRID.cols;c++){
        const stack=makeMiniStack(colors[r]);
        stack.position.set(startX + c*GRID.gapX, 0, startZ + r*GRID.gapZ);
        stack.userData.rc=[r,c]; stack.userData.active=0; row.push(stack); GRID.group.add(stack);
      }
      GRID.cells.push(row);
    }
    GRID.cursor=new THREE.Mesh(new THREE.BoxGeometry(3.0,0.35, GRID.rows*GRID.gapZ + 4), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.1}));
    GRID.cursor.position.set(startX,0.2,0); GRID.group.add(GRID.cursor);
    for(let r=0;r<instruments.length;r++){ const spr=mkSprite('R'+(r+1)); spr.scale.set(4.2,4.2,1); spr.position.set(startX-8.0,6,startZ + r*GRID.gapZ); GRID.labels.push(spr); GRID.group.add(spr); }
  }

  /* ===== Fit camera to grid (frustum‑aware) ===== */
  let dist=170, orbit=false; camera.position.set(120,80,150); look();
  function fitCameraToGrid(){
    const w=(GRID.cols-1)*GRID.gapX + 6, d=(GRID.rows-1)*GRID.gapZ + 6, h=60; // approximate stack height
    const fov=THREE.MathUtils.degToRad(camera.fov); const aspect=camera.aspect;
    const distV=(h/2)/Math.tan(fov/2) + 90; // height + buffer
    const vFovH=2*Math.atan(Math.tan(fov/2)*aspect);
    const distH=(w/2)/Math.tan(vFovH/2) + 90;
    dist=Math.max(distV, distH);
    const yaw=Math.atan2(camera.position.z, camera.position.x) || 0.75; // keep angle
    camera.position.set(Math.cos(yaw)*dist, 60, Math.sin(yaw)*dist);
    camTarget.set(0,8,0); look();
  }

  /* ===== Build initial grid ===== */
  buildGrid(); refreshLayout();

  /* ===== Pattern + Audio ===== */
  const pattern=Array.from({length:GRID.rows},()=>Array(GRID.cols).fill(0));
  const scales={major:[0,2,4,5,7,9,11], minor:[0,2,3,5,7,8,10], dorian:[0,2,3,5,7,9,10], mixolydian:[0,2,4,5,7,9,10], pentMinor:[0,3,5,7,10]};
  let root=50; let scaleName='dorian'; let progression=[0,3,4,5];
  let bpm=112, playing=false, step=0, progressionIdx=0;

  let AC=null, master=null, wet=null, dry=null; const laneFX=[]; let activeVoices=[];
  function degreeToFreq(deg,oct=0){ const arr=scales[scaleName]; const idx=((deg%arr.length)+arr.length)%arr.length; const semi=arr[idx]+12*oct; return 440*Math.pow(2,((root-69)+semi)/12); }

  async function audioInit(){ if(AC) return true; try{ const C=window.AudioContext||window.webkitAudioContext; if(!C){ toast('AudioContext unsupported'); return false; } AC=new C(); master=AC.createGain(); master.gain.value=.18; master.connect(AC.destination); const rv=AC.createConvolver(); rv.buffer=(function IR(sec=2.1,decay=3){const rate=AC.sampleRate,len=rate*sec,buf=AC.createBuffer(2,len,rate);for(let ch=0;ch<2;ch++){const d=buf.getChannelData(ch);for(let i=0;i<len;i++){d[i]=(Math.random()*2-1)*Math.pow(1-i/len,decay);}}return buf;})(); wet=AC.createGain(); dry=AC.createGain(); wet.gain.value=.22; dry.gain.value=.78; wet.connect(rv).connect(master); dry.connect(master); return true; }catch(e){ console.error(e); toast('Audio init failed'); return false; } }

  function mkEnv(){ const e=AC.createGain(); e.gain.value=0; return e; }
  function mkFilter(type='lowpass'){ const f=AC.createBiquadFilter(); f.type=type; f.frequency.value=1200; f.Q.value=0.8; return f; }
  function noiseBuf(){ const b=AC.createBuffer(1, AC.sampleRate*1, AC.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; return b; }
  function laneProcessors(){ const lanes=[]; for(let i=0;i<GRID.rows;i++){ const sat=AC.createWaveShaper(); const curve=new Float32Array(512); for(let j=0;j<512;j++){ const x=j/511*2-1; curve[j]=Math.tanh(2.2*x);} sat.curve=curve; const laneDry=AC.createGain(); const laneWet=AC.createGain(); laneWet.gain.value=.2; laneDry.gain.value=.8; const pan=AC.createStereoPanner(); pan.pan.value=0; const pre=AC.createGain(); pre.connect(sat); sat.connect(laneDry).connect(dry); sat.connect(laneWet).connect(wet); laneDry.connect(pan).connect(master); laneWet.connect(pan).connect(master); lanes.push({pre,sat,laneDry,laneWet,pan}); } return lanes; }

  function buildKick(dest){ const o=AC.createOscillator(); o.type='sine'; const g=mkEnv(); const f=mkFilter('lowpass'); o.connect(f).connect(g).connect(dest.pre); o.start(); return {start(v){ const t=AC.currentTime; o.frequency.setValueAtTime(120,t); o.frequency.exponentialRampToValueAtTime(40,t+0.08); g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.9*Math.min(1,v/2), t+0.005); g.gain.exponentialRampToValueAtTime(0.0001, t+0.28); }}}
  function buildSnare(dest){ const n=AC.createBufferSource(); n.buffer=noiseBuf(); n.loop=true; const g=mkEnv(); const hp=mkFilter('highpass'); hp.frequency.value=1800; n.connect(hp).connect(g).connect(dest.pre); n.start(); return {start(v){ const t=AC.currentTime; g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.7*(v/3+0.5), t+0.005); g.gain.exponentialRampToValueAtTime(0.0001, t+0.18); }}}
  function buildHat(dest){ const n=AC.createBufferSource(); n.buffer=noiseBuf(); n.loop=true; const g=mkEnv(); const hp=mkFilter('highpass'); hp.frequency.value=6000; n.connect(hp).connect(g).connect(dest.pre); n.start(); return {start(v){ const t=AC.currentTime; g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.4*(0.5+v/3), t+0.002); g.gain.exponentialRampToValueAtTime(0.0001, t+0.06); }}}
  function buildMono(dest,osc='sawtooth'){ const o=AC.createOscillator(); o.type=osc; const f=mkFilter('lowpass'); const g=mkEnv(); o.connect(f).connect(g).connect(dest.pre); o.start(); return {o,f,g,start(freq,vel=.6,decay=.2,shape=0.6){ const t=AC.currentTime; o.frequency.setTargetAtTime(freq,t,0.02); const bright=800 + 2600*shape; f.frequency.setTargetAtTime(bright,t,0.03); g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(g.gain.value,t); g.gain.linearRampToValueAtTime(vel, t+0.01); g.gain.exponentialRampToValueAtTime(0.0001, t+decay); }}}
  function buildChord(dest){ const gain=mkEnv(); gain.connect(dest.pre); const make=(det=0)=>{ const o=AC.createOscillator(); o.type='triangle'; o.detune.value=det; const f=mkFilter('lowpass'); o.connect(f).connect(gain); o.start(); return {o,f}; }; const a=make(-7), b=make(0), c=make(7); return {start(rootHz,vel=.4,shape=0.6){ const t=AC.currentTime; const thirds=[0,3,4]; const r=rootHz; const fA=r*Math.pow(2,thirds[(progressionIdx%thirds.length)]/12); const fB=r*Math.pow(2,7/12); a.o.frequency.setTargetAtTime(fA,t,0.02); b.o.frequency.setTargetAtTime(r,t,0.02); c.o.frequency.setTargetAtTime(fB,t,0.02); [a.f,b.f,c.f].forEach(f=>f.frequency.setTargetAtTime(900+shape*1800,t,0.04)); gain.gain.cancelScheduledValues(t); gain.gain.setValueAtTime(gain.gain.value,t); gain.gain.linearRampToValueAtTime(vel, t+0.03); gain.gain.exponentialRampToValueAtTime(0.0001, t+0.5); }}}

  function buildVoices(){ if(!AC || activeVoices.length) return; const fx=laneProcessors(); for(let i=0;i<GRID.rows;i++) laneFX[i]=fx[i];
    activeVoices=[
      buildKick(laneFX[0]), buildSnare(laneFX[1]), buildHat(laneFX[2]),
      buildMono(laneFX[3],'sawtooth'), buildChord(laneFX[4]),
      buildMono(laneFX[5],'square'), buildMono(laneFX[6],'triangle'), buildMono(laneFX[7],'sine')
    ];
  }

  /* Row state */
  const ROWCTL=Array.from({length:GRID.rows},(_,r)=>({row:r, sync:true, swing:0, octave:.5, chorus:.1, evo:false,
    en:1,lvl:.7,send:.25,width:.5,prob:1,shape:.6 }));

  /* Presets & Packs */
  const PRESETS={
    BASIC: (p)=>{ for(let r=0;r<GRID.rows;r++){ for(let c=0;c<GRID.cols;c++){ p[r][c]= (r<3? (c%4===0?1:0) : (Math.random()<0.2?1:0)); } } },
    HOUSE: (p)=>{ for(let c=0;c<GRID.cols;c++){ p[0][c]=(c%4===0)?2:0; p[1][c]=(c%8===4)?2:0; p[2][c]= (c%2===1)?1:0; } },
    DNB:   (p)=>{ for(let c=0;c<GRID.cols;c++){ p[0][c]=(c%8===0)?3:0; p[1][c]=(c%8===4)?3:0; p[2][c]= (c%2===0)?1:0; } }
  };
  const PACKS=[{name:'TAPE', bass:'sawtooth', lead:'triangle', perc:'square'},
               {name:'FMISH',bass:'square',  lead:'square',   perc:'square'},
               {name:'GRAN', bass:'triangle',lead:'sine',     perc:'triangle'},
               {name:'BIT',  bass:'square',  lead:'sawtooth', perc:'square'},
               {name:'WAVE', bass:'sawtooth',lead:'sawtooth', perc:'triangle'}];
  let packIdx=0; function applyPack(i){ packIdx=((i%PACKS.length)+PACKS.length)%PACKS.length; const P=PACKS[packIdx]; if(activeVoices[3]?.o) activeVoices[3].o.type=P.bass; if(activeVoices[5]?.o) activeVoices[5].o.type=P.lead; if(activeVoices[6]?.o) activeVoices[6].o.type=P.perc; if(activeVoices[7]?.o) activeVoices[7].o.type='sine'; toast('Pack: '+P.name); }

  function loadPreset(name='BASIC'){ const fn=PRESETS[name]||PRESETS.BASIC; fn(pattern); toast('Preset: '+name); }
  function evolveRow(r){ const bar=ROWCTL[r]; if(!bar.evo) return; for(let c=0;c<GRID.cols;c++){ if(Math.random()<0.06){ pattern[r][c] = (pattern[r][c]+1)%4; } } }

  /* Clock */
  function startClock(){ let last=performance.now(); (function loop(){ const beat=60000/bpm; const stepDur=beat/4; const now=performance.now(); if(playing && AC && AC.state==='running'){ if(now-last>=stepDur){ last=now; tick(); } } requestAnimationFrame(loop); })(); }

  function moveCursor(){ const x0=GRID.origin.x; GRID.cursor.position.x = x0 + step*GRID.gapX; }
  function shouldFire(row){ const en=ROWCTL[row].en>0.1; if(!en) return false; const p=ROWCTL[row].prob; return Math.random()<=p; }
  function trig(row,vel){ if(!activeVoices.length) return; const bar=ROWCTL[row]; const send=bar.send; const width=(bar.width-0.5)*2; const shape=bar.shape; const octAdj=Math.round((bar.octave*2)-2);
    laneFX[row].laneWet.gain.setTargetAtTime(send, AC.currentTime, 0.05);
    laneFX[row].laneDry.gain.setTargetAtTime(1-send, AC.currentTime, 0.05);
    laneFX[row].pan.pan.setTargetAtTime((row-3.5)/3.5 * width, AC.currentTime, 0.05);
    const V=Math.max(0,Math.min(3,vel))/3; const velGain=0.2+0.8*V; const rowGain=0.15+0.85*bar.lvl; const vfinal=velGain*rowGain;
    const cell=GRID.cells[row][step]; cell.userData.pulse(V);
    const degShift = (bar.sync? 0 : Math.round(bar.swing*2));
    switch(row){
      case 0: activeVoices[0].start(1+V*2); break;
      case 1: activeVoices[1].start(1+V*2); break;
      case 2: activeVoices[2].start(1+V*2); break;
      case 3: { const deg=(step%4)*2 + (progression[progressionIdx%progression.length]) + degShift; const f=degreeToFreq(deg, -1+octAdj); activeVoices[3].start(f*(1+bar.chorus*0.02), vfinal, 0.18+0.04*V, shape); } break;
      case 4: { const deg=progression[progressionIdx%progression.length] + degShift; const f=degreeToFreq(deg, 0+octAdj); activeVoices[4].start(f, vfinal, shape); } break;
      case 5: { const deg=(step%7) + degShift; const f=degreeToFreq(deg, 1+octAdj); activeVoices[5].start(f*(1-bar.chorus*0.02), vfinal, 0.16+0.05*V, shape); } break;
      case 6: { const deg=((step*3)%5) + degShift; const f=degreeToFreq(deg, 0+octAdj); activeVoices[6].start(f, vfinal, 0.1+0.05*V, shape); } break;
      case 7: { const f=degreeToFreq((step%5) + degShift, 2+octAdj); activeVoices[7].start(f, vfinal, 0.2, shape); } break;
    }
  }

  function tick(){ step=(step+1)%GRID.cols; if(step%4===0) progressionIdx=(progressionIdx+1)%progression.length; moveCursor(); for(let r=0;r<GRID.rows;r++){ evolveRow(r); const v=pattern[r][step]; if(v>0 && shouldFire(r)) trig(r,v); } }

  /* ===== Picking + Cell Focus ===== */
  const ray=new THREE.Raycaster(); const v2=new THREE.Vector2();
  function pickAt(x,y){ v2.x=(x/innerWidth)*2-1; v2.y=-(y/innerHeight)*2+1; ray.setFromCamera(v2,camera); const objs=[]; GRID.cells.forEach(row=>row.forEach(s=>objs.push(...s.children))); return ray.intersectObjects(objs); }

  let pressTimer=null, pressedCell=null, draggingCam=null, pinch=null;
  let selected={row:null,col:null, node:null, scale:1};

  const cellHUD=document.getElementById('cellHUD');
  const cellPanel=document.getElementById('cellPanel');

  function screenFromWorld(vec3){ const v=vec3.clone().project(camera); return { x:(v.x*0.5+0.5)*innerWidth, y:(-v.y*0.5+0.5)*innerHeight } }

  function updateCellHUDPos(){ if(!selected.node) return; const p=selected.node.position.clone(); p.y+=5; const s=screenFromWorld(p); cellHUD.style.left=(s.x-120)+"px"; cellHUD.style.top=(s.y-60)+"px"; }

  function dimOthers(on){ GRID.cells.forEach((row,r)=> row.forEach((g,c)=>{ g.children.forEach(m=>{ m.material.opacity = (on && !(selected.row===r && selected.col===c)) ? 0.08 : Math.max(m.material.opacity, 0.18); }); })); }

  function focusCameraTo(target, newDist=110, ms=220){
    const start={x:camera.position.x,y:camera.position.y,z:camera.position.z,d:dist};
    const yaw=Math.atan2(camera.position.z,camera.position.x);
    const goal={d:newDist, y:60, yaw:Math.atan2(target.z,target.x)+0.0001};
    const t0=performance.now();
    function step(){ const t=Math.min(1,(performance.now()-t0)/ms); const k=0.5-0.5*Math.cos(Math.PI*t);
      dist = start.d + (goal.d-start.d)*k;
      const y = start.y + (goal.y-start.y)*k;
      const yy = y; const ang = start.yaw + (goal.yaw-start.yaw)*k;
      camera.position.set(Math.cos(ang)*dist, yy, Math.sin(ang)*dist); camTarget.copy(target); look(); if(t<1) requestAnimationFrame(step);
    } requestAnimationFrame(step);
  }

  function buildCellPanel(r,c){ cellPanel.innerHTML=''; const mk=(id,label)=>{ const d=document.createElement('div'); d.className='mini'; d.textContent=label; d.dataset.id=id; return d; };
    const cells=[mk('v0','V0'),mk('v1','V1'),mk('v2','V2'),mk('v3','V3'),mk('clr','Ø')];
    const rowQuick=[mk('sync','SY'),mk('sw-','S-'),mk('sw+','S+'),mk('oc-','O-'),mk('oc+','O+')];
    const rowQuick2=[mk('ch-','C-'),mk('ch+','C+'),mk('evo','EV'),mk('p+','P+'),mk('p-','P-')];
    [...cells, ...rowQuick, ...rowQuick2].forEach(b=> cellPanel.appendChild(b));
    cellPanel.querySelectorAll('.mini').forEach(b=> b.addEventListener('click',()=> onCellPanel(b.dataset.id,r,c)));
  }

  function onCellPanel(id,r,c){
    // velocity & clear
    if(id==='v0'||id==='v1'||id==='v2'||id==='v3'){ const v=parseInt(id.slice(1),10); pattern[r][c]=v; selected.node.userData.active=v; selected.node.userData.pulse(v/3); buzz(6); return; }
    if(id==='clr'){ pattern[r][c]=0; selected.node.userData.active=0; selected.node.userData.pulse(0); buzz(4); return; }
    // row quick params
    const B=ROWCTL[r]; if(!B) return;
    if(id==='sync'){ B.sync=!B.sync; toast('R'+(r+1)+' SYNC '+(B.sync?'ON':'OFF')); return; }
    if(id==='evo'){ B.evo=!B.evo; toast('R'+(r+1)+' EVO '+(B.evo?'ON':'OFF')); return; }
    if(id==='sw+'||id==='sw-'){ const d=(id.endsWith('+')? +.1 : -.1); B.swing=Math.max(-1,Math.min(1, B.swing + d)); toast('SWG '+B.swing.toFixed(2)); return; }
    if(id==='oc+'||id==='oc-'){ const d=(id.endsWith('+')? +.1 : -.1); B.octave=Math.max(0,Math.min(1, B.octave + d)); toast('OCT '+B.octave.toFixed(2)); return; }
    if(id==='ch+'||id==='ch-'){ const d=(id.endsWith('+')? +.1 : -.1); B.chorus=Math.max(0,Math.min(1, B.chorus + d)); toast('CHO '+B.chorus.toFixed(2)); return; }
    if(id==='p+'||id==='p-'){ const d=(id.endsWith('+')? +.1 : -.1); B.prob=Math.max(0,Math.min(1, B.prob + d)); toast('PRB '+B.prob.toFixed(2)); return; }
  }

  function selectCell(r,c){
    if(selected.node){ selected.node.scale.set(1,1,1); selected.node.position.y = 0; }
    selected.row=r; selected.col=c; selected.node=GRID.cells[r][c];
    selected.node.scale.set(1.35,1,1.35); selected.node.position.y = 1.2;
    dimOthers(true);
    const target=new THREE.Vector3(selected.node.position.x,8, selected.node.position.z);
    focusCameraTo(target, Math.max(90, dist*0.72), 240);
    buildCellPanel(r,c); cellHUD.style.display='block'; updateCellHUDPos();
  }

  function clearSelection(){ if(selected.node){ selected.node.scale.set(1,1,1); selected.node.position.y=0; } selected={row:null,col:null,node:null,scale:1}; dimOthers(false); cellHUD.style.display='none'; }

  // Helper used by row menus
  function openRow(r){ const z=GRID.origin.z + r*GRID.gapZ; const target=new THREE.Vector3(0,8,z); focusCameraTo(target, Math.max(90, dist*0.85), 220); toast('Row '+(r+1)); }

  canvas.addEventListener('pointerdown',e=>{
    const hits=pickAt(e.clientX,e.clientY); if(!hits.length){
      draggingCam={x:e.clientX,y:e.clientY, yaw:Math.atan2(camera.position.z,camera.position.x), pitch:Math.asin((camera.position.y-50)/dist)}; return; }
    const parent=hits[0].object.parent; if(parent.userData.rc){ const [r,c]=parent.userData.rc; pressedCell=parent; selectCell(r,c); buzz(8);
      pressTimer=setTimeout(()=>{ pattern[r][c]=3; parent.userData.active=3; parent.userData.pulse(1); toast('R'+(r+1)+'@'+(c+1)+' vel3'); },420); }
  });
  addEventListener('pointermove',e=>{ if(draggingCam){ const dx=e.clientX-draggingCam.x; const dy=e.clientY-draggingCam.y; const yaw=draggingCam.yaw - dx*0.005; const pitch=Math.max(-1.15,Math.min(1.15, draggingCam.pitch - dy*0.003)); const cx=Math.cos(yaw)*dist, cz=Math.sin(yaw)*dist, cy=50+Math.sin(pitch)*70; camera.position.set(cx,cy,cz); look(); updateCellHUDPos(); }});
  addEventListener('pointerup',()=>{ if(pressedCell){ clearTimeout(pressTimer); const [r,c]=pressedCell.userData.rc; if(pattern[r][c]===0){ pattern[r][c]=1; } else if(pattern[r][c]===1){ pattern[r][c]=2; } else if(pattern[r][c]===2){ pattern[r][c]=0; } pressedCell.userData.active=pattern[r][c]; pressedCell.userData.pulse(pattern[r][c]/3); pressedCell=null; }
    draggingCam=null; });
  addEventListener('touchstart',e=>{ if(e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX; const dy=e.touches[0].clientY-e.touches[1].clientY; pinch={d:Math.hypot(dx,dy)}; } },{passive:false});
  addEventListener('touchmove',e=>{ if(pinch && e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX; const dy=e.touches[0].clientY-e.touches[1].clientY; const nd=Math.hypot(dx,dy); const k=nd/(pinch.d||1); pinch.d=nd; dist=Math.max(90,Math.min(460, dist/(k||1))); e.preventDefault(); updateCellHUDPos(); } },{passive:false});
  addEventListener('touchend',()=>{ pinch=null; });

  /* ===== DENSITY SWITCH (always symmetric) ===== */
  function setDensity(n){
    const map={16:[8,16],8:[8,8],4:[4,4],2:[2,2],1:[1,1]}; const [r,c]=map[n]||[8,16]; GRID.rows=r; GRID.cols=c; buildGrid(); refreshLayout(); toast(`${r}×${c}`); }

  document.querySelectorAll('#densityStack .mini').forEach(el=>{
    el.addEventListener('click',()=>{ setDensity(parseInt(el.dataset.density,10)); buzz(6); });
  });

  /* ===== PACKS / PRESETS ===== */
  document.querySelectorAll('#packStack .mini').forEach(el=>{
    el.addEventListener('click',()=>{ if(el.dataset.pack==='prev') applyPack(--packIdx); else applyPack(++packIdx); buzz(6); });
  });
  document.querySelectorAll('#presetStack .mini').forEach(el=>{
    el.addEventListener('click',()=>{ loadPreset(el.dataset.pre); buzz(6); });
  });

  /* ===== TRANSPORT / CAMERA ===== */
  const viewHUD=document.getElementById('viewHUD');
  const VIEWS=[{name:'FRONT',pos:[0,60,dist]},{name:'ISO L',pos:[-dist*0.8,80,dist*0.6]},{name:'ISO R',pos:[dist*0.8,80,dist*0.6]},{name:'TOP',pos:[0,240,0.01]},{name:'WIDE',pos:[dist*1.3,90,0]}];
  function applyView(i){ const v=VIEWS[(i%VIEWS.length+VIEWS.length)%VIEWS.length]; camera.position.set(...v.pos); look(); viewHUD.textContent=v.name; }

  document.getElementById('btnStart').addEventListener('click', async ()=>{
    if(!AC){ const ok=await audioInit(); if(!ok) return; try{ if(AC.state==='suspended') await AC.resume(); }catch{} buildVoices(); startClock(); loadPreset('BASIC'); }
    playing=!playing; (document.getElementById('btnStart')).setAttribute('aria-pressed', String(playing)); toast(playing?'Play':'Pause'); buzz(10);
  });
  document.getElementById('btnOrbit').addEventListener('click',()=>{ orbit=!orbit; document.getElementById('btnOrbit').textContent=orbit?'●':'○'; buzz(6); });
  document.getElementById('btnFit').addEventListener('click',()=>{ fitCameraToGrid(); buzz(6); });
  document.getElementById('btnZoomIn').addEventListener('click',()=>{ dist=Math.max(80,dist-15); const yaw=Math.atan2(camera.position.z,camera.position.x); camera.position.set(Math.cos(yaw)*dist, camera.position.y, Math.sin(yaw)*dist); look(); buzz(6); });
  document.getElementById('btnZoomOut').addEventListener('click',()=>{ dist=Math.min(460,dist+15); const yaw=Math.atan2(camera.position.z,camera.position.x); camera.position.set(Math.cos(yaw)*dist, camera.position.y, Math.sin(yaw)*dist); look(); buzz(6); });
  document.getElementById('btnPaper').addEventListener('click',()=>{ document.body.classList.toggle('mono'); buzz(4); });
  document.querySelectorAll('#viewStack .mini').forEach(el=> el.addEventListener('click',()=>{ applyView(parseInt(el.dataset.view,10)); buzz(6); }));

  /* ===== Alley Rail: Cascading stack-of-stacks panels ===== */
  // Ensure containers exist even if hidden
  let cascade=document.getElementById('cascade');
  if(!cascade){ cascade=document.createElement('div'); cascade.id='cascade'; document.getElementById('hud').appendChild(cascade); }
  const rail=document.getElementById('alleyRail');

  const panelStack=[]; // DOM panels stack
  function closeTop(){ const p=panelStack.pop(); if(p){ p.classList.remove('on'); setTimeout(()=>p.remove(),140); }}
  function closeAll(){ while(panelStack.length) closeTop(); }
  function spawnPanel(side='center', title='Menu', items=[], onPick=(id)=>{}){
    const p=document.createElement('div'); p.className='stackPanel';
    const centerX=innerWidth/2; // default center spawn above alley
    const px = (side==='left')? (centerX - 220) : (side==='right')? (centerX + 20) : (centerX - 100);
    p.style.left = Math.max(8, Math.min(innerWidth-8-260, px)) + 'px';
    p.innerHTML = `<div class="cap">${title}</div><div class="crumbs">${panelStack.map(c=>`<span class='crumb'>${c.dataset.title}</span>`).join('')}</div>`;
    items.forEach(it=>{ const b=document.createElement('div'); b.className='mini'; b.textContent=it.label; b.title=it.title||it.label; b.dataset.id=it.id; b.addEventListener('click',()=> onPick(it.id, it)); p.appendChild(b); });
    p.dataset.title=title; cascade.appendChild(p); requestAnimationFrame(()=> p.classList.add('on'));
    panelStack.push(p); return p;
  }

  // Row → pick a row → open tuning submenu (SWG/OCT/CHO/EVO)
  function openRowMenu(){ closeAll(); const side=(innerWidth<700? 'left':'left');
    const rowItems = Array.from({length:GRID.rows},(_,i)=>({id:'row'+i,label:String(i+1)}));
    spawnPanel(side,'ROW',rowItems,(id)=>{ const r=parseInt(id.replace('row',''),10); openRow(r); openRowTuning(r); });
  }
  function openRowTuning(r){ const side=(innerWidth<700? 'right':'right');
    const items=[{id:'sync',label:'SYNC'},{id:'swing',label:'SWG'},{id:'oct',label:'OCT'},{id:'chor',label:'CHO'},{id:'evo',label:'EVO'}];
    spawnPanel(side,`R${r+1}`,items,(id)=>{
      if(id==='sync'||id==='evo'){ document.body.dispatchEvent(new CustomEvent('stack:setRow',{detail:{row:r,key:id}})); }
      else { openDial(r,id); }
    });
  }
  function openDial(r,key){ const side=(innerWidth<700? 'left':'left');
    const vals=[0,0.25,0.5,0.75,1].map((v,i)=>({id:'v'+i,label:String(i+1)}));
    spawnPanel(side, key.toUpperCase(), vals,(vid)=>{ const idx=parseInt(vid.slice(1),10); const v=[0,.25,.5,.75,1][idx]; document.body.dispatchEvent(new CustomEvent('stack:setRow',{detail:{row:r,key,value:v}})); });
  }

  // Grid → density, presets
  function openGridMenu(){ closeAll(); const leftItems=[{id:'d16',label:'16'},{id:'d8',label:'8'},{id:'d4',label:'4'},{id:'d2',label:'2'},{id:'d1',label:'1'}];
    spawnPanel('left','DENS',leftItems,(id)=>{ const n=parseInt(id.slice(1),10); setDensity(n); });
    const rightItems=[{id:'BASIC',label:'B'},{id:'HOUSE',label:'H'},{id:'DNB',label:'D'}];
    spawnPanel('right','PRE',rightItems,(id)=> loadPreset(id));
  }

  // Mix → master & FX quick dials
  function openMixMenu(){ closeAll(); const items=[{id:'rv-',label:'RV-'},{id:'rv+',label:'RV+'},{id:'vol-',label:'VOL-'},{id:'vol+',label:'VOL+'}];
    spawnPanel('right','MIX',items,(id)=>{
      if(!AC||!master||!wet) return; if(id==='rv-') wet.gain.value=Math.max(0,wet.gain.value-0.05);
      if(id==='rv+') wet.gain.value=Math.min(1,wet.gain.value+0.05);
      if(id==='vol-') master.gain.value=Math.max(0,master.gain.value-0.03);
      if(id==='vol+') master.gain.value=Math.min(1,master.gain.value+0.03);
      toast(`RV ${wet?.gain.value.toFixed(2)||0} VOL ${master?.gain.value.toFixed(2)||0}`);
    });
  }

  if(rail){
    rail.querySelector('[data-rail="row"]')?.addEventListener('click',openRowMenu);
    rail.querySelector('[data-rail="grid"]')?.addEventListener('click',openGridMenu);
    rail.querySelector('[data-rail="mix"]')?.addEventListener('click',openMixMenu);
  }

  // Bridge: apply row param changes emitted by dial panels
  document.body.addEventListener('stack:setRow',(e)=>{
    const {row,key,value}=e.detail; if(row==null) return; const b=ROWCTL[row]; if(!b) return;
    if(key==='sync'){ b.sync=!b.sync; toast(`R${row+1} SYNC ${b.sync?'ON':'OFF'}`); return; }
    if(key==='evo'){ b.evo=!b.evo; toast(`R${row+1} EVO ${b.evo?'ON':'OFF'}`); return; }
    if(typeof value==='number'){
      if(key==='swing') b.swing = value*2-1;
      if(key==='oct')   b.octave = value;
      if(key==='chor')  b.chorus = value;
      toast(`R${row+1} ${key.toUpperCase()} ${(value).toFixed(2)}`);
    }
  });

  /* ===== Resize (fixed malformed braces) ===== */
  addEventListener('resize',()=>{
    camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(innerWidth,innerHeight);
    autoSpacing(); refreshLayout(); updateCellHUDPos();
  });

  /* ===== Animation loop ===== */
  function animate(){
    requestAnimationFrame(animate);
    if(orbit){ const yaw=Math.atan2(camera.position.z,camera.position.x)+0.004; camera.position.x=Math.cos(yaw)*dist; camera.position.z=Math.sin(yaw)*dist; camera.position.y=60+Math.sin(yaw*0.6)*20; look(); }
    updateCellHUDPos(); renderer.render(scene,camera);
  } animate();

  /* ===== Quick QA toggles (debug keys) ===== */
  addEventListener('keydown',(e)=>{
    if(e.key==='g'){ GRID.labels.forEach(s=> s.visible=!s.visible); toast('Labels: '+(GRID.labels[0].visible?'ON':'OFF')); }
    if(e.key==='c'){ GRID.cursor.visible=!GRID.cursor.visible; toast('Cursor: '+(GRID.cursor.visible?'ON':'OFF')); }
    if(e.key==='a'){ const A=document.getElementById('alley'); A && (A.style.display = (A.style.display==='none'?'block':'none')); }
  });
})();
</script>
<script>
// === Sanity tests (keep original and add a few more) ===
try{
  const tests=[]; const ok=(n,p)=>tests.push({test:n,pass:!!p});
  ok('#toast exists once', document.querySelectorAll('#toast').length===1);
  ok('#toast fixed', getComputedStyle(document.getElementById('toast')).position==='fixed');
  ok('openRow defined', typeof window.openRow==='function');
  try{ window.dispatchEvent(new Event('resize')); ok('resize dispatch ok', true);}catch(e){ ok('resize dispatch ok', false); }
  console.table(tests);
}catch(e){ console.warn('tests fail', e); }
</script>
</body>
</html>
