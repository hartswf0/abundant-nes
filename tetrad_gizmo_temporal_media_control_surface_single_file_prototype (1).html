<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Tetrahedron — Tetrad Control (Layers · Haptics · Media)</title>
<style>
  :root{ --bg:#06080f; --fg:#eaf0ff; --muted:#8fa0b8; --a:#7cc7ff; --b:#78ffd7; --c:#ffcc66; --danger:#ff6b6b; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1000px 1000px at 50% 12%, #0a1120 0%, #06080f 55%, #04060b 100%);color:var(--fg);font:500 14px/1.45 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial}
  .app{height:100%;display:grid;grid-template-rows:auto 1fr}
  header{padding:12px 16px calc(env(safe-area-inset-top) + 6px);text-align:center;color:var(--muted)}
  header b{color:var(--fg)}
  #c{width:100%;height:100%;display:block;touch-action:none}

  /* Minimal media panel (invoked by long‑press on a face) */
  .media{position:fixed;left:16px;right:16px;bottom:calc(env(safe-area-inset-bottom) + 16px);max-width:720px;margin:0 auto;padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.12);background:rgba(0,0,0,.38);backdrop-filter:blur(10px);box-shadow:0 10px 30px rgba(0,0,0,.35);display:none}
  .media.open{display:block}
  .media header{display:flex;align-items:center;justify-content:space-between;color:#ddd;font-size:13px;margin-bottom:6px}
  .tray{display:flex;gap:10px;overflow:auto;padding-bottom:6px}
  .chip{border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);border-radius:10px;padding:6px 10px;font-size:12px;color:#ddd;white-space:nowrap;cursor:pointer}
  .viewer{display:flex;align-items:center;justify-content:center;max-height:36vh;border-radius:10px;overflow:hidden;border:1px solid rgba(255,255,255,.12);background:#000}
  .viewer img{max-width:100%;height:auto}
  .viewer video{max-width:100%;max-height:36vh}
  .viewer audio{width:100%}
  .hint{position:fixed;left:0;right:0;top:12px;text-align:center;color:var(--muted);font-size:12px;pointer-events:none}
</style>
</head>
<body>
<div class="app" role="application" aria-label="Tetrahedron tetrad controller">
  <header><b>Tetrahedron</b> · Tetrad-as-control · Rings = Enhance · Edges = Obsolesce · Face-swipe = Retrieve · Vertex press = Reverse</header>
  <canvas id="c" aria-label="Tetrahedron canvas"></canvas>
</div>

<!-- Embedded media panel -->
<div id="media" class="media" role="dialog" aria-modal="false" aria-label="Media viewer">
  <header>
    <div id="mediaTitle">Face • Layer Media</div>
    <button id="mediaClose" class="chip" aria-label="Close">Close ✕</button>
  </header>
  <div class="viewer" id="mediaViewer"></div>
  <div class="tray" id="mediaTray"></div>
</div>

<script>
(() => {
  // ===== Canvas setup =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  function resize(){ const w=canvas.clientWidth, h=canvas.clientHeight; canvas.width=w*DPR; canvas.height=h*DPR; ctx.setTransform(DPR,0,0,DPR,0,0);} 
  new ResizeObserver(resize).observe(canvas);

  // ===== State mapped to tetrad =====
  const state = {
    t:0, running:true,
    enhance:1.0,     // speed/complexity multiplier (Rings)
    obsolesce:0.0,   // edge fade (Edges)
    reverse:false,   // direction flip (Vertices)
    retrieve:0.0,    // phase scrub 0..1 (Face swipe)
    layers:8,        // number of concentric layer-rings per face
    activeFace:null, // 'E' | 'Ø' | '⟲' | '↯'
  };

  // ===== Tet geometry =====
  const V = [ [ 1, 1, 1], [ 1,-1,-1], [-1, 1,-1], [-1,-1, 1] ];
  const F = [ [0,1,2,'E'], [0,3,1,'Ø'], [0,2,3,'⟲'], [1,3,2,'↯'] ];
  function rotX(p,a){ const s=Math.sin(a), c=Math.cos(a); const [x,y,z]=p; return [x, c*y-s*z, s*y+c*z]; }
  function rotY(p,a){ const s=Math.sin(a), c=Math.cos(a); const [x,y,z]=p; return [ c*x+s*z, y, -s*x+c*z]; }
  function rotZ(p,a){ const s=Math.sin(a), c=Math.cos(a); const [x,y,z]=p; return [ c*x-s*y, s*x+c*y, z]; }
  function project(p, w, h, fov=600){ const [x,y,z]=p; const d=fov/(fov - z*120); return [w/2 + x*120*d, h/2 + y*120*d, d]; }
  function centroid(a,b,c){ return [(a[0]+b[0]+c[0])/3,(a[1]+b[1]+c[1])/3,(a[2]+b[2]+c[2])/3]; }
  function normal(a,b,c){ const u=[b[0]-a[0],b[1]-a[1],b[2]-a[2]], v=[c[0]-a[0],c[1]-a[1],c[2]-a[2]]; return [u[1]*v[2]-u[2]*v[1], u[2]*v[0]-u[0]*v[2], u[0]*v[1]-u[1]*v[0]]; }
  function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}
  function lerp(a,b,t){return a+(b-a)*t}

  let rings2D=[], edges2D=[], verts2D=[];

  // ===== Audio (simple) =====
  let audioCtx, osc, gain; function ensureAudio(){ if(audioCtx) return; audioCtx=new (window.AudioContext||window.webkitAudioContext)(); osc=audioCtx.createOscillator(); gain=audioCtx.createGain(); osc.type='triangle'; osc.frequency.value=140; gain.gain.value=0.0; osc.connect(gain).connect(audioCtx.destination); osc.start(); }
  function blip(hz=220, vol=0.04, t=0.06){ if(!audioCtx) return; osc.frequency.setTargetAtTime(hz,audioCtx.currentTime,0.01); gain.gain.setTargetAtTime(vol,audioCtx.currentTime,0.005); gain.gain.setTargetAtTime(0.0,audioCtx.currentTime+Math.max(0.02,t),0.05); }
  function haptic(ms=18){ if(navigator.vibrate) navigator.vibrate(ms); }

  // ===== Media registry per face/layer =====
  // Replace sample URLs as needed; long‑press a face to open panel.
  const MEDIA = {
    'E': {
      0: [{type:'audio', url:'https://cdn.pixabay.com/download/audio/2022/03/15/audio_6f0b6bdb5b.mp3?filename=ui-confirmation-96974.mp3', title:'UI blip'}],
    },
    'Ø': {
      0: [{type:'image', url:'https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/Daguerreotype-portrait.jpg/512px-Daguerreotype-portrait.jpg', title:'Daguerreotype'}],
    },
    '⟲': {
      0: [{type:'video', url:'https://interactive-examples.mdn.mozilla.net/media/cc0-videos/flower.mp4', title:'Looping Flower'}],
    },
    '↯': {
      0: [{type:'audio', url:'https://cdn.pixabay.com/download/audio/2022/03/10/audio_7a3e2e1f2b.mp3?filename=error-126627.mp3', title:'Reverse cue'}],
    }
  };

  // ===== Render =====
  function draw(){
    const w=canvas.clientWidth, h=canvas.clientHeight;
    ctx.clearRect(0,0,w,h);
    const bg=ctx.createRadialGradient(w/2,h*0.3,12,w/2,h/2,Math.max(w,h)*0.9); bg.addColorStop(0,'#0b1528'); bg.addColorStop(1,'#06080f'); ctx.fillStyle=bg; ctx.fillRect(0,0,w,h);

    const sgn = state.reverse ? -1 : 1;
    const phase = (state.t*0.6*state.enhance*sgn + state.retrieve*Math.PI*2);
    const tv = V.map(p => rotZ(rotY(rotX(p, phase*0.6), phase*0.9), phase*0.3));
    const pv = tv.map(p => project(p,w,h));

    // collect edges & vertices for picking
    edges2D = [];
    verts2D = [];

    // faces painter order
    const faces = F.map(([i,j,k,label])=>{
      const c3=centroid(tv[i],tv[j],tv[k]); const n=normal(tv[i],tv[j],tv[k]);
      const depth=(tv[i][2]+tv[j][2]+tv[k][2])/3; const lit=Math.max(0.1, 0.5 + 0.5*dot(n,[0,0,1])/(Math.hypot(...n)||1));
      const cp=centroid(pv[i],pv[j],pv[k]); return {i,j,k,label,depth,lit,cp};
    }).sort((a,b)=>a.depth-b.depth);

    rings2D.length=0;

    for(const f of faces){
      const a=pv[f.i], b=pv[f.j], c=pv[f.k];
      // face fill
      ctx.beginPath(); ctx.moveTo(a[0],a[1]); ctx.lineTo(b[0],b[1]); ctx.lineTo(c[0],c[1]); ctx.closePath();
      const alpha=0.85*(1-state.obsolesce); const grad=ctx.createLinearGradient(a[0],a[1],c[0],c[1]); grad.addColorStop(0,`rgba(124,199,255,${0.12*f.lit})`); grad.addColorStop(1,`rgba(120,255,215,${0.10*f.lit})`);
      ctx.fillStyle=`rgba(255,255,255,${alpha*0.08})`; ctx.fill(); ctx.fillStyle=grad; ctx.fill();
      // edges (collect and draw thicker for interaction affordance)
      const Elist=[[a,b],[b,c],[c,a]]; ctx.lineWidth=1.6; ctx.strokeStyle=`rgba(200,225,255,${0.65*(1-state.obsolesce)})`; ctx.stroke();
      for(const [p1,p2] of Elist){ edges2D.push({x1:p1[0],y1:p1[1],x2:p2[0],y2:p2[1]}); }

      // concentric layer rings anchored to face centroid
      const baseR = 26 + 8*f.lit; const layers = state.layers; for(let L=0; L<layers; L++){
        const t=L/(layers-1||1); const r = baseR * (0.65 + t*0.85);
        ctx.beginPath(); ctx.arc(f.cp[0], f.cp[1], r, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(124,199,255,${0.28 + 0.55*(1-t)})`; ctx.lineWidth = (L===0?2:1);
        ctx.stroke();
        if(L===0){ // label only on innermost ring
          ctx.fillStyle = `rgba(235,245,255,0.9)`; ctx.font='700 14px ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(f.label, f.cp[0], f.cp[1]);
        }
        // ring hit targets by layer
        rings2D.push({x:f.cp[0], y:f.cp[1], R:r, label:f.label, layer:L});
      }

      // vertices (for reverse toggle)
      verts2D.push(a,b,c);
    }

    // subtle starfield dots to suggest depth
    const dots = 60; ctx.globalAlpha=0.25; for(let i=0;i<dots;i++){ const x=(i*97 % w); const y=(i*59 % h); ctx.fillStyle='rgba(160,200,255,0.15)'; ctx.fillRect(x, y, 1, 1); } ctx.globalAlpha=1;
  }

  // ===== Animation loop =====
  let last = performance.now();
  function tick(now){ const dt=(now-last)/1000; last=now; if(state.running){ state.t += dt; if(audioCtx){ const base=80 + state.enhance*90; const wob=Math.sin(state.t*2)*4; osc.frequency.setTargetAtTime(base+wob,audioCtx.currentTime,0.03); const target=(1-state.obsolesce)*0.025; gain.gain.setTargetAtTime(target,audioCtx.currentTime,0.05);} }
    draw(); requestAnimationFrame(tick);} 

  // ===== Picking helpers =====
  function pickRing(x,y){ let hit=null, best=1e9; for(const r of rings2D){ const d=Math.abs(Math.hypot(x-r.x,y-r.y)-r.R); if(d<16 && d<best){ best=d; hit=r; } } return hit; }
  function pickEdge(x,y){ function dist(px,py,x1,y1,x2,y2){ const A=px-x1, B=py-y1, C=x2-x1, D=y2-y1; const dot=A*C+B*D, len=C*C+D*D; let t=dot/len; t=Math.max(0,Math.min(1,t)); const ex=x1+t*C, ey=y1+t*D; return Math.hypot(px-ex, py-ey);} let h=null,best=14; for(const e of edges2D){ const d=dist(x,y,e.x1,e.y1,e.x2,e.y2); if(d<best){best=d; h=e;} } return h; }
  function pickVertex(x,y){ let h=null,best=12; for(const v of verts2D.flat()){ const d=Math.hypot(x-v[0],y-v[1]); if(d<best){best=d; h=v;} } return h; }

  // ===== Interactions (everything on tetra) =====
  let mode=null, baseVal=0, start=0, sx=0, sy=0, longPressTimer=null;

  function onDown(e){ ensureAudio(); const p=e.touches?e.touches[0]:e; const rect=canvas.getBoundingClientRect(); const x=p.clientX-rect.left, y=p.clientY-rect.top; sx=x; sy=y;
    const r=pickRing(x,y), ed=pickEdge(x,y), vt=pickVertex(x,y); 
    if(r){ mode='ring'; state.activeFace=r.label; baseVal=state.enhance; start=Math.atan2(y-r.y,x-r.x); haptic(); blip(260,0.02,0.04); longPressTimer=setTimeout(()=> openMedia(r.label, r.layer), 500); }
    else if(ed){ mode='edge'; baseVal=state.obsolesce; haptic(); blip(200,0.018,0.05); }
    else if(vt){ mode='vertex'; haptic(30); state.reverse=!state.reverse; blip(state.reverse?120:340,0.03,0.08); }
    else { mode='face'; }
    window.addEventListener('pointermove', onMove); window.addEventListener('pointerup', onUp, {once:true});
  }

  function onMove(e){ const p=e.touches?e.touches[0]:e; const rect=canvas.getBoundingClientRect(); const x=p.clientX-rect.left, y=p.clientY-rect.top; 
    if(mode==='ring'){ const r=pickRing(sx,sy); if(!r) return; const a=Math.atan2(y-r.y,x-r.x); const dA=a-start; state.enhance=Math.max(0.1,Math.min(4, baseVal + dA*1.25)); }
    else if(mode==='edge'){ const dy=(y-sy)/220; state.obsolesce=Math.max(0,Math.min(1, baseVal + dy)); }
    else if(mode==='face'){ const dx=(x-sx); state.retrieve = Math.max(0, Math.min(1, state.retrieve + dx/(rect.width*0.9))); sx=x; sy=y; }
  }

  function onUp(){ clearTimeout(longPressTimer); longPressTimer=null; mode=null; window.removeEventListener('pointermove', onMove); }

  canvas.addEventListener('pointerdown', onDown);
  window.addEventListener('keydown', e=>{ if(e.code==='Space'){ state.running=!state.running; } if(e.key==='l'){ state.layers = Math.min(16, state.layers+1); haptic(8);} if(e.key==='k'){ state.layers=Math.max(3, state.layers-1); haptic(8);} });

  // Double‑tap face to change number of layer rings quickly
  let lastTap=0; canvas.addEventListener('pointerup', (e)=>{ const now=performance.now(); if(now-lastTap<260){ state.layers = (state.layers%16)+4; haptic(20); blip(420,0.02,0.06);} lastTap=now; });

  // Device tilt adds micro‑modulation to enhance
  window.addEventListener('deviceorientation', (e)=>{ const g=(Math.abs(e.gamma||0)+Math.abs(e.beta||0))/180; state.enhance=Math.max(0.1, Math.min(4, state.enhance*0.98 + g*0.02)); });

  // ===== Media panel (long‑press ring) =====
  const mediaEl = document.getElementById('media');
  const mediaTitle = document.getElementById('mediaTitle');
  const mediaViewer = document.getElementById('mediaViewer');
  const mediaTray = document.getElementById('mediaTray');
  const mediaClose = document.getElementById('mediaClose');

  function openMedia(face, layer){ const set = (MEDIA[face]||{})[layer] || (MEDIA[face]||{})[0]; if(!set) return; mediaTitle.textContent = `${face} • Layer ${layer+1}`; mediaViewer.innerHTML=''; mediaTray.innerHTML='';
    set.forEach((m,ix)=>{ const b=document.createElement('button'); b.className='chip'; b.textContent=(m.title||m.type||'media') + (set.length>1?` • ${ix+1}`:''); b.addEventListener('click',()=> showMedia(m)); mediaTray.appendChild(b);});
    showMedia(set[0]); mediaEl.classList.add('open'); }
  function showMedia(m){ mediaViewer.innerHTML=''; let node; if(m.type==='image'){ node=new Image(); node.src=m.url; node.alt=m.title||'image'; } else if(m.type==='video'){ node=document.createElement('video'); node.src=m.url; node.controls=true; node.playsInline=true; } else if(m.type==='audio'){ node=document.createElement('audio'); node.src=m.url; node.controls=true; } else { node=document.createElement('div'); node.style.padding='12px'; node.textContent='Unsupported media'; } mediaViewer.appendChild(node); }
  mediaClose.addEventListener('click', ()=> mediaEl.classList.remove('open'));

  // ===== Start =====
  resize(); requestAnimationFrame(tick);
})();
</script>
</body>
</html>
