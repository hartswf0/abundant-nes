<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Tetrad Hypertetrahedron — Layered & Scrubbable</title>
  <style>
    :root{
      --bg:#070707; --fg:#eaeaea; --glass:rgba(0,0,0,.35); --glass-hi:rgba(255,255,255,.08);
      --shadow:0 4px 20px rgba(0,0,0,.35); --tap:44px; --cardW:720px;
      --enh:#ff4d4d; --obs:#4dff7a; --ret:#4db4ff; --rev:#ffd84d;
    }
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Inter,Roboto,Arial;overflow:hidden;touch-action:none}
    #app{position:fixed;inset:0}
    canvas{display:block;width:100%;height:100%}
    .hud{position:fixed;left:0;right:0;top:calc(env(safe-area-inset-top,0) + 8px);display:flex;align-items:center;justify-content:space-between;gap:10px;padding:10px 14px;font-size:12px;letter-spacing:.04em;color:#cfcfcf;pointer-events:none}
    .brand{pointer-events:auto}
    .chips{display:flex;gap:8px;pointer-events:auto}
    .chip{padding:6px 10px;border-radius:999px;border:1px solid var(--glass-hi);background:var(--glass);backdrop-filter:blur(8px);font-weight:600;color:#ddd;cursor:pointer}
    .chip[data-face="0"]{border-color:color-mix(in hsl, var(--enh) 50%, white)}
    .chip[data-face="1"]{border-color:color-mix(in hsl, var(--obs) 50%, white)}
    .chip[data-face="2"]{border-color:color-mix(in hsl, var(--ret) 50%, white)}
    .chip[data-face="3"]{border-color:color-mix(in hsl, var(--rev) 50%, white)}

    .scrubber{position:fixed;left:16px;right:16px;top:calc(env(safe-area-inset-top,0) + 54px);height:12px;border-radius:999px;background:linear-gradient(90deg, rgba(255,255,255,.12), rgba(255,255,255,.28));box-shadow:var(--shadow);touch-action:pan-x;pointer-events:auto}
    .thumb{position:absolute;top:-8px;width:28px;height:28px;border-radius:50%;background:#c9a227;box-shadow:0 0 0 6px rgba(201,162,39,.2), 0 0 18px rgba(201,162,39,.25);transform:translateX(-50%)}

    .controls{position:fixed;left:16px;right:16px;bottom:calc(env(safe-area-inset-bottom,0) + 16px);display:flex;gap:10px;justify-content:space-between;pointer-events:auto}
    .btn{flex:1;min-height:var(--tap);border-radius:12px;border:1px solid var(--glass-hi);background:var(--glass);color:#fff;font-weight:700;font-size:14px;letter-spacing:.02em;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(8px)}
    .btn:active{filter:brightness(1.15)}

    .depth{position:fixed;right:16px;bottom:calc(env(safe-area-inset-bottom,0) + 74px);background:var(--glass);border:1px solid var(--glass-hi);padding:9px 11px;border-radius:12px;color:#c9a227;backdrop-filter:blur(6px);box-shadow:var(--shadow);font-weight:600;max-width:58%;text-align:right}
  </style>
  <script type="importmap">{"imports":{"three":"https://unpkg.com/three@0.160.0/build/three.module.js","three/addons/":"https://unpkg.com/three@0.160.0/examples/jsm/"}}</script>
</head>
<body>
  <div id="app" role="application" aria-label="Tetrad layered tetrahedron"></div>

  <div class="hud">
    <div class="brand"><strong>Tetrad</strong> • <span style="color:var(--enh)">Enhance</span> · <span style="color:var(--obs)">Obsolesce</span> · <span style="color:var(--ret)">Retrieve</span> · <span style="color:var(--rev)">Reverse</span></div>
    <div class="chips" id="chips">
      <button class="chip" data-face="0" aria-pressed="true">Enhance</button>
      <button class="chip" data-face="1" aria-pressed="true">Obsolesce</button>
      <button class="chip" data-face="2" aria-pressed="true">Retrieve</button>
      <button class="chip" data-face="3" aria-pressed="true">Reverse</button>
    </div>
  </div>

  <div class="scrubber" id="scrubber" role="slider" aria-valuemin="1" aria-valuemax="64" aria-valuenow="1" aria-label="Layer scrubber">
    <div class="thumb" id="thumb" style="left:0%"></div>
  </div>

  <div class="depth" id="depth">01 / 64</div>

  <div class="controls">
    <button class="btn" id="prev">◀︎ Up</button>
    <button class="btn" id="next">Down ▶︎</button>
    <button class="btn" id="resetView">Reset View</button>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // ===== Scene / Camera / Renderer =====
    const app = document.getElementById('app');
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false, powerPreference:'high-performance' });
    const DPR = Math.min(devicePixelRatio||1, 2);
    renderer.setPixelRatio(DPR); renderer.setSize(innerWidth, innerHeight); renderer.setClearColor('#070707', 1);
    app.appendChild(renderer.domElement);
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
    const CAM_INIT = new THREE.Vector3(2.4, 2.4, 3.4);
    camera.position.copy(CAM_INIT);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.06;

    // ===== Tetrad Setup =====
    const SIZE = 1.25; const LAYERS = 64;
    const COLORS = [0xff4d4d, 0x4dff7a, 0x4db4ff, 0xffd84d];
    const FACE_NAMES = ['Enhance','Obsolesce','Retrieve','Reverse'];

    // Canonical tetra vertices
    const V = [ new THREE.Vector3( 1,  1,  1), new THREE.Vector3(-1, -1,  1), new THREE.Vector3(-1,  1, -1), new THREE.Vector3( 1, -1, -1) ]
      .map(v=>v.normalize().multiplyScalar(SIZE));
    const FACES = [ [0,1,2], [0,3,1], [0,2,3], [1,3,2] ];

    const group = new THREE.Group(); scene.add(group);

    // Base faces (translucent fill per tetrad law)
    function makeFaceFill(i){
      const [a,b,c] = FACES[i].map(j=>V[j]);
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([a.x,a.y,a.z,b.x,b.y,b.z,c.x,c.y,c.z]),3));
      geo.setIndex([0,1,2]); geo.computeVertexNormals();
      const mat = new THREE.MeshPhysicalMaterial({ color: COLORS[i], metalness:0.1, roughness:0.9, transparent:true, opacity:0.2, side:THREE.DoubleSide, clearcoat:0.25, clearcoatRoughness:0.95 });
      const mesh = new THREE.Mesh(geo, mat); mesh.userData={law:FACE_NAMES[i]};
      return mesh;
    }
    const faceFills = [0,1,2,3].map(i=>makeFaceFill(i)); faceFills.forEach(m=>group.add(m));

    // Base edges
    const baseEdges = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.TetrahedronGeometry(SIZE)), new THREE.LineBasicMaterial({ color:0xffffff, transparent:true, opacity:0.85 }));
    group.add(baseEdges);

    // ===== Per-face strata (64 each, colored) =====
    function buildLayeredFace(faceIdx){
      const [ai,bi,ci] = FACES[faceIdx];
      const a=V[ai].clone(), b=V[bi].clone(), c=V[ci].clone();
      const tri = new THREE.Triangle(a,b,c);
      const normal = tri.getNormal(new THREE.Vector3());
      const center = new THREE.Vector3(); tri.getMidpoint(center);
      const u = b.clone().sub(a).normalize();
      const v = new THREE.Vector3().crossVectors(normal, u).normalize();

      const g = new THREE.Group(); g.userData={law:faceIdx};
      const edges = [[a,b],[b,c],[c,a]];
      const baseColor = new THREE.Color(COLORS[faceIdx]);

      for(let i=0;i<LAYERS;i++){
        const t = i/(LAYERS-1);
        const offset = THREE.MathUtils.lerp(-0.028, 0.028, t);
        const scale  = THREE.MathUtils.lerp(0.98, 0.86, t);
        const pts = [a,b,c].map(p=>{
          const rel = p.clone().sub(center);
          const relU = u.clone().multiplyScalar(rel.dot(u));
          const relV = v.clone().multiplyScalar(rel.dot(v));
          return center.clone().add(relU.multiplyScalar(scale)).add(relV.multiplyScalar(scale)).add(normal.clone().multiplyScalar(offset));
        });
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(edges.length*2*3);
        for(let e=0;e<edges.length;e++){
          const i0=e*2*3; const p0=pts[e], p1=pts[(e+1)%3];
          pos[i0+0]=p0.x; pos[i0+1]=p0.y; pos[i0+2]=p0.z;
          pos[i0+3]=p1.x; pos[i0+4]=p1.y; pos[i0+5]=p1.z;
        }
        geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
        const opacity = THREE.MathUtils.lerp(0.7, 0.08, t);
        const mat = new THREE.LineBasicMaterial({ color: baseColor.getHex(), transparent:true, opacity });
        const wire = new THREE.LineSegments(geo, mat);
        wire.userData={layer:i}; g.add(wire);
      }
      return g;
    }

    const layeredFaces = [0,1,2,3].map(i=>buildLayeredFace(i)); layeredFaces.forEach(f=>group.add(f));

    // Vertex nexus points
    const vert = new THREE.SphereGeometry(0.06, 20, 20);
    const vertNodes = V.map(p=>{ const s=new THREE.Mesh(vert, new THREE.MeshBasicMaterial({color:0xffffff})); s.position.copy(p); group.add(s); return s; });

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const p1=new THREE.PointLight(0xffffff, 0.9); p1.position.set(3,3,3); scene.add(p1);
    const p2=new THREE.PointLight(0xffffff, 0.6); p2.position.set(-3,-2,1); scene.add(p2);

    // ===== Interaction state =====
    let idx=0; // current strata index (0..63)
    const faceEnabled=[true,true,true,true];

    function setLayer(i){
      const prev=idx; idx=Math.max(0,Math.min(LAYERS-1,i|0)); if(idx===prev) return;
      updateVisuals();
    }

    function updateVisuals(){
      document.getElementById('depth').textContent = `${String(idx+1).padStart(2,'0')} / ${LAYERS}`;
      const pct = idx/(LAYERS-1)*100; document.getElementById('thumb').style.left = pct.toFixed(2)+'%';

      // falloff weighting: nearest strata are brighter
      const falloff=6;
      layeredFaces.forEach((fg,fi)=>{
        fg.visible = !!faceEnabled[fi];
        fg.children.forEach(line=>{
          const d=Math.abs((line.userData.layer||0)-idx);
          const near=Math.max(0,1-d/falloff);
          line.material.opacity = THREE.MathUtils.lerp(0.06, 0.95, near) * (faceEnabled[fi]?1:0.15);
          line.material.needsUpdate=true;
        });
      });

      // subtle tint on fills based on enable state
      faceFills.forEach((m,fi)=>{ m.visible = !!faceEnabled[fi]; m.material.opacity = faceEnabled[fi]?0.22:0.08; });

      // request a single render
      render();
    }

    // ===== Rendering (no auto-rotation) =====
    let raf = null; function render(){ cancelAnimationFrame(raf); raf = requestAnimationFrame(()=>{ controls.update(); renderer.render(scene,camera); }); }

    // ===== UI wiring =====
    const scrubber=document.getElementById('scrubber');
    const thumb=document.getElementById('thumb');

    let dragging=false; function at(e){ const r=scrubber.getBoundingClientRect(); const nx=(e.clientX-r.left)/r.width; return Math.max(0,Math.min(1,nx)); }
    function drag(e){ const nx=at(e); setLayer(Math.round(nx*(LAYERS-1))); }
    scrubber.addEventListener('pointerdown', e=>{dragging=true; drag(e)});
    window.addEventListener('pointermove', e=>{ if(dragging) drag(e) });
    window.addEventListener('pointerup', ()=> dragging=false);

    document.getElementById('prev').addEventListener('click', ()=> setLayer(idx-1));
    document.getElementById('next').addEventListener('click', ()=> setLayer(idx+1));
    document.getElementById('resetView').addEventListener('click', ()=>{ camera.position.copy(CAM_INIT); controls.target.set(0,0,0); updateVisuals(); });

    // Face enable/disable chips
    const chips=document.getElementById('chips');
    chips.querySelectorAll('.chip').forEach(ch=>{
      ch.addEventListener('click',()=>{
        const i=+(ch.dataset.face||0); faceEnabled[i]=!faceEnabled[i]; ch.setAttribute('aria-pressed', String(faceEnabled[i])); updateVisuals();
      });
    });

    // Keyboard
    window.addEventListener('keydown', e=>{
      if(e.key==='ArrowRight'||e.key==='ArrowDown') setLayer(idx+1);
      if(e.key==='ArrowLeft'||e.key==='ArrowUp') setLayer(idx-1);
      if(e.key==='Home') setLayer(0);
      if(e.key==='End') setLayer(LAYERS-1);
      if(e.key>='1' && e.key<='4'){ const i=(+e.key)-1; faceEnabled[i]=!faceEnabled[i]; chips.querySelector(`[data-face="${i}"]`).setAttribute('aria-pressed', String(faceEnabled[i])); updateVisuals(); }
    });

    // Resize
    addEventListener('resize', ()=>{ renderer.setSize(innerWidth, innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); render(); });

    // Start — initial render only (no animation loop)
    updateVisuals();

    // ===== Tests =====
    (function tests(){
      const T=[]; const ok=(c,m)=>T.push({ok:!!c,msg:m});
      ok(renderer instanceof THREE.WebGLRenderer,'Renderer ok');
      ok(faceFills.length===4,'4 face fills');
      ok(layeredFaces.length===4 && layeredFaces.every(f=>f.children.length===64),'64 strata per face');
      ok(document.querySelectorAll('.chip').length===4,'Face chips present');
      ok(typeof setLayer==='function','setLayer exposed');
      const failed=T.filter(t=>!t.ok); if(failed.length){console.group('%cTetrad Layered Tests — FAIL','color:#f66');failed.forEach(t=>console.error('✗',t.msg));console.groupEnd();} else {console.group('%cTetrad Layered Tests — PASS','color:#6f6');T.forEach(t=>console.log('✓',t.msg));console.groupEnd();}
    })();

    // Expose minimal API
    window.tetrad={ setLayer:(i)=>setLayer(i), enableFace:(i,on)=>{faceEnabled[i]=!!on; updateVisuals();}, render };
  </script>
</body>
</html>
