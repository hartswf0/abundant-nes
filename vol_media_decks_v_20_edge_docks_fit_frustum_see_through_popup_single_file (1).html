<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
<title>VOL‚ÄëMEDIA DECKS v20 ‚Äî Edge Docks ‚Ä¢ Fit‚ÄëFrustum ‚Ä¢ Bottom Sheet</title>
<style>
  :root{
    --bg:#000; --fg:#fff; --glass:rgba(0,0,0,.55); --line:rgba(255,255,255,.18); --accent:#4dd9cc;
    --card:rgba(0,0,0,.38); --card2:rgba(0,0,0,.28); --font:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    --safe-bottom: env(safe-area-inset-bottom, 0px);
  }
  [data-theme="news"]{ --bg:#10100e; --fg:#111; --glass:rgba(255,255,255,.75); --line:rgba(0,0,0,.25); --accent:#111; --card:rgba(255,255,255,.8); --card2:rgba(255,255,255,.65); }
  [data-theme="light"]{ --bg:#f8f8f8; --fg:#111; --glass:rgba(255,255,255,.75); --line:rgba(0,0,0,.2); --accent:#0aa; --card:rgba(255,255,255,.85); --card2:rgba(255,255,255,.7); }

  *{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%}
  body{background:var(--bg);color:var(--fg);font-family:var(--font);overflow:hidden}
  #canvas{width:100vw;height:100vh;display:block}

  /* HUD root */
  #hud{position:fixed;inset:0;pointer-events:none;z-index:10}
  #viewHUD{position:absolute;top:10px;left:50%;transform:translateX(-50%);background:var(--glass);padding:6px 12px;border-radius:10px;font-weight:800;font-size:12px;border:1px solid var(--line);pointer-events:auto}

  .dock{position:absolute;display:flex;gap:6px;pointer-events:auto}
  #dockL{left:10px;top:50%;transform:translateY(-50%);flex-direction:column}
  #dockR{right:10px;top:50%;transform:translateY(-50%);flex-direction:column}
  #dockT{top:10px;left:10px;right:10px;justify-content:flex-start}

  .mini{min-width:34px;height:34px;border-radius:8px;border:1px solid var(--line);background:var(--card);font-weight:800;font-size:12px;display:flex;align-items:center;justify-content:center;cursor:pointer}
  .mini:active{transform:translateY(1px)}
  .stackBtn{width:34px;height:34px;border-radius:8px;border:1px dashed var(--line);background:var(--card2);font-size:10px;display:grid;place-items:center;cursor:pointer}
  .seg{display:flex;gap:6px}

  /* Toast */
  #toast{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);background:var(--glass);border:1px solid var(--line);padding:6px 10px;border-radius:10px;font-size:12px;display:none;z-index:12}

  /* Hide redundant side docks */
  #dockL, #dockR{display:none !important}

  /* Bottom Sheet (modal) */
  #sheet{position:fixed;inset:0;display:none;z-index:20}
  #sheet.show{display:block}
  #sheet .scrim{position:absolute;inset:0;background:rgba(0,0,0,.5)}
  #sheet .panel{position:absolute;left:0;right:0;bottom:0;background:rgba(28,28,28,.92);border-top-left-radius:18px;border-top-right-radius:18px;border:1px solid var(--line);padding:12px 14px calc(14px + var(--safe-bottom));box-shadow:0 -10px 30px rgba(0,0,0,.45)}
  #sheet .handle{width:56px;height:5px;background:rgba(255,255,255,.4);border-radius:999px;margin:4px auto 10px}
  #sheet header{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px}
  #sheet header .title{font-weight:800;letter-spacing:.02em}
  #sheet header .close{width:44px;height:36px;border-radius:10px;border:1px solid var(--line);background:var(--card);display:grid;place-items:center;cursor:pointer}
  #sheet .grid{display:grid;grid-template-columns:repeat(8,1fr);gap:14px}
  #sheet .col{display:flex;flex-direction:column;align-items:center}
  #sheet .col .knob{height:150px;width:36px}
  #sheet .chip{padding:4px 8px;border-radius:999px;border:1px solid var(--line);background:var(--card);font-size:12px;margin-top:6px}
  #sheet .button{min-width:72px;height:44px;border-radius:10px;border:1px solid var(--line);background:var(--card);font-weight:800;display:grid;place-items:center}

  input[type=range]{-webkit-appearance:none;appearance:none;background:var(--line);border-radius:8px}
  input[type=range]::-webkit-slider-thumb{ -webkit-appearance:none; appearance:none; width:22px; height:22px; border-radius:50%; background:var(--accent); border:1px solid var(--line)}

  @media (min-width:900px){
    #sheet .panel{left:50%;transform:translateX(-50%);width:min(880px,90vw)}
  }
</style>
</head>
<body>
<canvas id="canvas" aria-label="VOL-MEDIA Stacks"></canvas>
<div id="hud" aria-hidden="false">
  <div id="viewHUD">FRONT</div>

  <!-- top dock: transport + packs + toggles -->
  <div id="dockT" class="dock">
    <div class="seg">
      <div class="mini" title="Play/Pause" data-btn="start">‚ñ∂</div>
      <div class="mini" title="Orbit" data-btn="orbit">‚óã</div>
      <div class="mini" title="Fit" data-btn="fit">‚ñ°</div>
      <div class="mini" title="Zoom In" data-btn="zoomIn">Ôºã</div>
      <div class="mini" title="Zoom Out" data-btn="zoomOut">Ôºç</div>
    </div>
    <div class="seg">
      <div class="mini" title="Prev Pack" data-btn="packPrev">‚óÄ</div>
      <div class="mini" title="Next Pack" data-btn="packNext">‚ñ∂</div>
      <div class="mini" title="Theme" data-btn="theme">üì∞</div>
      <div class="mini" title="Labels" data-btn="labels">‚åó</div>
      <div class="mini" title="Debug" data-btn="debug">¬ß</div>
    </div>
    <div class="seg">
      <div class="stackBtn" data-btn="density" data-den="16">16√ó</div>
      <div class="stackBtn" data-btn="density" data-den="8">8√ó</div>
      <div class="stackBtn" data-btn="density" data-den="4">4√ó</div>
      <div class="stackBtn" data-btn="density" data-den="2">2√ó</div>
      <div class="stackBtn" data-btn="density" data-den="1">1√ó</div>
    </div>
  </div>
</div>
<div id="toast"></div>

<!-- Modal bottom sheet controls (always tappable, large targets) -->
<div id="sheet" aria-hidden="true">
  <div class="scrim"></div>
  <div class="panel" role="dialog" aria-modal="true">
    <div class="handle"></div>
    <header>
      <div class="title">Row <span id="sheetRow">‚Äî</span> Controls</div>
      <button class="close" id="sheetClose" title="Close">‚úï</button>
    </header>
    <div class="grid">
      <div class="col"><button class="button" id="sh_sync">SYNC</button><small class="chip">sync</small></div>
      <div class="col"><input id="sh_swg" class="knob" type="range" min="0" max="1" step="0.01"><small class="chip">swg</small></div>
      <div class="col"><input id="sh_oct" class="knob" type="range" min="0" max="1" step="0.01"><small class="chip">oct</small></div>
      <div class="col"><input id="sh_cho" class="knob" type="range" min="0" max="1" step="0.01"><small class="chip">cho</small></div>
      <div class="col"><button class="button" id="sh_evo">EVO</button><small class="chip">evo</small></div>
      <div class="col"><input id="sh_lvl" class="knob" type="range" min="0" max="1" step="0.01"><small class="chip">lvl</small></div>
      <div class="col"><input id="sh_snd" class="knob" type="range" min="0" max="1" step="0.01"><small class="chip">send</small></div>
      <div class="col"><input id="sh_prb" class="knob" type="range" min="0" max="1" step="0.01"><small class="chip">prob</small></div>
    </div>
  </div>
</div>

<script>
(async function(){
  // ===== Utils
  const vibrate=(ms=8)=>{ try{ if(navigator.vibrate) navigator.vibrate(ms); }catch{} };
  const qs=(sel,root=document)=>root.querySelector(sel);
  const qsa=(sel,root=document)=>[...root.querySelectorAll(sel)];
  const body=document.body;

  // ===== Load THREE fallback
  if(!window.THREE){
    const CDNs=['https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js','https://unpkg.com/three@0.152.2/build/three.min.js'];
    for(const src of CDNs){
      try{
        await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=src; s.onload=res; s.onerror=rej; document.head.appendChild(s); });
        if(window.THREE) break;
      }catch(e){}
    }
  }
  if(!window.THREE){ alert('THREE failed to load.'); return; }

  // ===== Core scene
  const canvas=qs('#canvas');
  const renderer=new THREE.WebGLRenderer({canvas,antialias:true,alpha:false,depth:true});
  renderer.setSize(innerWidth,innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
  const scene=new THREE.Scene(); scene.background=new THREE.Color(0x000000);
  const camera=new THREE.PerspectiveCamera(58, innerWidth/innerHeight, .1, 5000);
  let dist=170; camera.position.set(dist,60,0);
  const camTarget=new THREE.Vector3(0,8,0); const fitLook=()=>camera.lookAt(camTarget);
  fitLook();

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff,.28));
  const key=new THREE.PointLight(0x66ddff,1.2,1200); key.position.set(0,180,220); scene.add(key);
  const warm=new THREE.PointLight(0xffaa66,.8,1000); warm.position.set(180,100,-180); scene.add(warm);
  const rim=new THREE.DirectionalLight(0xffffff,.55); rim.position.set(-220,200,-60); scene.add(rim);

  // HUD
  const viewHUD=qs('#viewHUD');
  const toastEl=qs('#toast');
  function toast(t){ toastEl.textContent=t; toastEl.style.display='block'; clearTimeout(toast._id); toast._id=setTimeout(()=>toastEl.style.display='none',1100); }

  // ===== Views
  const VIEWS=[ {name:'FRONT',pos:[dist,60,0]}, {name:'ISO L',pos:[-140,90,120]}, {name:'ISO R',pos:[140,90,120]}, {name:'TOP',pos:[0,260,0.01]}, {name:'WIDE',pos:[260,90,0]} ];
  let viewIdx=0; function applyView(){ const v=VIEWS[viewIdx%VIEWS.length]; camera.position.set(...v.pos); fitLook(); viewHUD.textContent=v.name; }
  applyView();

  // ===== Sprite label (toggle-able)
  let labelsOn=true;
  function mkSprite(text){
    const cvs=document.createElement('canvas'); const s=256; cvs.width=cvs.height=s; const ctx=cvs.getContext('2d'); ctx.clearRect(0,0,s,s);
    ctx.fillStyle='rgba(0,0,0,0)'; ctx.fillRect(0,0,s,s);
    ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--fg') || 'white';
    ctx.font='bold 48px Inter, system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.shadowColor='rgba(0,0,0,0.6)'; ctx.shadowBlur=12;
    ctx.fillText(text,s/2,s/2);
    const tex=new THREE.CanvasTexture(cvs);
    const mat=new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false});
    const spr=new THREE.Sprite(mat); spr.scale.set(6,6,1); spr.visible=labelsOn; return spr;
  }

  // ===== Mini-stack builder
  function makeMiniStack(color, layers=8, spacing=0.55, size=2.6){
    const g=new THREE.Group();
    for(let i=0;i<layers;i++){
      const geo=new THREE.PlaneGeometry(size,size);
      const mat=new THREE.MeshStandardMaterial({color,transparent:true,opacity:0.18,roughness:.6,metalness:.1,side:THREE.DoubleSide,depthWrite:false});
      const m=new THREE.Mesh(geo,mat); m.rotation.x=-Math.PI/2; m.position.y=i*spacing;
      m.material.emissive=new THREE.Color(color); m.material.emissiveIntensity=.12; g.add(m);
    }
    g.userData.pulse=(level)=>{
      const L=g.children.length; for(let i=0;i<L;i++){ const p=g.children[i]; const on=i<Math.min(L,Math.ceil(level*L)); p.material.opacity=on?0.75:0.12; p.material.emissiveIntensity=on?0.9:0.08; p.scale.set(on?1.05:1,1,on?1.05:1); }
      if(level>0){ const s=1+level*0.14; g.scale.set(s,1,s); setTimeout(()=>g.scale.set(1,1,1),90); }
    };
    return g;
  }

  // ===== Grid
  const GRID={ rows:8, cols:16, gapX:7.5, gapZ:8.5, group:new THREE.Group(), cells:[], cursor:null, labels:[], origin:new THREE.Vector3(), densitySteps:[16,8,4,2,1] };
  scene.add(GRID.group);
  const instruments=['Kick','Snr','Hat','Bass','Chord','Lead','Perc','FX'];
  const colors=[0xff8844,0xff6688,0xffff66,0x66ffcc,0x99bbff,0xc47dff,0x88ffaa,0xffffff];

  function autoSpacing(){ const w=innerWidth,h=innerHeight; const baseX=7.5, baseZ=8.5; const scale=Math.min(Math.max(Math.min(w/900, h/620), 0.85), 1.35); GRID.gapX=baseX*scale; GRID.gapZ=baseZ*scale; }
  autoSpacing();

  function fitFrustum(){
    const bbox=new THREE.Box3().setFromObject(GRID.group);
    const size=new THREE.Vector3(); bbox.getSize(size);
    const maxDim=Math.max(size.x,size.z,60);
    const fov=THREE.MathUtils.degToRad(camera.fov);
    const fitDist=(maxDim/2)/Math.tan(fov/2)+40;
    dist=THREE.MathUtils.clamp(fitDist,90,420);
    const yaw=Math.atan2(camera.position.z,camera.position.x);
    camera.position.set(Math.cos(yaw)*dist, Math.min(260,60+maxDim*0.15), Math.sin(yaw)*dist);
    fitLook();
  }

  function refreshLayoutPositions(){
    const startX=-(GRID.cols-1)*GRID.gapX/2, startZ=-(GRID.rows-1)*GRID.gapZ/2; GRID.origin.set(startX,0,startZ);
    for(let r=0;r<GRID.rows;r++){
      for(let c=0;c<GRID.cols;c++){
        const stack=GRID.cells[r]?.[c]; if(!stack) continue; stack.position.set(startX + c*GRID.gapX, 0, startZ + r*GRID.gapZ);
      }
      const lbl=GRID.labels[r]; if(lbl){ lbl.position.set(startX-8.5, 6, startZ + r*GRID.gapZ); }
    }
    if(GRID.cursor){ GRID.cursor.position.set(startX + (step%GRID.cols)*GRID.gapX, 0.2, 0); GRID.cursor.scale.set(1,1,(GRID.rows*GRID.gapZ + 4)/(GRID.cursor.geometry.parameters.depth||1)); }
    fitFrustum();
  }

  function buildGrid(){
    GRID.cells.length=0; GRID.labels.length=0; while(GRID.group.children.length) GRID.group.remove(GRID.group.children[0]);
    const startX=-(GRID.cols-1)*GRID.gapX/2, startZ=-(GRID.rows-1)*GRID.gapZ/2; GRID.origin.set(startX,0,startZ);
    for(let r=0;r<GRID.rows;r++){
      const row=[];
      for(let c=0;c<GRID.cols;c++){
        const stack=makeMiniStack(colors[r]);
        stack.position.set(startX + c*GRID.gapX, 0, startZ + r*GRID.gapZ);
        stack.userData.rc=[r,c]; stack.userData.active=0; row.push(stack); GRID.group.add(stack);
      }
      GRID.cells.push(row);
    }
    GRID.cursor=new THREE.Mesh(new THREE.BoxGeometry(3.2,0.4, GRID.rows*GRID.gapZ + 4), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.1}));
    GRID.cursor.position.set(startX, 0.2, 0); GRID.group.add(GRID.cursor);
    for(let r=0;r<instruments.length;r++){
      const label=mkSprite(instruments[r]); label.scale.set(5,5,1); label.position.set(startX-8.5, 6, startZ + r*GRID.gapZ); label.userData.row=r; GRID.labels.push(label); GRID.group.add(label);
    }
  }
  buildGrid();

  // ===== Row Controllers (DATA-ONLY; no 3D)
  const ROWCTL={ bars:[] };
  function buildRowControllers(){
    ROWCTL.bars.length=0;
    for(let r=0;r<GRID.rows;r++){
      const bar={row:r, stacks:{}, swing:0, octave:0, chorus:0.1, evo:false, sync:true, phase:0, muted:false, solo:false};
      bar.stacks={ en:{userData:{val:1}}, lvl:{userData:{val:0.7}}, send:{userData:{val:0.25}}, width:{userData:{val:0.5}}, prob:{userData:{val:1.0}}, shape:{userData:{val:0.6}} };
      ROWCTL.bars.push(bar);
    }
  }
  buildRowControllers();

  // ===== Bottom Sheet Controls (DOM)
  const sheet=qs('#sheet');
  const sheetRow=qs('#sheetRow');
  const sh={ sync:qs('#sh_sync'), swg:qs('#sh_swg'), oct:qs('#sh_oct'), cho:qs('#sh_cho'), evo:qs('#sh_evo'), lvl:qs('#sh_lvl'), snd:qs('#sh_snd'), prb:qs('#sh_prb'), close:qs('#sheetClose') };
  let selected={row:null,col:null};
  const openSheet=(r)=>{ if(r==null||r<0) return; selected.row=r; const b=ROWCTL.bars[r]; sheetRow.textContent=r+1; sheet.classList.add('show'); sheet.setAttribute('aria-hidden','false');
    sh.sync.classList.toggle('on', !!b.sync); sh.evo.classList.toggle('on', !!b.evo);
    sh.swg.value=(b.swing+1)/2; sh.oct.value=b.octave; sh.cho.value=b.chorus; sh.lvl.value=b.stacks.lvl.userData.val; sh.snd.value=b.stacks.send.userData.val; sh.prb.value=b.stacks.prob.userData.val;
  };
  const closeSheet=()=>{ sheet.classList.remove('show'); sheet.setAttribute('aria-hidden','true'); };
  sh.close.onclick=closeSheet;
  sheet.querySelector('.scrim').onclick=closeSheet;
  addEventListener('keydown',e=>{ if(e.key==='Escape') closeSheet(); });
  (function swipeToClose(){ let startY=null, curY=null; const panel=sheet.querySelector('.panel');
    panel.addEventListener('touchstart',e=>{ startY=e.touches[0].clientY; },{passive:true});
    panel.addEventListener('touchmove',e=>{ curY=e.touches[0].clientY; if(startY!=null){ const dy=Math.max(0, curY-startY); panel.style.transform=`translateY(${dy}px)`; } },{passive:true});
    panel.addEventListener('touchend',()=>{ if(startY!=null){ const dy=(curY??startY)-startY; if(dy>90) closeSheet(); panel.style.transform=''; startY=null; curY=null; } });
  })();
  sh.sync.onclick=()=>{ const b=ROWCTL.bars[selected.row]; b.sync=!b.sync; sh.sync.classList.toggle('on', b.sync); vibrate(8); };
  sh.evo.onclick=()=>{ const b=ROWCTL.bars[selected.row]; b.evo=!b.evo; sh.evo.classList.toggle('on', b.evo); vibrate(8); };
  sh.swg.oninput=()=>{ const b=ROWCTL.bars[selected.row]; if(b) b.swing=sh.swg.value*2-1; };
  sh.oct.oninput=()=>{ const b=ROWCTL.bars[selected.row]; if(b) b.octave=parseFloat(sh.oct.value); };
  sh.cho.oninput=()=>{ const b=ROWCTL.bars[selected.row]; if(b) b.chorus=parseFloat(sh.cho.value); };
  sh.lvl.oninput=()=>{ const b=ROWCTL.bars[selected.row]; if(b) b.stacks.lvl.userData.val=parseFloat(sh.lvl.value); };
  sh.snd.oninput=()=>{ const b=ROWCTL.bars[selected.row]; if(b) b.stacks.send.userData.val=parseFloat(sh.snd.value); };
  sh.prb.oninput=()=>{ const b=ROWCTL.bars[selected.row]; if(b) b.stacks.prob.userData.val=parseFloat(sh.prb.value); };
  function openPopupForRow(r){ openSheet(r); toast('Row '+(r+1)+' controls'); }

  // ===== Pattern + Harmony
  const pattern=Array.from({length:GRID.rows},()=>Array(GRID.cols).fill(0));
  const scales={major:[0,2,4,5,7,9,11], minor:[0,2,3,5,7,8,10], dorian:[0,2,3,5,7,9,10], mixolydian:[0,2,4,5,7,9,10], pentMinor:[0,3,5,7,10]};
  let root=50; let scaleName='dorian'; let progression=[0,3,4,5];
  const degreeToFreq=(deg,oct=0)=>{ const arr=scales[scaleName]; const idx=((deg%arr.length)+arr.length)%arr.length; const semi=arr[idx]+12*oct; return 440*Math.pow(2,((root-69)+semi)/12); };

  // ===== Audio
  let AC=null, master=null, reverb=null, wet=null, dry=null; let laneFX=[]; let activeVoices=[]; let started=false;
  async function audioInit(){ if(AC) return true; try{ const C=window.AudioContext||window.webkitAudioContext; if(!C){ toast('AudioContext unsupported'); return false; } AC=new C(); master=AC.createGain(); master.gain.value=.18; master.connect(AC.destination); reverb=AC.createConvolver(); reverb.buffer=(function IR(sec=2.0,decay=3){const rate=AC.sampleRate,len=rate*sec,buf=AC.createBuffer(2,len,rate);for(let ch=0;ch<2;ch++){const d=buf.getChannelData(ch);for(let i=0;i<len;i++){d[i]=(Math.random()*2-1)*Math.pow(1-i/len,decay);}}return buf;})(); wet=AC.createGain(); dry=AC.createGain(); wet.gain.value=.22; dry.gain.value=.78; wet.connect(reverb).connect(master); dry.connect(master); return true; }catch(e){ console.error(e); toast('Audio init failed'); return false; } }
  function mkEnv(){ const e=AC.createGain(); e.gain.value=0; return e; }
  function mkFilter(type='lowpass'){ const f=AC.createBiquadFilter(); f.type=type; f.frequency.value=1200; f.Q.value=0.8; return f; }
  function noiseBuf(){ const b=AC.createBuffer(1, AC.sampleRate*1, AC.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1; return b; }
  function laneProcessors(){ const lanes=[]; for(let i=0;i<GRID.rows;i++){ const sat=AC.createWaveShaper(); const curve=new Float32Array(512); for(let j=0;j<512;j++){ const x=j/511*2-1; curve[j]=Math.tanh(2.5*x);} sat.curve=curve; const laneDry=AC.createGain(); const laneWet=AC.createGain(); laneWet.gain.value=.2; laneDry.gain.value=.8; const pan=AC.createStereoPanner(); pan.pan.value=0; const pre=AC.createGain(); pre.connect(sat); sat.connect(laneDry).connect(dry); sat.connect(laneWet).connect(wet); laneDry.connect(pan).connect(master); laneWet.connect(pan).connect(master); lanes.push({pre,sat,laneDry,laneWet,pan}); } return lanes; }
  function buildKick(dest){ const o=AC.createOscillator(); o.type='sine'; const g=mkEnv(); const f=mkFilter('lowpass'); o.connect(f).connect(g).connect(dest.pre); o.start(); return {start(v){ const t=AC.currentTime; o.frequency.setValueAtTime(120,t); o.frequency.exponentialRampToValueAtTime(40,t+0.08); g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.9*Math.min(1,v/2), t+0.005); g.gain.exponentialRampToValueAtTime(0.0001, t+0.28); }}};
  function buildSnare(dest){ const n=AC.createBufferSource(); n.buffer=noiseBuf(); n.loop=true; const g=mkEnv(); const hp=mkFilter('highpass'); hp.frequency.value=1800; n.connect(hp).connect(g).connect(dest.pre); n.start(); return {start(v){ const t=AC.currentTime; g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.7*(v/3+0.5), t+0.005); g.gain.exponentialRampToValueAtTime(0.0001, t+0.18); }}};
  function buildHat(dest){ const n=AC.createBufferSource(); n.buffer=noiseBuf(); n.loop=true; const g=mkEnv(); const hp=mkFilter('highpass'); hp.frequency.value=6000; n.connect(hp).connect(g).connect(dest.pre); n.start(); return {start(v){ const t=AC.currentTime; g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.4*(0.5+v/3), t+0.002); g.gain.exponentialRampToValueAtTime(0.0001, t+0.06); }}};
  function buildMono(dest,osc='sawtooth'){ const o=AC.createOscillator(); o.type=osc; const f=mkFilter('lowpass'); const g=mkEnv(); o.connect(f).connect(g).connect(dest.pre); o.start(); return {o,f,g,start(freq,vel=.6,decay=.2,shape=0.6){ const t=AC.currentTime; o.frequency.setTargetAtTime(freq,t,0.02); const bright=800 + 2600*shape; f.frequency.setTargetAtTime(bright,t,0.03); g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(g.gain.value,t); g.gain.linearRampToValueAtTime(vel, t+0.01); g.gain.exponentialRampToValueAtTime(0.0001, t+decay); }}};
  function buildChord(dest){ const gain=mkEnv(); gain.connect(dest.pre); const make=(det=0)=>{ const o=AC.createOscillator(); o.type='triangle'; o.detune.value=det; const f=mkFilter('lowpass'); o.connect(f).connect(gain); o.start(); return {o,f}; }; const a=make(-7), b=make(0), c=make(7); return {start(rootHz,vel=.4,shape=0.6){ const t=AC.currentTime; const thirds=[0,3,4]; const r=rootHz; const fA=r*Math.pow(2,thirds[(progressionIdx%thirds.length)]/12); const fB=r*Math.pow(2,7/12); a.o.frequency.setTargetAtTime(fA,t,0.02); b.o.frequency.setTargetAtTime(r,t,0.02); c.o.frequency.setTargetAtTime(fB,t,0.02); [a.f,b.f,c.f].forEach(f=>f.frequency.setTargetAtTime(900+shape*1800,t,0.04)); gain.gain.cancelScheduledValues(t); gain.gain.setValueAtTime(gain.gain.value,t); gain.gain.linearRampToValueAtTime(vel, t+0.03); gain.gain.exponentialRampToValueAtTime(0.0001, t+0.5); }}};
  function buildVoices(){ if(!AC||activeVoices.length) return; laneFX=laneProcessors(); activeVoices=[ buildKick(laneFX[0]), buildSnare(laneFX[1]), buildHat(laneFX[2]), buildMono(laneFX[3],'sawtooth'), buildChord(laneFX[4]), buildMono(laneFX[5],'square'), buildMono(laneFX[6],'triangle'), buildMono(laneFX[7],'sine') ]; }

  // ===== Packs & Presets
  const PACKS=[ {name:'TAPE', bass:'sawtooth', lead:'triangle', perc:'square'}, {name:'FMISH', bass:'square',lead:'square',perc:'square'}, {name:'GRAN', bass:'triangle',lead:'sine',perc:'triangle'}, {name:'BIT', bass:'square',lead:'sawtooth',perc:'square'}, {name:'WAVE', bass:'sawtooth',lead:'sawtooth',perc:'triangle'} ];
  let packIdx=0; function applyPack(i){ packIdx=((i%PACKS.length)+PACKS.length)%PACKS.length; const P=PACKS[packIdx]; if(activeVoices[3]?.o) activeVoices[3].o.type=P.bass; if(activeVoices[5]?.o) activeVoices[5].o.type=P.lead; if(activeVoices[6]?.o) activeVoices[6].o.type=P.perc; if(activeVoices[7]?.o) activeVoices[7].o.type='sine'; toast('Pack: '+P.name); }
  const PRESETS={ BASIC:(p)=>{ for(let r=0;r<GRID.rows;r++){ for(let c=0;c<GRID.cols;c++){ p[r][c]= (r<3? (c%4===0?1:0) : (Math.random()<0.2?1:0)); } } }, HOUSE:(p)=>{ for(let c=0;c<GRID.cols;c++){ p[0][c]=(c%4===0)?2:0; p[1][c]=(c%8===4)?2:0; p[2][c]= (c%2===1)?1:0; } }, DNB:(p)=>{ for(let c=0;c<GRID.cols;c++){ p[0][c]=(c%8===0)?3:0; p[1][c]=(c%8===4)?3:0; p[2][c]= (c%2===0)?1:0; } } };
  function loadPreset(name='BASIC'){ const fn=PRESETS[name]||PRESETS.BASIC; fn(pattern); toast('Preset: '+name); }
  function evolveRow(r){ const bar=ROWCTL.bars[r]; if(!bar.evo) return; for(let c=0;c<GRID.cols;c++){ if(Math.random()<0.06){ pattern[r][c] = (pattern[r][c]+1)%4; } } }

  // ===== Sequencer
  let bpm=112; let playing=false; let step=0; let progressionIdx=0; let orbit=false; let debugMode=false;
  function startClock(){ let last=performance.now(); (function loop(){ const beat=60000/bpm; const stepDur=beat/4; const now=performance.now(); if(playing && AC && AC.state==='running'){ if(now-last>=stepDur){ last=now; tick(); } } requestAnimationFrame(loop); })(); }
  const moveCursor=()=>{ const x0=GRID.origin.x; GRID.cursor.position.x = x0 + step*GRID.gapX; };
  function shouldFire(row){ const bar=ROWCTL.bars[row]; if(bar.muted) return false; if(ROWCTL.bars.some(b=>b.solo) && !bar.solo) return false; const en=bar.stacks.en.userData.val>0.1; if(!en) return false; const p=bar.stacks.prob.userData.val; return Math.random()<=p; }
  function trig(row,vel){ if(!activeVoices.length) return; const bar=ROWCTL.bars[row]; const lvl=bar.stacks.lvl.userData.val; const send=bar.stacks.send.userData.val; const width=(bar.stacks.width.userData.val-0.5)*2; const shape=bar.stacks.shape.userData.val; const octAdj=Math.round((bar.octave*2)-2);
    laneFX[row].laneWet.gain.setTargetAtTime(send, AC.currentTime, 0.05); laneFX[row].laneDry.gain.setTargetAtTime(1-send, AC.currentTime, 0.05); laneFX[row].pan.pan.setTargetAtTime((row-3.5)/3.5 * width, AC.currentTime, 0.05);
    const V=Math.max(0,Math.min(3,vel))/3; const velGain=0.2+0.8*V; const rowGain=0.15+0.85*lvl; const vfinal=velGain*rowGain; const cell=GRID.cells[row][step]; cell.userData.pulse(V);
    const degShift = (bar.sync? 0 : Math.round(bar.swing*2));
    switch(row){
      case 0: activeVoices[0].start(1+V*2); break;
      case 1: activeVoices[1].start(1+V*2); break;
      case 2: activeVoices[2].start(1+V*2); break;
      case 3: { const deg=(step%4)*2 + (progression[progressionIdx%progression.length]) + degShift; const f=degreeToFreq(deg, -1+octAdj); activeVoices[3].start(f*(1+bar.chorus*0.02), vfinal, 0.18+0.04*V, shape); } break;
      case 4: { const deg=progression[progressionIdx%progression.length] + degShift; const f=degreeToFreq(deg, 0+octAdj); activeVoices[4].start(f, vfinal, shape); } break;
      case 5: { const deg=(step%7) + degShift; const f=degreeToFreq(deg, 1+octAdj); activeVoices[5].start(f*(1-bar.chorus*0.02), vfinal, 0.16+0.05*V, shape); } break;
      case 6: { const deg=((step*3)%5) + degShift; const f=degreeToFreq(deg, 0+octAdj); activeVoices[6].start(f, vfinal, 0.1+0.05*V, shape); } break;
      case 7: { const f=degreeToFreq((step%5) + degShift, 2+octAdj); activeVoices[7].start(f, vfinal, 0.2, shape); } break;
    }
  }
  function tick(){ step=(step+1)%GRID.cols; if(step%4===0) progressionIdx=(progressionIdx+1)%progression.length; moveCursor(); for(let r=0;r<GRID.rows;r++){ evolveRow(r); const v=pattern[r][step]; if(v>0 && shouldFire(r)) trig(r,v); } }

  // ===== Picking & Interaction
  const ray=new THREE.Raycaster(); const v2=new THREE.Vector2();
  function pickMeshesAt(x,y){ v2.x=(x/innerWidth)*2-1; v2.y=-(y/innerHeight)*2+1; ray.setFromCamera(v2,camera); const objs=[]; GRID.cells.forEach(row=>row.forEach(s=>objs.push(...s.children))); return ray.intersectObjects(objs); }

  canvas.addEventListener('pointerdown',e=>{
    const hits=pickMeshesAt(e.clientX,e.clientY); if(!hits.length){ return; }
    const parent=hits[0].object.parent;
    if(parent.userData.rc){ const [r,c]=parent.userData.rc; selected={row:r,col:c}; openPopupForRow(r); const pressTimer=setTimeout(()=>{ pattern[r][c]=3; parent.userData.active=3; parent.userData.pulse(1); camTarget.copy(parent.position); fitLook(); toast('R'+(r+1)+'@'+(c+1)+' vel3'); vibrate(); },420); const up=()=>{ clearTimeout(pressTimer); window.removeEventListener('pointerup',up); if(pattern[r][c]===0){ pattern[r][c]=1; } else if(pattern[r][c]===1){ pattern[r][c]=2; } else if(pattern[r][c]===2){ pattern[r][c]=0; } parent.userData.active=pattern[r][c]; parent.userData.pulse(pattern[r][c]/3); }; window.addEventListener('pointerup',up,{once:true}); }
  });

  // Row label double‚Äëtap
  function wireRowLabelDoubleTap(){ GRID.labels.forEach(lbl=>{ lbl.onpointerdown=(e)=>{ const now=performance.now(); if(lbl._t && now-lbl._t<300){ camTarget.set(GRID.origin.x+4, 8, GRID.origin.z + lbl.userData.row*GRID.gapZ); openPopupForRow(lbl.userData.row); toast('Focus row '+(lbl.userData.row+1)); vibrate(); } lbl._t=now; }; }); }
  wireRowLabelDoubleTap();

  // ===== Top dock controls
  qsa('[data-btn]').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const k=btn.getAttribute('data-btn');
      if(k==='start'){
        if(!started){ const ok=await audioInit(); if(!ok) return; try{ if(AC.state==='suspended') await AC.resume(); }catch{} buildVoices(); started=true; startClock(); playing=true; loadPreset('BASIC'); toast('Playing'); }
        else { playing=!playing; toast(playing?'Play':'Pause'); }
      }
      if(k==='orbit'){ orbit=!orbit; btn.textContent=orbit?'‚óè':'‚óã'; }
      if(k==='fit'){ fitFrustum(); }
      if(k==='zoomIn'){ dist=Math.max(80,dist-15); const yaw=Math.atan2(camera.position.z,camera.position.x); camera.position.set(Math.cos(yaw)*dist, camera.position.y, Math.sin(yaw)*dist); fitLook(); }
      if(k==='zoomOut'){ dist=Math.min(420,dist+15); const yaw=Math.atan2(camera.position.z,camera.position.x); camera.position.set(Math.cos(yaw)*dist, camera.position.y, Math.sin(yaw)*dist); fitLook(); }
      if(k==='packPrev'){ applyPack(--packIdx); }
      if(k==='packNext'){ applyPack(++packIdx); }
      if(k==='theme'){ const cur=body.getAttribute('data-theme')||'dark'; const order=['dark','light','news']; const idx=order.indexOf(cur); const want=order[(idx+1)%order.length]; if(want==='dark') body.removeAttribute('data-theme'); else body.setAttribute('data-theme', want); toast('Theme: '+(body.getAttribute('data-theme')||'dark')); }
      if(k==='labels'){ labelsOn=!labelsOn; GRID.labels.forEach(l=>l.visible=labelsOn); toast('Labels '+(labelsOn?'ON':'OFF')); }
      if(k==='debug'){ debugMode=!debugMode; toast('Debug '+(debugMode?'ON':'OFF')); GRID.cursor.visible=!debugMode; }
      if(k==='view'){ viewIdx=(viewIdx+1)%VIEWS.length; applyView(); }
      if(k==='density'){
        const den=+btn.getAttribute('data-den'); GRID.cols=den; for(let r=0;r<GRID.rows;r++){ pattern[r].length=GRID.cols; for(let c=0;c<GRID.cols;c++){ if(typeof pattern[r][c]!=="number") pattern[r][c]=0; } }
        buildGrid(); buildRowControllers(); wireRowLabelDoubleTap(); refreshLayoutPositions(); toast('Density '+den+'√ó');
      }
    });
  });

  // Camera drag + pinch zoom
  let draggingCam=null; let pinch=null;
  canvas.addEventListener('pointerdown',e=>{ draggingCam={x:e.clientX,y:e.clientY, yaw:Math.atan2(camera.position.z,camera.position.x), pitch:Math.asin((camera.position.y-50)/dist)}; });
  addEventListener('pointermove',e=>{ if(!draggingCam) return; const dx=e.clientX-draggingCam.x; const dy=e.clientY-draggingCam.y; const yaw=draggingCam.yaw - dx*0.005; const pitch=Math.max(-1.2,Math.min(1.2, draggingCam.pitch - dy*0.003)); const cx=Math.cos(yaw)*dist, cz=Math.sin(yaw)*dist, cy=50+Math.sin(pitch)*70; camera.position.set(cx,cy,cz); fitLook(); });
  addEventListener('pointerup',()=>{ draggingCam=null; });
  addEventListener('touchstart',e=>{ if(e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX; const dy=e.touches[0].clientY-e.touches[1].clientY; pinch={d:Math.hypot(dx,dy)}; } },{passive:false});
  addEventListener('touchmove',e=>{ if(pinch && e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX; const dy=e.touches[0].clientY-e.touches[1].clientY; const nd=Math.hypot(dx,dy); const k=nd/(pinch.d||1); pinch.d=nd; dist=Math.max(90,Math.min(420, dist/(k||1))); e.preventDefault(); } },{passive:false});
  addEventListener('touchend',()=>{ pinch=null; });

  // Resize
  addEventListener('resize',()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); autoSpacing(); refreshLayoutPositions(); });

  // ===== Animation
  function animate(){ requestAnimationFrame(animate); if(orbit){ const yaw=Math.atan2(camera.position.z,camera.position.x)+0.004; camera.position.x=Math.cos(yaw)*dist; camera.position.z=Math.sin(yaw)*dist; camera.position.y=60+Math.sin(yaw*0.6)*20; fitLook(); } renderer.render(scene,camera); }
  animate();

  // ===== Tests (keep, and add a couple more)
  (function tests(){ try{ const results=[]; const ok=(n,p)=>results.push({test:n,pass:!!p});
    ok('THREE present', !!window.THREE);
    ok('Grid 8xN', GRID.cells.length===8 && GRID.cells[0].length===GRID.cols);
    ok('Row controllers data-only', Array.isArray(ROWCTL.bars) && ROWCTL.bars.length===8 && !('group' in ROWCTL));
    ok('Sheet exists', !!document.getElementById('sheet'));
    openPopupForRow(0); ok('Open sheet for row 1', document.getElementById('sheet').classList.contains('show')); closeSheet(); ok('Close sheet', !document.getElementById('sheet').classList.contains('show'));
    // extra: theme toggle and density
    const prevTheme=document.body.getAttribute('data-theme')||'dark';
    document.querySelector('[data-btn="theme"]').click();
    ok('Theme toggled', (document.body.getAttribute('data-theme')||'dark')!==prevTheme || prevTheme!=='dark');
    const prevCols=GRID.cols; const denBtn=document.querySelector('[data-btn="density"][data-den="8"]'); if(denBtn){ denBtn.click(); ok('Density changed', GRID.cols!==prevCols); }
    console.table(results);
  }catch(e){ console.error('Test error', e); } })();
})();
</script>
</body>
</html>
