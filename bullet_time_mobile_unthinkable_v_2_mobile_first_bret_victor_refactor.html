<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Bullet Time Camera Array ‚Äî Mobile Unthinkable</title>
<style>
  :root{
    --bg:#000; --ink:#d7ffe2; --ui:#00ff88; --muted:#0a2217; --warn:#ff4b72; --shadow:rgba(0,255,136,0.18);
    --ring:#082b1f; --accent:#00ff88; --panel:rgba(0,0,0,0.85); --panel2:rgba(0,0,0,0.65);
    --pad:12px; --radius:14px; --touch:44px; --focus:0 0 0 2px rgba(0,255,136,0.65);
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Inter,Roboto,Arial,sans-serif;}
  #stage{position:fixed;inset:0;overflow:hidden}
  canvas{display:block}

  /* === Top HUD (compact, high-contrast, non-overlapping) === */
  .hud{position:fixed;top:8px;left:8px;right:8px;display:flex;gap:8px;align-items:center;z-index:30}
  .chip{min-height:var(--touch);padding:0 14px;border:2px solid var(--ui);border-radius:12px;background:var(--panel);
        color:var(--ink);display:flex;align-items:center;gap:10px;font-weight:700;letter-spacing:1px;text-transform:uppercase;box-shadow:0 8px 24px var(--shadow)}
  .chip .big{font-size:18px}
  .chip .mono{font-family:"Courier New",monospace}
  .chip button{background:transparent;border:none;color:var(--ink);font-weight:800;font-size:18px}
  .chip button:active{transform:scale(.95)}

  /* === Right Mini-Map (Ring Buffer) === */
  #ring{position:fixed;top:8px;right:8px;width:132px;height:132px;border:2px solid var(--ui);border-radius:50%;
        background:radial-gradient(100% 100% at 50% 50%, #04130e 0%, #000 70%);box-shadow:0 8px 24px var(--shadow);z-index:20}
  #ring canvas{width:100%;height:100%;}

  /* === Bottom Sheet Controls (mobile-first) === */
  .sheet{position:fixed;left:0;right:0;bottom:0;z-index:40;padding:10px 10px 12px;background:linear-gradient(0deg, rgba(0,0,0,0.95), rgba(0,0,0,0.6));backdrop-filter:blur(4px)}
  .controls{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:8px}
  .btn{height:var(--touch);border-radius:12px;border:2px solid var(--ui);background:var(--panel);color:var(--ink);font-weight:800}
  .btn[aria-pressed="true"], .btn.active{background:var(--ui);color:#00130b}
  .btn:active{transform:scale(.98)}
  .row{display:flex;align-items:center;gap:10px;margin:6px 4px}
  .row label{font-size:12px;opacity:.9;width:96px}
  input[type=range]{flex:1;height:32px;-webkit-appearance:none;background:var(--panel2);border-radius:12px;border:1px solid var(--ui)}
  input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:24px;height:24px;border-radius:50%;background:var(--ui);box-shadow:0 0 0 3px #00130b}

  /* === Timeline (scrubbable) === */
  #timeline{position:relative;height:56px;margin:6px 4px;border:2px solid var(--ui);border-radius:12px;background:linear-gradient(180deg,#00160e,#000)}
  #progress{position:absolute;top:50%;left:0;height:3px;background:var(--ui);box-shadow:0 0 10px var(--ui);transform:translateY(-50%);width:0}
  .tick{position:absolute;top:8px;width:2px;height:16px;background:#0a3}
  .marker{position:absolute;bottom:8px;width:10px;height:10px;border:2px solid var(--ui);border-radius:50%;background:#063}
  .marker.active{width:18px;height:18px;background:var(--ui);box-shadow:0 0 16px var(--ui)}

  /* === Debug Drawer (Surfaces the Invisible) === */
  details.debug{position:fixed;left:8px;bottom:130px;max-width:min(92vw,520px);z-index:50}
  details.debug>summary{cursor:pointer;list-style:none;min-height:var(--touch);display:flex;align-items:center;gap:10px;padding:0 14px;border:2px solid var(--ui);border-radius:12px;background:var(--panel);box-shadow:0 8px 24px var(--shadow);font-weight:800}
  .dbg{margin-top:8px;padding:10px;border:2px solid var(--ui);border-radius:12px;background:var(--panel)}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:6px 10px;font-family:"Courier New",monospace;font-size:12px}
  .log{max-height:120px;overflow:auto;border-top:1px solid #063;margin-top:8px;padding-top:6px;font-family:"Courier New",monospace;font-size:12px}
  #wave{width:100%;height:64px;border:1px dashed #063;border-radius:10px;margin-top:6px}
  .tests{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .tests .mini{border:2px solid var(--ui);background:var(--panel2);color:var(--ink);border-radius:10px;padding:8px 10px;font-weight:800}

  /* Path pills (left column) */
  .paths{position:fixed;left:8px;top:64px;display:flex;flex-direction:column;gap:8px;z-index:25;max-height:45vh;overflow:auto}
  .pill{min-height:36px;display:flex;align-items:center;gap:8px;padding:6px 10px;border:2px solid var(--ui);border-radius:20px;background:var(--panel);font-weight:700}
  .pill.active{background:var(--ui);color:#00130b}

  @media (max-width:480px){
    .controls{grid-template-columns:repeat(2,1fr)}
    .paths{top:auto;bottom:210px;flex-direction:row;max-width:96vw;max-height:none}
  }

  /* Focus ring */
  :focus-visible{outline:none;box-shadow:var(--focus)}

  /* === Modal (Clipboard Fallback) === */
  #modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.65);backdrop-filter:blur(6px);z-index:60}
  .modal-card{width:min(92vw,720px);max-height:80vh;border:2px solid var(--ui);border-radius:16px;background:var(--panel);box-shadow:0 8px 24px var(--shadow);padding:12px;display:flex;flex-direction:column;gap:8px}
  .modal-card header{display:flex;align-items:center;justify-content:space-between;font-weight:800}
  .modal-card textarea{width:100%;height:48vh;border:1px dashed #063;border-radius:10px;background:#000;color:var(--ink);padding:10px;font-family:"Courier New",monospace}
  .modal-actions{display:flex;gap:8px;flex-wrap:wrap}
  .toast{position:fixed;left:50%;bottom:96px;transform:translateX(-50%);padding:10px 14px;border:2px solid var(--ui);border-radius:12px;background:var(--panel);color:var(--ink);font-weight:800;z-index:70;display:none}
</style>
</head>
<body>
  <div id="stage"></div>

  <!-- Top HUD -->
  <div class="hud" role="toolbar" aria-label="HUD">
    <div class="chip" aria-live="polite"><span>Cam</span><span id="camNo" class="big mono">01</span></div>
    <div class="chip" aria-live="polite"><span id="pathName">STRAIGHT</span></div>
    <button id="helpBtn" class="chip" aria-label="Show template prompt">‚ùì Help</button>
  </div>

  <!-- Mini-map Ring -->
  <div id="ring"><canvas id="ringCanvas" width="300" height="300" aria-label="Mini-map"></canvas></div>

  <!-- Path Pills -->
  <div id="paths" class="paths" aria-label="Path selector"></div>

  <!-- Debug Drawer -->
  <details class="debug" id="debugDrawer">
    <summary>üî¨ Debug & State</summary>
    <div class="dbg">
      <div class="kv" id="kv"></div>
      <canvas id="wave"></canvas>
      <div class="tests">
        <button id="testCopy" class="mini">‚ñ∂ Clipboard Test</button>
        <button id="testAudio" class="mini">‚ñ∂ Audio Test</button>
        <button id="testVibe" class="mini">‚ñ∂ Vibrate Test</button>
      </div>
      <div class="log" id="log"></div>
    </div>
  </details>

  <!-- Bottom Sheet Controls -->
  <div class="sheet" aria-label="Transport and parameters">
    <div class="controls">
      <button id="play" class="btn" aria-pressed="true">‚è∏Ô∏é Pause</button>
      <button id="dir" class="btn">‚ñ∂Ô∏é Fwd</button>
      <button id="viz" class="btn" aria-pressed="true">üì∑ Rigs</button>
      <button id="audio" class="btn" aria-pressed="true">üîä Audio</button>
    </div>
    <div class="row"><label for="speed">Speed <span id="speedVal">1.0√ó</span></label><input id="speed" type="range" min="0.1" max="8" step="0.1" value="1"/></div>
    <div class="row"><label for="cams">Cameras <span id="camsVal">48</span></label><input id="cams" type="range" min="12" max="72" step="1" value="48"/></div>
    <div class="row"><label for="radius">Radius <span id="radVal">25</span></label><input id="radius" type="range" min="8" max="60" step="1" value="25"/></div>
    <div id="timeline" aria-label="Camera timeline"><div id="progress"></div></div>
  </div>

  <!-- Modal (Clipboard Fallback) -->
  <div id="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle" aria-describedby="modalDesc">
    <div class="modal-card">
      <header>
        <div id="modalTitle">Bret Victor Template</div>
        <button id="modalClose" class="mini" aria-label="Close">‚úï</button>
      </header>
      <div id="modalDesc" class="kv" style="gap:8px 12px">
        <div>Tip</div><div>If clipboard is blocked (HTTP, sandbox, or permissions policy), select and copy from the text below or use Download.</div>
      </div>
      <textarea id="modalText" spellcheck="false"></textarea>
      <div class="modal-actions">
        <button id="modalCopy" class="mini">Copy</button>
        <button id="modalSelect" class="mini">Select All</button>
        <button id="modalDownload" class="mini">Download .txt</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <!-- Bret Victor Template (hidden) -->
  <template id="bvTemplate">
Title: Apply ‚ÄúMedia for Thinking the Unthinkable‚Äù to Bullet Time Camera Array
Prompt:
You are an interface designer tasked with transforming the Bullet Time Camera Array into a medium that:
1) Surfaces the Invisible ‚Üí Overlay currentCam, phase, stride waveform, mini-map of camera positions, and link lines to subject. Show FPS, audio state, rig visibility. 
2) Overcomes Cognitive Limits ‚Üí Allow time expansion/compression via speed slider (0.1√ó‚Äì8√ó); visualize out-of-band leg motion as a normalized waveform. 
3) Supports Multiple Modes ‚Üí Interactive: scrubbable timeline & swipe-to-step; Visual: mini-map + rig highlights; Symbolic: live key‚Äìvalue state & event log. 
4) Enables Rapid What-If ‚Üí Sliders for cameras/radius/speed with instant rebuild; play/pause and direction toggle; long-press to toggle rigs. 
5) Links Perspectives ‚Üí Synchronize renderer view, ring mini-map, timeline, and debug drawer; tapping a timeline marker selects that camera and updates all views. 
6) Abstracts & Generalizes ‚Üí Save snapshots (path, cam count, radius, speed) to localStorage (not included by default, but stubs provided). 
Instructions: Propose concrete UI/code changes; prototype; evaluate how each unlocks previously hidden structure.
  </template>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
  // ======= Core State =======
  let scene, renderer, rigs = [], cams = [], subject, playing = true, dir = 1, speed = 1.0;
  let CAM_COUNT = 48, RADIUS = 25, current = 0, lastNow = 0, visited = new Set([0]), fps = 0;
  let showRigs = true, audioOn = true, audioCtx = null; 
  const logEl = document.getElementById('log');
  const kvEl = document.getElementById('kv');
  const ringCanvas = document.getElementById('ringCanvas');
  const waveCanvas = document.getElementById('wave');
  const toast = document.getElementById('toast');

  const PATHS = {
    straight:{name:'STRAIGHT', cam:(i,n)=>{const t=i/(n-1);return {pos:new THREE.Vector3(-40+ t*80, 5, 20), look:new THREE.Vector3(-40+t*80,2,0)}} , horse:p=>({x:-35+p*70,z:0,r:0})},
    arc180:{name:'180¬∞ ARC', cam:(i,n)=>{const a=Math.PI*(i/(n-1))-Math.PI/2; return {pos:new THREE.Vector3(Math.cos(a)*RADIUS,7,Math.sin(a)*RADIUS), look:new THREE.Vector3(0,2,0)}} , horse:p=>({x:0,z:0,r:0})},
    orbit360:{name:'360¬∞ ORBIT', cam:(i,n)=>{const a=(i/n)*Math.PI*2; return {pos:new THREE.Vector3(Math.cos(a)*RADIUS,8,Math.sin(a)*RADIUS), look:new THREE.Vector3(0,2.5,0)}} , horse:p=>({x:0,z:0,r:Math.PI/4})},
    closeup:{name:'CLOSEUP ARC', cam:(i,n)=>{const a=Math.PI*(i/(n-1))-Math.PI/2; return {pos:new THREE.Vector3(Math.cos(a)*Math.max(12,RADIUS*0.5),3.5,Math.sin(a)*Math.max(12,RADIUS*0.5)), look:new THREE.Vector3(0,2,0)}} , horse:p=>({x:0,z:0,r:0})},
    overhead:{name:'OVERHEAD', cam:(i,n)=>{const t=i/(n-1); return {pos:new THREE.Vector3(-30+t*60, 25, 0), look:new THREE.Vector3(-30+t*60,0,0)}} , horse:p=>({x:-30+p*60,z:0,r:0})},
    spiral:{name:'SPIRAL UP', cam:(i,n)=>{const a=(i/n)*Math.PI*5; const r=18+(i/n)*12; const h=3+(i/n)*15; return {pos:new THREE.Vector3(Math.cos(a)*r, h, Math.sin(a)*r), look:new THREE.Vector3(0,2,0)}} , horse:p=>({x:0,z:0,r:p*Math.PI*2})}
  };
  let pathKey = 'straight';

  // ======= Utilities =======
  function log(msg){ const t = new Date().toLocaleTimeString(); logEl.innerHTML = `<div>[${t}] ${msg}</div>` + logEl.innerHTML; const max=80; const kids=logEl.children; if(kids.length>max) kids[max-1].remove(); }
  function setKV(entries){ kvEl.innerHTML = entries.map(([k,v])=>`<div>${k}</div><div>${v}</div>`).join(''); }
  function beep(freq=700,dur=0.03){ if(!audioOn||!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='square'; o.frequency.value=freq; g.gain.setValueAtTime(0.08,audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.005,audioCtx.currentTime+dur); o.connect(g).connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+dur); }
  function vibe(ms=10){ if(navigator.vibrate) navigator.vibrate(ms); }
  function showToast(text){ toast.textContent=text; toast.style.display='block'; clearTimeout(showToast.t); showToast.t=setTimeout(()=>toast.style.display='none', 1400); }

  // Clipboard helpers with robust fallbacks
  async function safeCopy(text){
    // Try modern API first in secure contexts
    try{
      if(window.isSecureContext && navigator.clipboard && typeof navigator.clipboard.writeText==='function'){
        await navigator.clipboard.writeText(text); return {ok:true, method:'navigator.clipboard'};
      }
    }catch(e){ /* continue to fallbacks */ }
    // Fallback to execCommand
    try{
      const ta = document.createElement('textarea');
      ta.value = text; ta.setAttribute('readonly','');
      ta.style.position='fixed'; ta.style.left='-9999px'; ta.style.top='-9999px';
      document.body.appendChild(ta); ta.select(); ta.setSelectionRange(0, ta.value.length);
      const success = document.execCommand('copy'); document.body.removeChild(ta);
      if(success) return {ok:true, method:'execCommand'};
    }catch(e){ /* ignore */ }
    return {ok:false};
  }

  function openPromptModal(text){
    const modal = document.getElementById('modal');
    const ta = document.getElementById('modalText');
    ta.value = text; modal.style.display='flex';
    // Try to preserve selection for faster manual copy
    setTimeout(()=>{ ta.focus(); ta.select(); }, 50);
  }

  function downloadText(filename, text){
    const blob = new Blob([text], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }

  // ======= Scene Setup =======
  function init(){
    scene = new THREE.Scene(); scene.background = new THREE.Color(0x000000); scene.fog = new THREE.Fog(0x000000, 80, 180);
    renderer = new THREE.WebGLRenderer({antialias:true,powerPreference:'high-performance'});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 1.6));
    renderer.setSize(innerWidth, innerHeight);
    document.getElementById('stage').appendChild(renderer.domElement);

    const amb = new THREE.AmbientLight(0xffffff, 0.55); scene.add(amb);
    const key = new THREE.DirectionalLight(0xffffff, 1.3); key.position.set(35, 40, 28); scene.add(key);
    const rim = new THREE.DirectionalLight(0x00ff88, 0.5); rim.position.set(-10, 14, -28); scene.add(rim);

    const ground = new THREE.Mesh(new THREE.PlaneGeometry(280,280), new THREE.MeshStandardMaterial({color:0x020202, roughness:0.95, metalness:0.05}));
    ground.rotation.x = -Math.PI/2; scene.add(ground);

    // Subject (stylized horse proxy)
    subject = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({color:0x0b0b0b, metalness:0.5, roughness:0.5, emissive:0x002a17, emissiveIntensity:0.15});
    const body = new THREE.Mesh(new THREE.BoxGeometry(5.4,2.3,1.8),mat); body.position.y=2.4; subject.add(body);
    const neck = new THREE.Mesh(new THREE.BoxGeometry(1.5,3,1.3),mat); neck.position.set(3,3.2,0); neck.rotation.z = 0.5; subject.add(neck);
    const head = new THREE.Mesh(new THREE.BoxGeometry(1.5,1.5,1.2),mat); head.position.set(4.2,5,0); head.rotation.z = 0.2; subject.add(head);
    const legG = new THREE.CylinderGeometry(0.22,0.19,2.7);
    subject.legs = [];
    [ {x:2.1,z:0.7,p:0}, {x:2.1,z:-0.7,p:Math.PI}, {x:-1.9,z:0.7,p:Math.PI*0.6}, {x:-1.9,z:-0.7,p:Math.PI*1.6} ].forEach(d=>{ const leg=new THREE.Mesh(legG,mat); leg.position.set(d.x,1.35,d.z); leg.userData={bx:d.x, ph:d.p}; subject.add(leg); subject.legs.push(leg); });
    scene.add(subject);

    buildPaths();
    rebuildCameras();

    addHandlers();
    requestAnimationFrame(tick);
    log('Initialized');
  }

  function buildPaths(){
    const wrap = document.getElementById('paths');
    wrap.innerHTML = '';
    Object.keys(PATHS).forEach(k=>{
      const b=document.createElement('button'); b.className='pill'+(k===pathKey?' active':''); b.textContent=PATHS[k].name; b.onclick=()=>{pathKey=k; current=0; visited=new Set([0]); rebuildCameras(); updateHUD(); beep(900,0.04); vibe(14);}; wrap.appendChild(b);
    });
  }

  function rebuildCameras(){
    // Remove old rigs
    rigs.forEach(r=>scene.remove(r)); rigs=[]; cams=[];
    const P = PATHS[pathKey];
    for(let i=0;i<CAM_COUNT;i++){
      const cfg = P.cam(i, CAM_COUNT);
      const cam = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.5, 400);
      cam.position.copy(cfg.pos); cam.lookAt(cfg.look); cams.push(cam);
      const rig = new THREE.Group();
      const body = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.4,0.6), new THREE.MeshStandardMaterial({color:0x00ff88, emissive:0x00ff88, emissiveIntensity:0.35, metalness:0.7, roughness:0.2}));
      const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.18,0.25), new THREE.MeshStandardMaterial({color:0x00ff88, emissive:0x00ff88, emissiveIntensity:0.6})); lens.rotation.x=Math.PI/2; lens.position.z=0.4; rig.add(body); rig.add(lens); rig.position.copy(cfg.pos); rig.lookAt(cfg.look); rig.visible = showRigs; scene.add(rig); rigs.push(rig);
    }
    drawRing();
    buildTimeline();
    updateHUD();
  }

  // ======= UI Wiring =======
  function addHandlers(){
    // Transport buttons
    const playBtn = document.getElementById('play');
    const dirBtn = document.getElementById('dir');
    const vizBtn = document.getElementById('viz');
    const audioBtn = document.getElementById('audio');

    playBtn.onclick = ()=>{ playing=!playing; playBtn.textContent = playing? '‚è∏Ô∏é Pause':'‚ñ∂Ô∏é Play'; playBtn.setAttribute('aria-pressed', String(playing)); beep(playing?800:500,0.04); vibe(12); };
    dirBtn.onclick = ()=>{ dir *= -1; dirBtn.textContent = dir<0 ? '‚óÄÔ∏é Rev' : '‚ñ∂Ô∏é Fwd'; dirBtn.classList.toggle('active', dir<0); beep(dir<0?420:820,0.04); vibe(12); };
    vizBtn.onclick = ()=>{ showRigs=!showRigs; rigs.forEach(r=>r.visible=showRigs); vizBtn.setAttribute('aria-pressed', String(showRigs)); beep(showRigs?1000:600,0.03); vibe(10); };
    audioBtn.onclick = ()=>{ audioOn=!audioOn; if(audioOn && !audioCtx){ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); } audioBtn.setAttribute('aria-pressed', String(audioOn)); beep(920,0.03); vibe(8); };

    // Sliders
    const speedR = document.getElementById('speed');
    const camsR = document.getElementById('cams');
    const radiusR = document.getElementById('radius');
    const speedVal = document.getElementById('speedVal');
    const camsVal = document.getElementById('camsVal');
    const radVal = document.getElementById('radVal');

    speedR.oninput = ()=>{ speed = Number(speedR.value); speedVal.textContent = speed.toFixed(1)+'√ó'; };
    camsR.onchange = ()=>{ CAM_COUNT = Number(camsR.value); camsVal.textContent = CAM_COUNT; current = Math.min(current, CAM_COUNT-1); visited = new Set([current]); rebuildCameras(); beep(700,0.03); vibe(12); };
    radiusR.oninput = ()=>{ RADIUS = Number(radiusR.value); radVal.textContent = RADIUS; rebuildCameras(); };

    // Timeline scrubbing
    const tl = document.getElementById('timeline');
    let scrub=false;
    const getIdx = (x)=> Math.max(0, Math.min(CAM_COUNT-1, Math.round((x - tl.getBoundingClientRect().left) / tl.clientWidth * (CAM_COUNT-1))));
    const toIdx = (i)=>{ current=i; visited.add(i); updateHUD(); beep(500 + (i/CAM_COUNT)*400, 0.02); vibe(6); };
    tl.addEventListener('pointerdown', e=>{ scrub=true; toIdx(getIdx(e.clientX)); });
    window.addEventListener('pointermove', e=>{ if(scrub) toIdx(getIdx(e.clientX)); });
    window.addEventListener('pointerup', ()=>{ scrub=false; });

    // Gestures: swipe to step, long-press to toggle rigs
    let x0=0, lpTimer=null;
    window.addEventListener('touchstart', e=>{ const t=e.touches[0]; x0=t.clientX; lpTimer=setTimeout(()=>{ showRigs=!showRigs; rigs.forEach(r=>r.visible=showRigs); vizBtn.setAttribute('aria-pressed', String(showRigs)); log('Long-press: toggle rigs'); }, 500); }, {passive:true});
    window.addEventListener('touchmove', e=>{ if(!x0) return; const dx=e.touches[0].clientX - x0; if(Math.abs(dx)>40){ clearTimeout(lpTimer); x0=0; toIdx((current + (dx>0?-1:1) + CAM_COUNT)%CAM_COUNT); } }, {passive:true});
    window.addEventListener('touchend', ()=>{ clearTimeout(lpTimer); x0=0; }, {passive:true});

    // === Help: Copy with fallbacks, else show modal ===
    document.getElementById('helpBtn').onclick = async ()=>{
      const txt = document.getElementById('bvTemplate').content.textContent.trim();
      const res = await safeCopy(txt);
      if(res.ok){ showToast('Template copied ('+res.method+').'); log('Clipboard success via '+res.method); }
      else { openPromptModal(txt); log('Clipboard blocked; opened modal fallback.'); }
    };

    // Modal controls
    document.getElementById('modalClose').onclick = ()=>{ document.getElementById('modal').style.display='none'; };
    document.getElementById('modalSelect').onclick = ()=>{ const ta=document.getElementById('modalText'); ta.focus(); ta.select(); showToast('Selected ‚Äî tap Copy'); };
    document.getElementById('modalCopy').onclick = async ()=>{ const ta=document.getElementById('modalText'); const res=await safeCopy(ta.value); if(res.ok){ showToast('Copied ('+res.method+').'); } else { showToast('Copy still blocked ‚Äî use Select All'); } };
    document.getElementById('modalDownload').onclick = ()=>{ const txt=document.getElementById('modalText').value; downloadText('BV_template.txt', txt); };

    // Self-tests
    document.getElementById('testCopy').onclick = async ()=>{
      const demo = 'Clipboard self-test @ ' + new Date().toISOString();
      const res = await safeCopy(demo);
      log(res.ok? ('TEST PASS: copied using '+res.method) : 'TEST FAIL: clipboard blocked ‚Äî modal will be used at runtime');
      if(res.ok) showToast('Clipboard OK'); else showToast('Clipboard blocked');
    };
    document.getElementById('testAudio').onclick = ()=>{ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); beep(880,0.05); log('Audio test beep'); };
    document.getElementById('testVibe').onclick = ()=>{ vibe(15); log('Vibrate test fired'); };

    // Audio init on first tap anywhere
    window.addEventListener('pointerdown', ()=>{ if(!audioCtx && audioOn){ audioCtx = new (window.AudioContext||window.webkitAudioContext)(); beep(880,0.02); } }, {once:true});

    window.addEventListener('resize', onResize);
  }

  function onResize(){
    cams.forEach(c=>{ c.aspect = innerWidth/innerHeight; c.updateProjectionMatrix(); });
    renderer.setSize(innerWidth, innerHeight);
  }

  // ======= Timeline & Ring =======
  function buildTimeline(){
    const tl = document.getElementById('timeline');
    tl.querySelectorAll('.tick,.marker').forEach(n=>n.remove());
    for(let i=0;i<CAM_COUNT;i++){
      if(i%6===0 || i===CAM_COUNT-1){ const t=document.createElement('div'); t.className='tick'; t.style.left = (i/(CAM_COUNT-1))*100+'%'; tl.appendChild(t); }
      const m=document.createElement('div'); m.className='marker'; m.style.left = (i/(CAM_COUNT-1))*100+'%'; m.onclick=()=>{ current=i; visited.add(i); updateHUD(); }; tl.appendChild(m);
    }
  }

  function updateTimeline(){
    const tl = document.getElementById('timeline');
    const progress = document.getElementById('progress');
    const ms = tl.querySelectorAll('.marker');
    ms.forEach((m,i)=>{ m.classList.toggle('active', i===current); });
    progress.style.width = ((current+1)/CAM_COUNT*100)+'%';
  }

  function drawRing(){
    const ctx = ringCanvas.getContext('2d');
    const w = ringCanvas.width, h = ringCanvas.height; const cx=w/2, cy=h/2; ctx.clearRect(0,0,w,h);
    const P = PATHS[pathKey];
    // subject (red)
    const hp = P.horse(current/CAM_COUNT); const hx=cx + (hp.x/60)*(w*0.42); const hy=cy + (hp.z/60)*(h*0.42);
    // cameras
    for(let i=0;i<CAM_COUNT;i++){
      const cfg = P.cam(i, CAM_COUNT); const x=cx + (cfg.pos.x/60)*(w*0.42); const y=cy + (cfg.pos.z/60)*(h*0.42);
      ctx.beginPath(); ctx.arc(x,y, i===current?9:5, 0, Math.PI*2); ctx.fillStyle = i===current? '#00ff88' : (visited.has(i)? '#0a5':'#032'); ctx.fill(); if(i===current){ ctx.lineWidth=3; ctx.strokeStyle='#00ff88'; ctx.stroke(); }
    }
    // link
    const ccfg = P.cam(current, CAM_COUNT); const cx2=cx+(ccfg.pos.x/60)*(w*0.42); const cy2=cy+(ccfg.pos.z/60)*(h*0.42);
    ctx.beginPath(); ctx.moveTo(cx2,cy2); ctx.lineTo(hx,hy); ctx.lineWidth=2; ctx.strokeStyle='rgba(0,255,136,0.7)'; ctx.stroke();
    ctx.beginPath(); ctx.arc(hx,hy,7,0,Math.PI*2); ctx.fillStyle='#ff3355'; ctx.fill();
  }

  // ======= Subject Motion & Waveform =======
  function updateSubject(phase, dt){
    const P = PATHS[pathKey];
    const pos = P.horse(phase);
    subject.position.set(pos.x, 0, pos.z); subject.rotation.y = pos.r;
    const stride = phase * Math.PI * 14;
    subject.legs.forEach(leg=>{ const lp = stride + leg.userData.ph; const lift = Math.max(0, Math.sin(lp))*1.8; leg.position.y = 1.35 + lift; const swing = Math.cos(lp)*0.75; leg.position.x = leg.userData.bx + swing; leg.rotation.z = Math.sin(lp)*0.45; });
    // Draw waveform of stride
    const ctx = waveCanvas.getContext('2d'); const w=waveCanvas.width = waveCanvas.clientWidth; const h=waveCanvas.height = waveCanvas.clientHeight;
    ctx.clearRect(0,0,w,h); ctx.strokeStyle='#0a5'; ctx.lineWidth=2; ctx.beginPath();
    for(let x=0;x<w;x++){
      const t = (x/w)*Math.PI*2; const y = Math.sin(t + stride% (Math.PI*2)); const yy = (h/2) + y*(h/2 - 6); if(x===0) ctx.moveTo(0,yy); else ctx.lineTo(x,yy);
    }
    ctx.stroke();
  }

  // ======= HUD Update =======
  function updateHUD(){
    document.getElementById('camNo').textContent = String(current+1).padStart(2,'0');
    document.getElementById('pathName').textContent = PATHS[pathKey].name;
    drawRing(); updateTimeline();
    setKV([
      ['currentCam', current], ['visited', visited.size + '/' + CAM_COUNT], ['speed', speed.toFixed(2)], ['dir', dir<0?'REV':'FWD'], ['fps', fps.toFixed(0)], ['path', pathKey], ['radius', RADIUS], ['audio', String(audioOn)], ['rigs', String(showRigs)]
    ]);
  }

  // ======= Main Loop =======
  function tick(now=0){
    requestAnimationFrame(tick);
    const dt = Math.min((now-lastNow)/1000, 0.1); lastNow = now; fps = 1/Math.max(dt, 0.0001);
    if(playing){ // step cameras based on speed
      const step = speed * dt * dir; // convert to discrete cam steps ~ every ~0.06 sec at 1√ó
      tick.acc = (tick.acc||0) + step; 
      const stride = 0.06; // base cadence
      while(Math.abs(tick.acc) >= stride){ tick.acc -= Math.sign(tick.acc)*stride; current = (current + Math.sign(dir) + CAM_COUNT) % CAM_COUNT; visited.add(current); if(current%4===0) beep(520 + (current/CAM_COUNT)*360, 0.02); }
    }
    const phase = current / CAM_COUNT;
    updateSubject(phase, dt);
    updateHUD();
    renderer.render(scene, cams[current] || cams[0]);
  }

  // ======= Init =======
  init();
  </script>
</body>
</html>
