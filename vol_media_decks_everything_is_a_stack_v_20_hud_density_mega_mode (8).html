<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>SEA SEQUENCER — Pure Stacks v2.2</title>
<style>
  :root{
    --abyss:#03080f; --ink:#e9f6ff; --muted:#8fb4c9; --foam:#dff4ff;
    --shadow:0 22px 48px rgba(0,0,0,.58), 0 3px 16px rgba(0,0,0,.36);
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color:transparent; touch-action:none}
  html,body{height:100%}
  body{margin:0; background:radial-gradient(1200px 800px at 50% 40%, #081b2c 0%, var(--abyss) 60%); color:var(--ink); font:14px/1.2 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; overflow:hidden}
  canvas#scene{position:fixed; inset:0; display:block}

  /* HUD */
  #hud{position:fixed; inset:0; pointer-events:none}
  #paramDock{position:absolute; right:10px; top:10px; bottom:10px; display:none; gap:16px; pointer-events:auto; flex-direction:column; justify-content:flex-end}
  #safeBottom{position:fixed; left:0; right:0; bottom:0; height:118px; pointer-events:none}
  /* Alley — only control at boot */
  #alley{position:absolute; right:10px; top:10px; bottom:10px; display:flex; flex-direction:column; gap:16px; pointer-events:auto; justify-content:flex-end}

  /* Stack widgets (sliders look like stacks) */
  .stack{--w:84px; width:var(--w); height:140px; background:linear-gradient(180deg, rgba(170,220,255,.10), rgba(255,255,255,.02)); border:1px solid rgba(160,210,255,.24); border-radius:16px; box-shadow:var(--shadow); position:relative; overflow:hidden}
  .stack .glyph{position:absolute; right:4px; top:8px; bottom:8px; width:12px; writing-mode:vertical-rl; text-orientation:mixed; font-size:10px; letter-spacing:.06em; color:rgba(180,220,255,.75); display:flex; align-items:flex-start; justify-content:center; text-shadow:0 0 6px rgba(120,200,255,.25)}
  .stack .legend{position:absolute; bottom:6px; left:10px; font-size:10px; color:#cfe8ff; opacity:.75}
  .stack .layers{position:absolute; inset:16px 24px 22px 12px; display:flex; flex-direction:column; justify-content:flex-end; gap:6px}
  .stack .lay{height:10px; border-radius:6px; background:rgba(170,220,255,.17); box-shadow:0 0 12px rgba(120,200,255,.22)}
  .stack.accent{border-color:rgba(120,200,255,.60); box-shadow:0 0 0 1px rgba(120,200,255,.40), inset 0 0 34px rgba(120,200,255,.16), var(--shadow)}

  #colorPipe{position:fixed; left:0; right:0; bottom:0; height:3px; background:linear-gradient(90deg, #1c5d7a, #78d9ff); opacity:.55; pointer-events:none}
  @media (max-width:760px){ .stack{--w:76px; height:132px} #safeBottom{height:112px} }
</style>
</head>
<body>
  <canvas id="scene"></canvas>
  <div id="hud">
    <!-- PARAM surface (appears after tapping Alley OPEN) -->
    <div id="paramDock"></div>

    <!-- Alley: only control at boot; tall stacks, vertical labels on edge -->
    <div id="alley">
      <div class="stack accent" id="alleyOpen"><div class="glyph">OPEN</div><div class="layers" id="alleyOpenLayers"></div><div class="legend" id="alleyOpenLegend">PARAM</div></div>
      <div class="stack" id="alleyGrid"><div class="glyph">GRID</div><div class="layers" id="alleyGridLayers"></div><div class="legend" id="alleyGridLegend">8×8</div></div>
      <div class="stack" id="alleyPack"><div class="glyph">PACK</div><div class="layers" id="alleyPackLayers"></div><div class="legend" id="alleyPackLegend">SEA</div></div>
      <div class="stack" id="alleyEcho"><div class="glyph">ECHO</div><div class="layers" id="alleyEchoLayers"></div><div class="legend" id="alleyEchoLegend"></div></div>
      <div class="stack" id="alleyPlay"><div class="glyph">PLAY</div><div class="layers" id="alleyPlayLayers"></div><div class="legend" id="alleyPlayLegend">STOP</div></div>
    </div>

    <div id="safeBottom"></div>
    <div id="colorPipe"></div>
  </div>

<script>
(()=>{
  /* ============ DOM/Setup ============ */
  const canvas=document.getElementById('scene');
  const ctx=canvas.getContext('2d');
  const $=id=>document.getElementById(id);
  const DPR=Math.max(1,devicePixelRatio||1);
  let W=0,H=0; function resize(){W=innerWidth;H=innerHeight;canvas.width=W*DPR;canvas.height=H*DPR;canvas.style.width=W+'px';canvas.style.height=H+'px';ctx.setTransform(DPR,0,0,DPR,0,0);} addEventListener('resize',resize,{passive:true}); resize();
  const buzz=(p)=>{try{navigator.vibrate&&navigator.vibrate(p||10)}catch{}};

  /* ============ Colors per row ============ */
  const ROW_COLORS=['#0ea5e9','#22d3ee','#38bdf8','#67e8f9','#93c5fd','#a5f3fc','#60a5fa','#7dd3fc'];

  /* ============ State ============ */
  const state={
    gridOpts:[16,8,4,2,1], gridIdx:1, cols:8, rows:8,
    baseCell:30, defaultLayers:12,
    playing:false, t:0, bpm:118, playhead:0,
    selection:null, editor:false,
    focus:{tx:0,tz:0,sx:0,sz:0,scale:1,targetScale:1,lerp:0.22},
    aimInflate:58,
    paramPage:0,
    echo:.35
  };

  /* ============ Grid ============ */
  function makeCell(r){return{on:Math.random()<0.22,vel:0.7,prob:0.95,len:0.7,pitch:0,pan:(r-3.5)/3.5,send:0.35,lum:0.95,sep:1.05,layers:0.75,halo:0.75,sat:0.98,twist:0.02,_layersCache:state.defaultLayers,_pulse:0,_wig:0}};
  function makeGrid(cols){const g=[];for(let r=0;r<state.rows;r++){const row=[];for(let c=0;c<cols;c++)row.push(makeCell(r));g.push(row);}return g}
  let grid=makeGrid(state.cols);

  /* ============ Build visual layers ============ */
  function buildLayers(el,n=12,lit=4){el.innerHTML='';for(let i=0;i<n;i++){const d=document.createElement('div');d.className='lay';if(i>=n-lit)d.style.background='linear-gradient(90deg,#58e0ff,#fff)';el.appendChild(d)}}
  buildLayers($('alleyOpenLayers'),10,8); buildLayers($('alleyGridLayers'),10,5); buildLayers($('alleyPackLayers'),10,4); buildLayers($('alleyEchoLayers'),10,Math.round(10*state.echo)); buildLayers($('alleyPlayLayers'),10,2);

  /* ============ Geometry helpers (isometric) ============ */
  function safeRect(){const r=document.getElementById('safeBottom').getBoundingClientRect();return{x:0,y:0,w:W,h:Math.max(0,H-(r.height+8))}}
  function spacing(){const G=Math.max(state.cols,state.rows);const fx=G/state.cols,fz=G/state.rows;return{dx:state.baseCell*fx*1.48,dz:state.baseCell*fz*1.48}}
  function isoProject(x,y,z){const phi=0.16*Math.PI, theta=0.24*Math.PI;const cy=Math.cos(theta),sy=Math.sin(theta);const cx=Math.cos(phi),sx=Math.sin(phi);let X=x,Y=y,Z=z;let x1=X*cy+Z*sy;let z1=-X*sy+Z*cy;let y2=Y*cx-z1*sx;const f=state.focus; x1-=f.sx;y2-=f.sz;const R=safeRect();return{x:R.x+R.w*.5+x1,y:R.y+R.h*.5+y2,depth:z1}}
  function cellCenter(c,r){const {dx,dz}=spacing();const w=(state.cols-1)*dx;const h=(state.rows-1)*dz;return{x:c*dx-w/2,y:0,z:r*dz-h/2}}

  function colorize(hex,sat){const n=parseInt(hex.slice(1),16);let r=(n>>16)&255,g=(n>>8)&255,b=n&255;const gr=0.3*r+0.59*g+0.11*b;const mix=(t,a,b)=>Math.round(a*(1-t)+b*t);r=mix(1-sat,r,gr);g=mix(1-sat,g,gr);b=mix(1-sat,b,gr);return`rgb(${r},${g},${b})`}
  function roundedRect(x,y,w,h,r){ctx.beginPath();ctx.moveTo(x+r,y);ctx.arcTo(x+w,y,x+w,y+h,r);ctx.arcTo(x+w,y+h,x,y+h,r);ctx.arcTo(x,y+h,x,y,r);ctx.arcTo(x,y,x+w,y,r);ctx.closePath()}
  function calcLayersFrom(v){return Math.round(6+v*20)}

  /* ============ Draw stacks (wiggle + pulse) ============ */
  function drawStack(c,r,cell){
    const base=cellCenter(c,r);const color=ROW_COLORS[r%ROW_COLORS.length];
    const p=isoProject(base.x + Math.sin(cell._wig)*7*cell._pulse, 0, base.z + Math.cos(cell._wig)*7*cell._pulse);
    const layers= calcLayersFrom(cell.layers); const lum=cell.lum, sat=cell.sat, halo=cell.halo, sep=cell.sep, tw=cell.twist;

    ctx.save();ctx.translate(p.x,p.y);ctx.globalAlpha=.10;ctx.fillStyle=color;roundedRect(-20,-12,40,24,8);ctx.fill();ctx.restore();

    for(let i=0;i<layers;i++){
      const y=i*(11*sep);
      const px=isoProject(base.x+Math.sin(i*.12+cell._wig)*tw*16*(1+cell._pulse*0.4), -y, base.z);
      ctx.save();ctx.translate(px.x,px.y);ctx.globalAlpha=(.10+i*.022)*lum*(1+cell._pulse*0.38);
      ctx.fillStyle=colorize(color,sat);
      ctx.shadowColor='#7fdcff';ctx.shadowBlur=12*halo*(1+cell._pulse*1.2);
      roundedRect(-28/2,-16/2,28,16,7);ctx.fill();
      ctx.restore();
    }
  }

  /* ============ Interaction ============ */
  function pickCell(mx,my){let best=null,bestD=1e9;for(let r=0;r<state.rows;r++)for(let c=0;c<state.cols;c++){const P=isoProject(cellCenter(c,r).x,0,cellCenter(c,r).z);const dx=mx-P.x,dy=my-P.y;const d=dx*dx+dy*dy - state.aimInflate*state.aimInflate;if(d<bestD){bestD=d;best={r,c}}}return best}
  function scrubTo(col){ if(typeof col!=='number') return; const c=Math.max(0,Math.min(state.cols-1,col|0)); state.playhead=c; buzz(4); for(let r=0;r<state.rows;r++){ const cell=grid[r][c]; if(cell.on) trig(r,cell,true); } }

  canvas.addEventListener('pointerdown',async e=>{await userGestureAudio(); const R=canvas.getBoundingClientRect();const mx=e.clientX-R.left,my=e.clientY-R.top;const hit=pickCell(mx,my);if(hit){canvas.setPointerCapture(e.pointerId);state.selection=hit;state.editor=true; populateParamDock(); focusOnSelection(); scrubTo(hit.c); buzz(16); e.preventDefault();}})
  canvas.addEventListener('pointermove',e=>{if(!state.editor) return; const R=canvas.getBoundingClientRect();const mx=e.clientX-R.left,my=e.clientY-R.top;const hit=pickCell(mx,my); if(hit) scrubTo(hit.c)})
  addEventListener('pointerup',()=>{state.editor=false})

  function focusOnSelection(){if(!state.selection){state.focus.targetScale=1;return}const sel=state.selection;const base=cellCenter(sel.c,sel.r);const R=safeRect();const aX=R.x+R.w*.52,aY=R.y+R.h*.72;const p=isoProject(base.x,0,base.z);state.focus.tx+=(p.x-aX);state.focus.tz+=(p.y-aY);state.focus.targetScale=Math.min(2.3,1.0+(16/state.cols)*0.28)}

  /* ============ Param Dock (stacks-as-sliders) ============ */
  const PARAMS_SOUND=[{key:'vel',label:'VEL'},{key:'prob',label:'PRB'},{key:'len',label:'LEN'},{key:'pitch',label:'PIT'},{key:'pan',label:'PAN'},{key:'send',label:'REV'}];
  const PAGE_SIZE=4; function clamp01(x){return Math.max(0,Math.min(1,x))}
  function value01(key,c){if(key==='pitch')return (c.pitch+24)/48; if(key==='pan')return (c.pan+1)/2; return (key in c)? c[key] : .5}
  function applySound(obj,k,v){if(k==='pitch')obj.pitch=Math.round((v*2-1)*24); else if(k==='pan')obj.pan=(v*2-1); else obj[k]=v}
  function populateParamDock(){ const dock=$('paramDock'); dock.style.display='flex'; dock.innerHTML=''; const sel=state.selection; if(!sel) return; const SET=PARAMS_SOUND; const page= state.paramPage % Math.max(1,Math.ceil(SET.length/PAGE_SIZE)); const slice=SET.slice(page*PAGE_SIZE, page*PAGE_SIZE+PAGE_SIZE);
    slice.forEach(p=>{const s=document.createElement('div'); s.className='stack'; s.innerHTML=`<div class=\"glyph\">${p.label}</div><div class=\"layers\"></div><div class=\"legend\"></div>`; const L=s.querySelector('.layers'); let v=value01(p.key, grid[sel.r][sel.c]); const render=(vv)=>{const lit=Math.max(1,Math.round(1+vv*11)); buildLayers(L,12,lit)}; render(v);
      let grabbing=false, sy=0, sv=v, last=-1; const dead=6;
      s.addEventListener('pointerdown',async e=>{await userGestureAudio(); grabbing=true; sy=e.clientY; sv=v; s.setPointerCapture(e.pointerId); buzz([10,16,10])});
      s.addEventListener('pointermove',e=>{ if(!grabbing) return; const dy=sy-e.clientY; let dv=(Math.abs(dy)>dead?(dy>0?(dy-dead):(dy+dead)):0)/110; v=clamp01(sv+dv); render(v);
        const cell=grid[sel.r][sel.c]; applySound(cell, p.key, v); if(p.key!=='prob'){ trig(sel.r, cell, true); } const tick=Math.round(v*24); if(tick!==last){ last=tick; buzz(5);} });
      s.addEventListener('pointerup',()=>{grabbing=false; buzz(12)});
      dock.appendChild(s);
    });
    if(SET.length>PAGE_SIZE){ const more=document.createElement('div'); more.className='stack'; more.innerHTML='<div class=\"glyph\">MORE</div><div class=\"layers\" id=\"moreLayers\"></div>'; const Lm=more.querySelector('#moreLayers'); buildLayers(Lm,12,2+page); more.addEventListener('pointerdown',()=>{state.paramPage++; populateParamDock(); buzz(8)}); dock.appendChild(more); }
  }

  /* ============ Audio — ambient/trap/folk engine ============ */
  const AC=(window.AudioContext||window.webkitAudioContext); let audioCtx=null,
    master=null, preMaster=null, shaper=null, comp=null,
    wet=null, dry=null, delay=null, fb=null, tone=null, rvbIn=null, convolver=null, rvbMix=null,
    scPumpGain=null; // sidechain like pump on wet/reverb

  function makeIR(len=2.6, decay=2.8){ const rate=audioCtx.sampleRate; const size=Math.floor(rate*len); const buf=audioCtx.createBuffer(2,size,rate); for(let ch=0;ch<2;ch++){ const d=buf.getChannelData(ch); for(let i=0;i<size;i++){ const t=i/size; d[i]=(Math.random()*2-1)*Math.pow(1-t,decay); } } return buf; }

  async function userGestureAudio(){ ensureAudio(); try{ if(audioCtx && audioCtx.state==='suspended') await audioCtx.resume(); }catch{}}

  function ensureAudio(){ if(audioCtx||!AC) return; audioCtx=new AC();
    // Master chain: pre -> softclip -> comp -> master
    preMaster=audioCtx.createGain(); preMaster.gain.value=0.9;
    shaper=audioCtx.createWaveShaper(); const curve=new Float32Array(1024); for(let i=0;i<1024;i++){ const x=i/1023*2-1; curve[i]=Math.tanh(1.2*x); } shaper.curve=curve;
    comp=audioCtx.createDynamicsCompressor(); comp.threshold.value=-18; comp.knee.value=24; comp.ratio.value=2.5; comp.attack.value=0.01; comp.release.value=0.18;
    master=audioCtx.createGain(); master.gain.value=.34; preMaster.connect(shaper).connect(comp).connect(master).connect(audioCtx.destination);

    // Buses
    dry=audioCtx.createGain(); wet=audioCtx.createGain(); dry.gain.value=.85; wet.gain.value=.24; dry.connect(preMaster); wet.connect(preMaster);

    // Delay + tone (echo)
    delay=audioCtx.createDelay(1.2); delay.delayTime.value=0.36; fb=audioCtx.createGain(); fb.gain.value=0.40; tone=audioCtx.createBiquadFilter(); tone.type='lowpass'; tone.frequency.value=2800; delay.connect(fb).connect(tone).connect(delay); delay.connect(wet);

    // Convolution reverb
    convolver=audioCtx.createConvolver(); convolver.buffer=makeIR(3.2,3.1); rvbIn=audioCtx.createGain(); rvbMix=audioCtx.createGain(); rvbMix.gain.value=0.22; rvbIn.connect(convolver).connect(rvbMix).connect(preMaster);

    // Sidechain pump on wet path
    scPumpGain=audioCtx.createGain(); scPumpGain.gain.value=1.0; wet.disconnect(); wet.connect(scPumpGain).connect(preMaster); rvbMix.disconnect(); rvbMix.connect(scPumpGain); // pump both wet & rvb
  }

  function osc(type='sine'){ const o=audioCtx.createOscillator(); o.type=type; return o; }
  function env(){ const g=audioCtx.createGain(); g.gain.value=0; return g; }

  // Whale = sine with subtle FM for Eno-ish movement
  function voiceWhale(type='sine'){ const o=osc(type), mod=osc('sine'), modGain=audioCtx.createGain(); mod.frequency.value=0.12; modGain.gain.value=12; mod.connect(modGain); modGain.connect(o.frequency);
    const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=1400; const g=env(); o.connect(f).connect(g); g.connect(dry); g.connect(delay); g.connect(rvbIn); o.start(); mod.start();
    return {o,g,f,start(fr,len=1.6){ const t=audioCtx.currentTime; o.frequency.cancelScheduledValues(t); o.frequency.setValueAtTime(fr,t); o.frequency.exponentialRampToValueAtTime(Math.max(40,fr*0.45), t+len);
      g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(0.24, t+0.12); g.gain.exponentialRampToValueAtTime(0.0001, t+len);
    } }
  }

  // Pluck = mellowed for folk/ambient
  function voicePluck(type='triangle'){ const o=osc(type), f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=900; f.Q.value=0.6; const g=env(); o.connect(f).connect(g); g.connect(dry); g.connect(delay); g.connect(rvbIn); o.start();
    return {o,f,g,hit(frq,vel=0.5,shape=0.7){ const t=audioCtx.currentTime; o.frequency.setTargetAtTime(frq,t,0.01); f.frequency.setTargetAtTime(700+shape*2200,t,0.02);
      g.gain.cancelScheduledValues(t); g.gain.setValueAtTime(0,t); g.gain.linearRampToValueAtTime(vel*0.9, t+0.012); g.gain.exponentialRampToValueAtTime(0.0001, t+0.26);
    }}
  }

  // Drone bed = slowly drifting dual osc
  function voiceDrone(){ const a=osc('sine'), b=osc('triangle'); a.detune.value=-4; b.detune.value=+5; const mix=audioCtx.createGain(); mix.gain.value=0.12; const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=900; const lfo=osc('sine'), lg=audioCtx.createGain(); lfo.frequency.value=0.05; lg.gain.value=180; lfo.connect(lg).connect(f.frequency);
    a.connect(f); b.connect(f); f.connect(mix); mix.connect(dry); mix.connect(rvbIn); a.start(); b.start(); lfo.start(); return {set(x){ mix.gain.setTargetAtTime(x, audioCtx.currentTime, 0.5); }} }

  function voiceSurf(){ const n=audioCtx.createBuffer(1, audioCtx.sampleRate*3, audioCtx.sampleRate); const d=n.getChannelData(0); for(let i=0;i<d.length;i++){ const prev=d[i-1]||0; d[i]=(Math.random()*2-1)*0.42 + prev*0.44; } const s=audioCtx.createBufferSource(); s.buffer=n; s.loop=true; const f=audioCtx.createBiquadFilter(); f.type='bandpass'; f.frequency.value=240; f.Q.value=0.9; const g=audioCtx.createGain(); g.gain.value=0.12; s.connect(f).connect(g).connect(dry); g.connect(delay); g.connect(rvbIn); s.start(); return {set(x){ g.gain.setTargetAtTime(x, audioCtx.currentTime, 0.2); }} }

  let packs=[
    {name:'SEA', whale:'sine',     pluck:'triangle', echo:0.34, tone:2600, drone:0.10},
    {name:'DEEP', whale:'sine',    pluck:'square',   echo:0.42, tone:1800, drone:0.18},
    {name:'REEF', whale:'triangle',pluck:'sawtooth', echo:0.30, tone:3000, drone:0.08},
    {name:'GLASS',whale:'sine',    pluck:'sine',     echo:0.24, tone:3600, drone:0.12},
    {name:'MYTH', whale:'triangle',pluck:'triangle', echo:0.38, tone:2200, drone:0.22},
    {name:'PRIMAL', whale:'sine',  pluck:'square',   echo:0.48, tone:1700, drone:0.25}
  ], packIdx=0;
  let whale, pluck, surf, drone;

  // Ensure instruments exist before any trigger
  function ensureVoices(){ if(!audioCtx) return; if(!whale || !pluck || !surf || !drone){ applyPack(packIdx); } }

  function applyPack(i){ ensureAudio(); packIdx=(i%packs.length+packs.length)%packs.length; const P=packs[packIdx];
    if(!whale) whale=voiceWhale(P.whale); else whale.o.type=P.whale;
    if(!pluck) pluck=voicePluck(P.pluck); else pluck.o.type=P.pluck;
    if(!surf)  surf = voiceSurf();
    if(!drone) drone= voiceDrone();
    tone.frequency.setTargetAtTime(P.tone, audioCtx.currentTime, 0.3);
    fb.gain.setTargetAtTime(0.22+P.echo*0.7, audioCtx.currentTime, 0.2);
    drone.set(P.drone);
    $('alleyPackLegend').textContent=P.name; buildLayers($('alleyPackLayers'),10,Math.max(3,packIdx+3));
  }

  // Sidechain pump helper (kick-like)
  function pump(){ if(!scPumpGain||!audioCtx) return; const t=audioCtx.currentTime; scPumpGain.gain.cancelScheduledValues(t); scPumpGain.gain.setValueAtTime(0.72,t); scPumpGain.gain.exponentialRampToValueAtTime(1.0, t+0.25); }

  function trig(row,cell,preview){ ensureAudio(); ensureVoices(); if(!pluck || !whale) return; if(Math.random()>cell.prob) return; const base=[28,31,33,35,36,38,40,43][row%8]; const f= 55*Math.pow(2, ((base+cell.pitch)/12));
    // motion pulse
    cell._pulse = Math.min(1, cell._pulse + 0.9*(preview?0.5:1)); cell._wig += Math.random()*0.75;
    // sound
    const v = 0.18 + cell.vel*0.62; const shape = 0.6 + cell.send*0.6;
    if(row===0) pump();
    if(row%2===0){ pluck.hit(f*(row===2?2:1), v, shape); }
    else { whale.start(f* (row===7?4:1), 1.2+cell.len*1.1); }
  }

  // Alley actions (all resume audio on touch)
  $('alleyOpen').addEventListener('pointerdown',async()=>{ await userGestureAudio(); ensureVoices(); populateParamDock(); $('paramDock').style.display='flex'; buzz([10,20,10]) });
  $('alleyGrid').addEventListener('pointerdown',async()=>{ await userGestureAudio(); state.gridIdx=(state.gridIdx+1)%state.gridOpts.length; state.cols=state.gridOpts[state.gridIdx]; grid=makeGrid(state.cols); $('alleyGridLegend').textContent= state.cols===1? '1×1' : `${state.cols}×${state.cols}`; buildLayers($('alleyGridLayers'),10,10-state.gridIdx); buzz(12) });
  $('alleyPack').addEventListener('pointerdown',async()=>{ await userGestureAudio(); applyPack(packIdx+1); buzz([12,24,12]) });
  $('alleyEcho').addEventListener('pointerdown',async e=>{ await userGestureAudio(); ensureVoices(); const el=e.currentTarget; let grab=false, sy=0, sv=state.echo; const L=$('alleyEchoLayers'); const render=()=>buildLayers(L,10,Math.round(1+state.echo*9)); render();
    const onMove=ev=>{ if(!grab) return; const dy=sy-ev.clientY; state.echo=Math.max(0,Math.min(1, sv + dy/180)); fb.gain.setTargetAtTime(0.22+state.echo*0.7, audioCtx.currentTime, 0.1); render(); };
    const onUp=()=>{ grab=false; removeEventListener('pointermove',onMove); removeEventListener('pointerup',onUp); };
    grab=true; sy=e.clientY; addEventListener('pointermove',onMove); addEventListener('pointerup',onUp); buzz([6,8,6]);
  });
  $('alleyPlay').addEventListener('pointerdown',async()=>{ await userGestureAudio(); ensureVoices(); state.playing=!state.playing; $('alleyPlayLegend').textContent= state.playing?'PLAY':'STOP'; buildLayers($('alleyPlayLayers'),10,state.playing?10:2); buzz([14,28,14]) });

  // ===== Tick & Render
  function update(dt){
    if(state.playing){ const bps=state.bpm/60; state.t+=dt*bps; const next=Math.floor(state.t)%state.cols; if(next!==state.playhead){ state.playhead=next; for(let r=0;r<state.rows;r++){ const cell=grid[r][state.playhead]; if(cell.on) trig(r,cell); } buzz(3); }}
    for(let r=0;r<state.rows;r++) for(let c=0;c<state.cols;c++){ const cell=grid[r][c]; cell._pulse *= 0.88; cell._wig += cell._pulse*0.2; }
    state.focus.sx += (state.focus.tx-state.focus.sx)*state.focus.lerp; state.focus.sz += (state.focus.tz-state.focus.sz)*state.focus.lerp; state.focus.scale += (state.focus.targetScale-state.focus.scale)*state.focus.lerp; }

  function render(){ ctx.clearRect(0,0,W,H); const R=safeRect(); const side=Math.min(R.w,R.h); const cx=R.x+R.w*.5, cy=R.y+R.h*.5; const base=side/Math.max(640,side)*state.focus.scale; ctx.save(); ctx.translate(cx,cy); ctx.scale(base,base); ctx.translate(-cx,-cy);
    // faint playhead behind
    const phx=cellCenter(state.playhead,0).x; const p0=isoProject(phx,-140, cellCenter(0,0).z-140); const p1=isoProject(phx,220, cellCenter(state.cols-1,state.rows-1).z+140); ctx.save(); ctx.globalAlpha=0.07; ctx.strokeStyle='#cfe8ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(p0.x,p0.y); ctx.lineTo(p1.x,p1.y); ctx.stroke(); ctx.restore();
    const order=[]; for(let r=0;r<state.rows;r++) for(let c=0;c<state.cols;c++) order.push({r,c}); order.sort((a,b)=>(a.r+a.c)-(b.r+b.c)); order.forEach(({r,c})=>drawStack(c,r,grid[r][c]));
    ctx.restore(); }

  let last=performance.now(); function loop(now){ const dt=Math.min(0.05,(now-last)/1000); last=now; update(dt); render(); requestAnimationFrame(loop);} requestAnimationFrame(loop);

  // Boot pattern for audible demo
  for(let c=0;c<state.cols;c++){ grid[0][c].on = c%4===0; grid[1][c].on = c%8===4; grid[2][c].on = c%2===0; grid[3][c].on = (c+2)%4===0; }

  // Self-tests
  try{
    console.assert(document.querySelector('#alley').children.length>=5, 'Only Alley visible at boot');
    console.assert(document.getElementById('paramDock').style.display!=='flex', 'Param dock hidden at boot');
    console.assert(typeof applyPack==='function', 'applyPack present');
    console.assert(typeof ensureVoices==='function', 'ensureVoices present');
    ensureAudio(); ensureVoices(); console.assert(true, 'ensureVoices runs');
    console.assert(packs.length>=6, 'Has 6+ packs for variety');
  }catch(e){ console.warn('[Sea Sequencer tests] minor issue', e); }
})();
</script>
</body>
</html>
