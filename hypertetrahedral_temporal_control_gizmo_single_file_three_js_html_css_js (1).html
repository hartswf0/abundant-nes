<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <title>Hypertetrahedral Temporal Control Gizmo</title>
  <style>
    :root { --bg:#0b0e13; --fg:#c9d7ff; --accent:#7aa2ff; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); }
    canvas { display:block; touch-action:none; }
    /* Minimal HUD (icons only) */
    .hud { position:fixed; inset:0; pointer-events:none; }
    .ring { position:absolute; width:10px; height:10px; border-radius:50%; outline:2px solid #5ea1ff55; box-shadow:0 0 12px #5ea1ff55; transform:translate(-50%, -50%); opacity:0; transition:opacity .2s ease; }
    .scope { position:fixed; right:env(safe-area-inset-right,8px); bottom:calc(8px + env(safe-area-inset-bottom,8px)); width:180px; height:70px; border-radius:12px; background:#0d1220aa; backdrop-filter:blur(6px); outline:1px solid #27407a; box-shadow:0 8px 24px #0006; }
    .scope canvas { width:100%; height:100%; }
    .btns { position:fixed; left:env(safe-area-inset-left,8px); bottom:calc(8px + env(safe-area-inset-bottom,8px)); display:flex; gap:8px; }
    .btn { width:36px; height:36px; border-radius:10px; background:#0d1220cc; outline:1px solid #27407a; box-shadow:inset 0 0 0 1px #0b1733; display:grid; place-items:center; pointer-events:auto; }
    .btn svg { width:18px; height:18px; fill:#9bb7ff; opacity:.85; }
    .btn:active { filter:brightness(1.2); }
  </style>
  <script type="importmap">
    {"imports":{ "three":"https://unpkg.com/three@0.160.1/build/three.module.js", "three/addons/":"https://unpkg.com/three@0.160.1/examples/jsm/" }}
  </script>
</head>
<body>
  <div id="hud" class="hud">
    <div id="ring" class="ring"></div>
    <div class="scope"><canvas id="osc"></canvas></div>
    <div class="btns">
      <div class="btn" id="playPause" title="Play/Pause" aria-label="Play/Pause"><svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg></div>
      <div class="btn" id="rec" title="Snapshot" aria-label="Snapshot"><svg viewBox="0 0 24 24"><circle cx="12" cy="12" r="6"/></svg></div>
      <div class="btn" id="load" title="Load" aria-label="Load"><svg viewBox="0 0 24 24"><path d="M12 3v12m0 0l-4-4m4 4l4-4M4 19h16"/></svg></div>
      <div class="btn" id="media" title="Media Layers" aria-label="Media Layers"><svg viewBox="0 0 24 24"><path d="M4 5h16v4H4zM4 10h10v4H4zM4 15h7v4H4z"/></svg></div>
      <input id="file" type="file" accept="application/json" hidden />
    </div>
  </div>

  <!-- Minimal media panel (toggle with Media Layers button). Icon-first; no prose. -->
  <div id="mediaPanel" style="position:fixed;left:8px;right:8px;bottom:calc(56px + env(safe-area-inset-bottom,8px));background:#0b1020cc;border:1px solid #27407a;border-radius:12px;backdrop-filter:blur(8px);box-shadow:0 8px 24px #0006;display:none">
    <div style="display:flex;align-items:center;justify-content:space-between;padding:8px 10px">
      <div style="display:flex;gap:8px;align-items:center">
        <svg width="18" height="18" viewBox="0 0 24 24" style="fill:#9bb7ff;opacity:.9"><path d="M4 5h16v4H4zM4 10h10v4H4zM4 15h7v4H4z"/></svg>
        <div id="mediaStatus" style="font-size:12px;color:#aecdff;opacity:.9"></div>
      </div>
      <button id="mediaClose" class="btn" style="width:28px;height:28px"><svg viewBox="0 0 24 24"><path d="M18 6L6 18M6 6l12 12"/></svg></button>
    </div>
    <div id="mediaTray" style="display:flex;gap:8px;overflow:auto;padding:8px 10px 12px"></div>
    <div id="mediaViewer" style="display:flex;align-items:center;justify-content:center;max-height:36vh;border-top:1px solid #27407a;background:#000"></div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- Self-tests ---
    (function(){
      const ok = !!THREE && !!THREE.Vector3 && typeof OrbitControls==='function';
      console.assert(ok, 'three & OrbitControls should load');
    })();

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.setAnimationLoop(animate);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(getComputedStyle(document.documentElement).getPropertyValue('--bg'));

    const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.01, 100);
    camera.position.set(0.9, 0.9, 1.6);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.05; controls.enablePan = false;

    // Lights
    const key = new THREE.DirectionalLight(0xffffff, 1.0); key.position.set(2,3,4);
    const fill = new THREE.DirectionalLight(0x88aaff, 0.4); fill.position.set(-3,-2,1);
    const rim  = new THREE.PointLight(0x3a79ff, 1.2, 6); rim.position.set(0,1.6,-1.2);
    scene.add(key, fill, rim);

    // Tetrahedron core
    const radius = 0.6, detail = 0;
    const tetraGeo = new THREE.TetrahedronGeometry(radius, detail);

    // Faces with per-face material
    const faceMaterials = [];
    const faceMesh = new THREE.Mesh();
    {
      const geo = tetraGeo.clone(); geo.clearGroups();
      const triCount = geo.index ? geo.index.count/3 : geo.attributes.position.count/3;
      for (let i=0;i<triCount;i++) {
        const mat = new THREE.MeshStandardMaterial({ color:0x14213a, metalness:0.2, roughness:0.45, emissive:0x2a6cff, emissiveIntensity:0.0, transparent:true, opacity:0.95 });
        faceMaterials.push(mat); geo.addGroup(i*3, 3, i);
      }
      faceMesh.geometry = geo; faceMesh.material = faceMaterials; scene.add(faceMesh);
      console.assert(triCount===4, 'Expected 4 triangular faces');
    }

    // Edges
    const edges = new THREE.LineSegments(new THREE.EdgesGeometry(tetraGeo), new THREE.LineDashedMaterial({ color:0x7aa2ff, dashSize:0.05, gapSize:0.03 }));
    edges.computeLineDistances(); scene.add(edges);

    // Vertices
    const vGeo = new THREE.SphereGeometry(0.03, 16, 16);
    const vMat = new THREE.MeshStandardMaterial({ color:0x9bb7ff, emissive:0x4f7cff, emissiveIntensity:0.2, roughness:0.2, metalness:0.0 });
    const vertexMeshes = [];
    const vPositions = tetraGeo.getAttribute('position');
    const verts = [];
    for (let i=0;i<vPositions.count;i+=3) verts.push(new THREE.Vector3().fromBufferAttribute(vPositions, i));
    const uniq = [...new Map(verts.map(p=>[p.toArray().map(n=>n.toFixed(5)).join(','), p])).values()];
    uniq.forEach(p=>{ const m=new THREE.Mesh(vGeo, vMat.clone()); m.position.copy(p); scene.add(m); vertexMeshes.push(m); });

    // State including media layer engine
    const state = {
      t: 0,
      playing: true,
      faces: faceMaterials.map(()=>({ warp: 0.0, complexity: 0.0 })),
      edges: { dashOffset: 0.0, energy: 0.0 },
      vertices: vertexMeshes.map(()=>({ pulse: 0.0 })),
      trail: [],
      media: {
        active: 0,
        // User: replace via JSON import { media:[{title?,type:'image'|'video'|'audio',url,tag?}, ...] }
        items: [
          { title:"Biden—SOTU clip", type:"video", url:"", tag:"biden" },
          { title:"Campaign still",  type:"image", url:"", tag:"biden" },
          { title:"Press audio",     type:"audio", url:"", tag:"biden" },
          { title:"Generic layer",   type:"image", url:"", tag:"layer" }
        ]
      }
    };

    // Raycaster
    const ray = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    let dragging = null; let lastHit = null;

    function setPointerFromEvent(e){
      const x = (e.touches? e.touches[0].clientX : e.clientX) / innerWidth * 2 - 1;
      const y = -((e.touches? e.touches[0].clientY : e.clientY) / innerHeight) * 2 + 1;
      pointer.set(x,y);
    }
    function vibrate(ms=12){ if(navigator.vibrate) navigator.vibrate(ms); }

    function pick(){
      ray.setFromCamera(pointer, camera);
      const faceHits = ray.intersectObject(faceMesh, false);
      let hit = faceHits[0] ? { type:'face', index:(faceHits[0].faceIndex|0), point:faceHits[0].point } : null;
      if(!hit){ const vHits = ray.intersectObjects(vertexMeshes, false); if (vHits[0]) hit = { type:'vertex', index:vertexMeshes.indexOf(vHits[0].object), point:vHits[0].point }; }
      return hit;
    }

    // Touch ring
    const ring = document.getElementById('ring');
    function showRing(x,y){ ring.style.left=x+'px'; ring.style.top=y+'px'; ring.style.opacity=1; clearTimeout(showRing._t); showRing._t=setTimeout(()=>ring.style.opacity=0,200); }

    // Input
    let holdTimer = null;
    function onDown(e){
      setPointerFromEvent(e);
      const hit = pick();
      if(hit){
        lastHit = hit;
        const sx = e.touches? e.touches[0].clientX : e.clientX;
        const sy = e.touches? e.touches[0].clientY : e.clientY;
        showRing(sx, sy); vibrate(10);
        if(hit.type==='face'){
          dragging = { type:'face', index:hit.index, startWarp:state.faces[hit.index].warp };
          // Quick tap: cycle media
          cycleMediaFromFace(hit.index);
        } else if(hit.type==='vertex'){
          dragging = { type:'vertex', index:hit.index, startWarp:state.vertices[hit.index].pulse };
        }
        // Hold toggles play
        holdTimer = setTimeout(()=>{ state.playing = !state.playing; vibrate(30); }, 420);
      }
    }

    function onMove(e){
      if(!dragging) return; e.preventDefault();
      const clientX = e.touches? e.touches[0].clientX : e.clientX;
      const clientY = e.touches? e.touches[0].clientY : e.clientY;
      const nx = (clientX/innerWidth)*2-1; const ny = -(clientY/innerHeight)*2+1;
      const delta = Math.hypot(nx-pointer.x, ny-pointer.y);
      const sign = Math.sign(nx-pointer.x || 1);
      if(dragging.type==='face'){
        const i = dragging.index;
        state.faces[i].warp = THREE.MathUtils.clamp(dragging.startWarp + sign*delta*3.2, -2.5, 2.5);
        state.faces[i].complexity = THREE.MathUtils.smoothstep(Math.abs(state.faces[i].warp), 0, 2.5);
      } else if(dragging.type==='vertex'){
        const i = dragging.index;
        state.vertices[i].pulse = THREE.MathUtils.clamp(dragging.startWarp + sign*delta*4.0, -3.0, 3.0);
      }
      state.edges.energy = 0.25 + 0.75*avgFaceComplexity();
      state.trail.push([clientX, clientY, Date.now()]);
    }
    function onUp(){ dragging=null; clearTimeout(holdTimer); holdTimer=null; }

    renderer.domElement.addEventListener('pointerdown', onDown, { passive:true });
    addEventListener('pointermove', onMove, { passive:false });
    addEventListener('pointerup', onUp, { passive:true });
    addEventListener('pointercancel', onUp, { passive:true });

    // Audio (WebAudio)
    let AC, masterGain; const vertexOsc = [];
    function initAudio(){
      if(AC) return; AC = new (window.AudioContext||window.webkitAudioContext)();
      masterGain = AC.createGain(); masterGain.gain.value=0.05; masterGain.connect(AC.destination);
      vertexMeshes.forEach((_, i)=>{
        const osc = AC.createOscillator(); osc.type='sine'; osc.frequency.value = 220 + i*60;
        const gain = AC.createGain(); gain.gain.value=0.0;
        const panner = AC.createStereoPanner ? AC.createStereoPanner() : AC.createGain();
        if(panner.pan) panner.pan.value = (i-1.5)/1.5;
        osc.connect(gain).connect(panner).connect(masterGain); osc.start();
        vertexOsc.push({ osc, gain, panner });
      });
    }

    // Oscilloscope HUD
    const oscCanvas = document.getElementById('osc'); const octx = oscCanvas.getContext('2d');
    function drawScope(){
      const w=oscCanvas.width = oscCanvas.clientWidth*devicePixelRatio;
      const h=oscCanvas.height= oscCanvas.clientHeight*devicePixelRatio;
      octx.clearRect(0,0,w,h); octx.globalAlpha=0.9; octx.fillStyle='#0b1022'; octx.fillRect(0,0,w,h);
      octx.strokeStyle='#6ea0ff'; octx.lineWidth=2; octx.beginPath();
      const N=120, now=performance.now()*0.001; for(let i=0;i<N;i++){ const x=i/(N-1)*w; const y=h*0.5 + Math.sin(now*2 + i*0.2) * 12 * (0.2 + avgFaceComplexity()); if(i===0) octx.moveTo(x,y); else octx.lineTo(x,y);} octx.stroke();
      // trail
      const ttl=800, tnow=Date.now(); state.trail = state.trail.filter(([, , t])=> tnow-t < ttl);
      octx.strokeStyle='#a6c4ff66'; octx.lineWidth=1; octx.beginPath();
      state.trail.forEach(([x,y],i)=>{ const sx=x/innerWidth*w, sy=y/innerHeight*h; if(i===0) octx.moveTo(sx,sy); else octx.lineTo(sx,sy); });
      octx.stroke();
    }

    function avgFaceComplexity(){ return state.faces.reduce((a,f)=>a+f.complexity,0)/state.faces.length; }

    // Snapshot / Load (state)
    function snapshot(){
      const data = { faces: state.faces.map(f=>({warp:f.warp})), vertices: state.vertices.map(v=>({pulse:v.pulse})), playing: state.playing, media: state.media.items };
      const blob = new Blob([JSON.stringify(data,null,2)], {type:'application/json'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='hypertetrahedron_state.json'; document.body.appendChild(a); a.click(); a.remove();
    }

    // Buttons
    const playBtn = document.getElementById('playPause');
    const recBtn  = document.getElementById('rec');
    const loadBtn = document.getElementById('load');
    const mediaBtn= document.getElementById('media');
    const fileInp = document.getElementById('file');

    playBtn.addEventListener('click', ()=>{ state.playing=!state.playing; vibrate(15); initAudio(); if(AC && AC.state==='suspended') AC.resume(); });
    recBtn.addEventListener('click', ()=>{ snapshot(); vibrate(20); });
    loadBtn.addEventListener('click', ()=> fileInp.click());
    mediaBtn.addEventListener('click', ()=> toggleMediaPanel());

    // Media panel logic
    const mediaPanel = document.getElementById('mediaPanel');
    const mediaTray  = document.getElementById('mediaTray');
    const mediaViewer= document.getElementById('mediaViewer');
    const mediaStatus= document.getElementById('mediaStatus');
    const mediaClose = document.getElementById('mediaClose');
    mediaClose.addEventListener('click', ()=> mediaPanel.style.display='none');

    function toggleMediaPanel(){
      if(mediaPanel.style.display==='none' || !mediaPanel.style.display){ renderMediaTray(); mediaPanel.style.display='block'; }
      else mediaPanel.style.display='none';
    }
    function iconPath(type){ if(type==='video') return "<path d='M4 6h12v12H4zM16 10l4-2v8l-4-2z'/>"; if(type==='audio') return "<path d='M9 7v10l6-4V11l4-2v6'/>"; return "<path d='M4 5h16v14H4z'/>"; }
    function renderMediaTray(){
      mediaTray.innerHTML='';
      const items = state.media.items; mediaStatus.textContent = `${items.length} · ${state.media.active+1}`;
      items.forEach((m,i)=>{ const b=document.createElement('button'); b.className='btn'; b.style.minWidth='64px'; b.style.height='36px'; b.innerHTML=`<svg viewBox='0 0 24 24' width='16' height='16' style='fill:#9bb7ff;opacity:.9'>${iconPath(m.type)}</svg>`; b.addEventListener('click',()=>{ state.media.active=i; showMedia(items[i]); vibrate(8); }); mediaTray.appendChild(b); });
      showMedia(items[state.media.active]||null);
    }
    function showMedia(m){ mediaViewer.innerHTML=''; if(!m) return; const node=document.createElement('div'); node.style.color='#9bb7ff'; node.style.padding='10px'; node.style.fontSize='12px'; const ico=document.createElement('div'); ico.innerHTML=`<svg viewBox='0 0 24 24' width='24' height='24' style='fill:#9bb7ff;opacity:.9'>${iconPath(m.type)}</svg>`; node.appendChild(ico); mediaViewer.appendChild(node); }

    // Allow importing external media JSON (schema: { media:[{title?,type,url,tag?}, ...] })
    fileInp.addEventListener('change', async (e)=>{
      const file=e.target.files[0]; if(!file) return; const txt=await file.text();
      try{ const data=JSON.parse(txt); if(Array.isArray(data.media)) state.media.items=data.media; renderMediaTray(); vibrate(30);}catch(err){ console.warn('Invalid media JSON', err); }
    });

    // Cycle media on face tap
    function cycleMediaFromFace(){ state.media.active = (state.media.active + 1) % state.media.items.length; if(mediaPanel.style.display==='block') renderMediaTray(); }

    // Animation loop
    function animate(){
      const dt = 0.016; state.t += (state.playing? dt : 0);
      faceMaterials.forEach((m,i)=>{ const f=state.faces[i]; const beat=Math.sin(state.t*(1.5+Math.abs(f.warp)))*0.5+0.5; m.emissiveIntensity=0.05 + f.complexity*(0.2+0.8*beat); m.opacity=0.85 + 0.15*Math.sin(state.t*0.8 + i); });
      edges.material.dashOffset -= dt * (0.5 + state.edges.energy); edges.material.needsUpdate=true;
      vertexMeshes.forEach((vm,i)=>{ const v=state.vertices[i]; const s=1+0.6*Math.sin(state.t*2 + v.pulse); vm.scale.setScalar(THREE.MathUtils.lerp(vm.scale.x, 0.9+0.12*s, 0.2)); if(vertexOsc[i]) vertexOsc[i].gain.gain.value=0.02 + 0.08*Math.max(0, Math.sin(state.t*2 + v.pulse)); });
      faceMesh.rotation.y += 0.12*dt; faceMesh.rotation.x += 0.07*dt; edges.rotation.copy(faceMesh.rotation); vertexMeshes.forEach(v=> v.rotation.copy(faceMesh.rotation));
      rim.intensity = 0.6 + 0.9*avgFaceComplexity();
      controls.update(); renderer.render(scene, camera); drawScope();
    }

    // Kickstart audio on first gesture
    addEventListener('pointerdown', ()=>{ initAudio(); if(AC && AC.state==='suspended') AC.resume(); }, { once:true, passive:true });

    // Responsive
    addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

    // Tests for media engine
    (function(){
      console.assert(Array.isArray(state.media.items), 'media.items should be an array');
      const before = state.media.active; state.media.active = state.media.items.length-1; cycleMediaFromFace();
      console.assert(state.media.active === 0 || state.media.items.length===0, 'cycleMediaFromFace should wrap');
    })();

  </script>
</body>
</html>
