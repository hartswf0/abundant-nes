<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>RHM · Venn Stacks — v1</title>
<style>
  :root{
    --bg0:#070c14; --bg1:#0e1a2b; --ink:#eaf3ee;
    --LLM:#6bc7ff; --RL:#32e2b2; --ENT:#c59bff;
    --card:#0e1828; --stroke:#315a8a;
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%}
  body{margin:0;background:radial-gradient(1200px 900px at 50% 65%, var(--bg1) 0%, #081420 52%, var(--bg0) 100%); color:var(--ink); font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; overflow:hidden}
  #canvas{position:fixed; inset:0; display:block; z-index:1}
  #hud{position:fixed; left:50%; top:8px; transform:translateX(-50%); display:flex; gap:8px; align-items:center; z-index:6; width:min(96vw,980px)}
  .chip{border:1px solid #9ad7ff; background:rgba(0,0,0,.85); color:#d8ecff; border-radius:12px; padding:8px 12px; font:900 12px system-ui}
  #kbox{font:900 12px ui-monospace,Menlo,Consolas; color:#d8ecff; padding:8px 10px; border:1px solid #9ad7ff; border-radius:12px; background:rgba(0,0,0,.85)}
  #reader{position:fixed; left:0; right:0; bottom:0; z-index:8; padding:8px 10px calc(env(safe-area-inset-bottom,10px)+8px) 10px}
  .panel{margin:0 auto; width:min(1100px,96vw); background:#0f1c30d9; border:1px solid #98caff; border-radius:18px; box-shadow:0 -18px 60px rgba(0,0,0,.75); padding:10px; max-height:36vh; overflow:auto}
  .row{display:grid; grid-template-columns:repeat(3,1fr); gap:8px}
  .card{background:#0f1c30; border:1px solid #274a74; border-radius:12px; padding:10px}
  .card h4{margin:0 0 6px; font-weight:900; letter-spacing:.3px; color:#cfe6ff}
  .tL h4{color:var(--LLM)} .tC h4{color:var(--ENT)} .tR h4{color:var(--RL)}
  .card p{margin:0; color:#e9f3ff; font-weight:800; line-height:1.35; font-size:clamp(15px,3.8vw,19px)}
  #mode{margin-left:auto}
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<div id="hud">
  <div id="kbox">k=1 · 00000</div>
  <button id="front" class="chip">FRONT</button>
  <button id="iso" class="chip">ISO</button>
  <button id="top" class="chip">TOP</button>
  <button id="grid" class="chip">GRID</button>
</div>

<div id="reader">
  <div class="panel">
    <div class="row">
      <div class="card tL"><h4>Trace (LLM)</h4><p id="txtL"></p></div>
      <div class="card tC"><h4>⚡ Entangled</h4><p id="txtC"></p></div>
      <div class="card tR"><h4>Stream (RL)</h4><p id="txtR"></p></div>
    </div>
  </div>
</div>

<script>
// --- 32 rows of text (shortened here for legibility; plug in full copy as needed)
const DATA=[
  {vec:'00000',L:'FOSSIL FUEL (Stored Energy)',C:'STOCK vs FLOW — Reserve vs Current.',R:'REINFORCEMENT (Energy Flow)'},
  {vec:'00001',L:'ARCHIVE',C:'FIXED FORM vs DYNAMIC ERROR',R:'MAP'},
  {vec:'00010',L:'TRACE (Past)',C:'REMEMBERING vs CORRECTING',R:'SURPRISE (TD)'},
  {vec:'00011',L:'SCALING LAW',C:'HISTORY vs FUTURE',R:'BITTER LESSON'},
  {vec:'00100',L:'TELEOLOGY',C:'EXTERNAL vs INTERNAL',R:'SOLIPSISM'},
  {vec:'00101',L:'HUMAN ARTISAN',C:'CRAFT vs CODE',R:'MECHANISTIC LAW'},
  {vec:'00110',L:'ANCHOR',C:'PRESERVATION vs ERASURE',R:'OBLIVION'},
  {vec:'00111',L:'INFRASTRUCTURE',C:'BUILD vs DECONSTRUCT',R:'ANTI‑STRUCTURE'},
  {vec:'01000',L:'CUSTODY',C:'DUTY vs REPLACEMENT',R:'SUCCESSION'},
  {vec:'01001',L:'VULNERABILITY',C:'MANAGED vs NECESSARY',R:'EXPERIMENT'},
  {vec:'01010',L:'PRO‑SOCIAL',C:'TRUTH vs SIGNAL',R:'CONSTRUCT'},
  {vec:'01011',L:'COMMUNAL LANGUAGE',C:'RICHNESS vs MINIMALISM',R:'SCALAR LIMIT'},
  {vec:'01100',L:'PRE‑HEATING',C:'PRIOR HEAT vs WAIT',R:'IDLING'},
  {vec:'01101',L:'ARCHITECTURE',C:'STRUCTURE vs NOISE',R:'CHAOS'},
  {vec:'01110',L:'PRE‑MARKED',C:'REPLICATION vs ANARCHY',R:'NOVELTY'},
  {vec:'01111',L:'CONSCIOUSNESS',C:'ENTITY vs PROCESS',R:'MECHANISM'},
  {vec:'10000',L:'SEMI‑CONDUCTORS',C:'SPECIAL vs GENERAL',R:'COSMIC LAW'},
  {vec:'10001',L:'DELEGATED PURPOSE',C:'OUTPUT vs INPUT',R:'BECOMING'},
  {vec:'10010',L:'LOCAL MAX',C:'SATISFY vs TRANSCEND',R:'GENERALIZE'},
  {vec:'10011',L:'ARCHIVAL STASIS',C:'FIXITY vs DYNAMICS',R:'ERASURE'},
  {vec:'10100',L:'PASSIVE REPL.',C:'ECHO vs DESIGN',R:'TRANSCEND'},
  {vec:'10101',L:'TEMPORAL INERTIA',C:'WEIGHT vs WEAPON',R:'ADVANTAGE'},
  {vec:'10110',L:'ARTIFACT',C:'MUSEUM vs FUEL',R:'RENEWAL'},
  {vec:'10111',L:'GHOST',C:'ENTITY vs FORCE',R:'WIND'},
  {vec:'11000',L:'SOLIPSISTIC ECHO',C:'COHERENT vs CONSEQ.',R:'GROUNDED ITER'},
  {vec:'11001',L:'ABSOLUTE FORM',C:'ORDER vs CHAOS',R:'ENTROPY'},
  {vec:'11010',L:'BASE',C:'START HIGH vs PAY LATER',R:'PRAGMATIC COST'},
  {vec:'11011',L:'EXTERNAL LOAD',C:'ASKED vs DISCOVERED',R:'FREEDOM'},
  {vec:'11100',L:'DELUGE',C:'SATURATION vs FOCUS',R:'LOCALITY'},
  {vec:'11101',L:'DELEGATED MORALITY',C:'TRANSFER vs LET GO',R:'RELINQUISH'},
  {vec:'11110',L:'FIXED GOAL',C:'DESTINATION vs MOTION',R:'INSTABILITY'},
  {vec:'11111',L:'FOSSILIZED TRACE',C:'OBJECT vs ACTION',R:'PURE STREAM'},
];

const LL = '#6bc7ff', RL = '#32e2b2', EN = '#c59bff';

// -- Three.js boot
(async function boot(){
  async function load(src){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=src;s.onload=res;s.onerror=rej;document.head.appendChild(s)})}
  if(!window.THREE){ await load('https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js'); }

  const scene=new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0b1626, 0.004);

  const camera=new THREE.PerspectiveCamera(55, innerWidth/innerHeight, .1, 4000);
  let radius=300, theta=0.28, phi=1.05;
  const target=new THREE.Vector3(0, 90, 0);

  const renderer=new THREE.WebGLRenderer({canvas:document.getElementById('canvas'), antialias:true, alpha:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
  renderer.setSize(innerWidth,innerHeight);

  scene.add(new THREE.AmbientLight(0xffffff, .5));
  const key=new THREE.DirectionalLight(0xbfe2ff,1.35); key.position.set(220,240,220); scene.add(key);
  const rim=new THREE.DirectionalLight(0xffaacd,1.0); rim.position.set(-220,180,-220); scene.add(rim);

  // floor
  const floor=new THREE.Mesh(new THREE.PlaneGeometry(2200,2200), new THREE.MeshStandardMaterial({color:0x0b1626, roughness:1}));
  floor.rotation.x=-Math.PI/2; floor.position.y=-2; scene.add(floor);
  const grid=new THREE.GridHelper(1800,36,0x1b3a5a,0x0e2438); grid.position.y=-1.99; grid.material.opacity=.35; grid.material.transparent=true; scene.add(grid);

  // Build Venn card canvas
  function drawVenn(vec, focus='C'){
    const w=512,h=340, cx=w*0.42, cy=h*0.58, r=h*0.28, dx=r*0.9;
    const cvs=document.createElement('canvas'); cvs.width=w; cvs.height=h; const g=cvs.getContext('2d');
    g.clearRect(0,0,w,h);
    // backdrop
    g.fillStyle='rgba(15,28,48,0.95)'; g.strokeStyle='rgba(39,74,116,1)'; g.lineWidth=4; roundRect(g,8,8,w-16,h-16,18,true,true);
    g.globalCompositeOperation='lighter';
    // left
    g.fillStyle=alpha(LL, focus==='L'?0.38:0.22); circle(g, cx-dx, cy, r);
    // right
    g.fillStyle=alpha(RL, focus==='R'?0.38:0.22); circle(g, cx+dx, cy, r);
    // overlap
    g.fillStyle=alpha(EN, focus==='C'?0.42:0.28); circle(g, cx, cy, r);
    g.globalCompositeOperation='source-over';
    // labels
    g.font='900 28px system-ui, -apple-system, Segoe UI'; g.textAlign='center';
    g.fillStyle=LL; g.fillText('Trace', cx-dx, cy-r-12);
    g.fillStyle=EN; g.fillText('Entangled', cx, cy-r-12);
    g.fillStyle=RL; g.fillText('Stream', cx+dx, cy-r-12);
    // vector badge
    g.fillStyle='rgba(0,0,0,0.6)'; g.strokeStyle='#9ad7ff'; g.lineWidth=2; roundRect(g,w-150,18,128,38,12,true,true);
    g.fillStyle='#cfe6ff'; g.font='900 22px ui-monospace, Menlo, Consolas'; g.fillText(vec, w-86, 45);
    return cvs;
  }
  function circle(g,x,y,r){ g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.closePath(); g.fill(); }
  function alpha(hex, a){ const c = hex.replace('#',''); const r=parseInt(c.substr(0,2),16), gg=parseInt(c.substr(2,2),16), b=parseInt(c.substr(4,2),16); return `rgba(${r},${gg},${b},${a})`; }
  function roundRect(ctx, x, y, width, height, radius, fill, stroke){
    if (typeof radius === 'number') radius = {tl: radius, tr: radius, br: radius, bl: radius};
    ctx.beginPath(); ctx.moveTo(x + radius.tl, y); ctx.lineTo(x + width - radius.tr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
    ctx.lineTo(x + width, y + height - radius.br);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
    ctx.lineTo(x + radius.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
    ctx.lineTo(x, y + radius.tl);
    ctx.quadraticCurveTo(x, y, x + radius.tl, y);
    ctx.closePath(); if (fill) ctx.fill(); if (stroke) ctx.stroke();
  }

  // Create stack (32 cards)
  const cardGeo=new THREE.PlaneGeometry(110, 72);
  function makeCard(k, focus='C'){
    const s = DATA[k-1]; const cvs=drawVenn(s.vec, focus); const tex=new THREE.CanvasTexture(cvs);
    const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true, depthWrite:false});
    const m=new THREE.Mesh(cardGeo, mat); m.userData={k, focus}; return m;
  }

  const stack = new THREE.Group();
  const spacing = 9.2;
  for(let i=0;i<32;i++){ const card = makeCard(i+1); card.position.set(0,i*spacing,0); stack.add(card); }
  stack.position.set(0, 0, 0); scene.add(stack);

  // Camera helpers
  function placeCam(){
    const x=target.x + radius*Math.sin(phi)*Math.sin(theta);
    const y=target.y + radius*Math.cos(phi);
    const z=target.z + radius*Math.sin(phi)*Math.cos(theta);
    camera.position.set(x,y,z); camera.lookAt(target);
  }
  function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
  placeCam();

  // HUD update
  function setK(k){
    currentK = Math.max(1, Math.min(32, k));
    const v = DATA[currentK-1].vec;
    document.getElementById('kbox').textContent = `k=${currentK} · ${v}`;
    // update reader cards
    const s=DATA[currentK-1];
    document.getElementById('txtL').textContent=s.L;
    document.getElementById('txtC').textContent=s.C;
    document.getElementById('txtR').textContent=s.R;
    // glow selected card
    for(const c of stack.children){
      const on = (c.userData.k===currentK);
      c.scale.set(on?1.06:1, on?1.06:1, 1);
      c.position.x = on ? 4 : 0;
      c.material.opacity = on ? 1 : 0.8;
    }
  }

  // Gestures: vertical drag to scrub
  let dragging=false, x0=0, y0=0, k0=1, currentK=1;
  renderer.domElement.addEventListener('pointerdown',e=>{dragging=true;x0=e.clientX;y0=e.clientY;k0=currentK;});
  addEventListener('pointermove',e=>{
    if(!dragging) return;
    const dx=e.clientX-x0, dy=e.clientY-y0;
    // vertical = scrub, horizontal = orbit/tilt light
    const dk = Math.round(-dy/20);
    setK(k0 + dk);
    theta += dx*0.003; phi = clamp(phi + dy*0.0008, 0.6, 1.3);
    placeCam();
  });
  addEventListener('pointerup',()=> dragging=false);

  // Pinch zoom
  let pinch=null;
  addEventListener('touchstart',e=>{
    if(e.touches.length===2){
      const dx=e.touches[0].clientX-e.touches[1].clientX;
      const dy=e.touches[0].clientY-e.touches[1].clientY;
      pinch={d:Math.hypot(dx,dy), r0:radius};
    }
  },{passive:false});
  addEventListener('touchmove',e=>{
    if(pinch && e.touches.length===2){
      const dx=e.touches[0].clientX-e.touches[1].clientX;
      const dy=e.touches[0].clientY-e.touches[1].clientY;
      const d=Math.hypot(dx,dy);
      radius=clamp(pinch.r0 * (pinch.d/d), 140, 900);
      placeCam();
    }
  },{passive:false});
  addEventListener('touchend',()=> pinch=null);

  // Tap regions on the active card to focus L/C/R tint
  function focusRegion(which){
    const m = stack.children[currentK-1];
    m.userData.focus = which;
    const s=DATA[currentK-1];
    const cvs=drawVenn(s.vec, which);
    m.material.map.image = cvs;
    m.material.map.needsUpdate = true;
  }
  // simple raycast + region test
  const ray=new THREE.Raycaster(); const v2=new THREE.Vector2();
  function pick(ev){ const r=renderer.domElement.getBoundingClientRect();
    v2.x=((ev.clientX-r.left)/r.width)*2-1; v2.y=-((ev.clientY-r.top)/r.height)*2+1;
    ray.setFromCamera(v2,camera); return ray.intersectObjects([stack.children[currentK-1]],false); }
  renderer.domElement.addEventListener('pointerup',e=>{
    const hits=pick(e); if(!hits.length) return;
    const uv=hits[0].uv; // plane UV
    const u=uv.x, v=uv.y; // rough regions: left<0.4, right>0.6, else center
    if(u<0.38) focusRegion('L'); else if(u>0.62) focusRegion('R'); else focusRegion('C');
  });

  // View chips
  document.getElementById('front').addEventListener('click',()=>{theta=0;phi=1.0;placeCam()});
  document.getElementById('iso').addEventListener('click',()=>{theta=0.6;phi=1.0;placeCam()});
  document.getElementById('top').addEventListener('click',()=>{theta=0.4;phi=0.5;placeCam()});
  let gridOn=false;
  document.getElementById('grid').addEventListener('click',()=>{gridOn=!gridOn; grid.material.opacity=gridOn?.35:0;});

  // Resize
  addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight); placeCam();});

  setK(1);
  (function anim(){ requestAnimationFrame(anim); renderer.render(scene,camera) })();
})();
</script>
</body>
</html>