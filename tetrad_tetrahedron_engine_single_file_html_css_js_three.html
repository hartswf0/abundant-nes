<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetrad Tetrahedron Engine — three.js + Haptics + Audio</title>
  <style>
    :root{
      --bg:#0b0c10; --panel:#12141a; --ink:#e6e8ee; --muted:#98a2b3; --accent:#7c5cff; --ok:#22c55e; --warn:#f59e0b; --danger:#ef4444;
      --card:#0f1117; --edge:#222; --chip:#1a1d25; --b:#000; --white:#fff;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b0c10,#0b0c10 50%,#0a0b10);color:var(--ink);font:15px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #app{display:grid;grid-template-columns:1fr 360px;grid-template-rows:100vh;gap:0}
    #stage{position:relative;overflow:hidden}
    canvas{display:block}
    .hud{position:absolute;inset:auto 16px 16px 16px;display:flex;gap:8px;flex-wrap:wrap;pointer-events:none}
    .chip{pointer-events:auto;background:var(--chip);border:1px solid #1f2430;border-radius:999px;padding:6px 10px;color:var(--muted)}
    .chip strong{color:var(--ink)}
    .legend{position:absolute;top:12px;left:12px;background:rgba(10,12,18,.6);backdrop-filter:blur(8px);border:1px solid #202635;border-radius:12px;padding:8px 12px}
    .legend b{color:var(--ink)}
    .panel{background:var(--panel);border-left:1px solid #1f2430;display:flex;flex-direction:column;min-width:320px;max-width:420px}
    .panel header{padding:14px 14px 10px;border-bottom:1px solid #1f2430}
    .panel h1{margin:0;font-size:18px;letter-spacing:.2px}
    .panel .sub{color:var(--muted);font-size:12px;margin-top:4px}
    .panel section{padding:12px 14px;display:grid;gap:10px;border-bottom:1px solid #1f2430}
    label{display:grid;gap:6px}
    input[type=text], textarea, select{width:100%;background:#0d0f15;color:var(--ink);border:1px solid #22283a;border-radius:10px;padding:10px 12px;outline:none}
    textarea{min-height:72px;resize:vertical}
    .row{display:flex;gap:8px}
    button{appearance:none;background:var(--accent);color:#fff;border:0;border-radius:12px;padding:10px 14px;font-weight:600;cursor:pointer}
    button.secondary{background:#1d2230;color:var(--ink);border:1px solid #2a3042}
    button.ghost{background:transparent;border:1px dashed #374151;color:var(--muted)}
    .outputs{display:grid;grid-template-columns:1fr;gap:10px}
    .card{background:var(--card);border:1px solid #1b2130;border-radius:14px;padding:10px}
    .card h3{margin:4px 0 8px;font-size:13px;color:var(--muted);text-transform:uppercase;letter-spacing:.14em}
    .card pre{margin:0;white-space:pre-wrap;word-wrap:break-word}
    .facemap{display:grid;grid-template-columns:repeat(4,1fr);gap:6px}
    .facepill{padding:6px 8px;background:#121520;border:1px solid #1f2534;border-radius:999px;text-align:center;font-size:12px;color:var(--muted)}
    .facepill.active{color:#fff;border-color:#3a3fff;background:#191d33}
    .savebar{display:flex;gap:8px;justify-content:space-between;align-items:center}
    .tiny{font-size:12px;color:var(--muted)}

    @media (max-width: 980px){
      #app{grid-template-columns:1fr;grid-template-rows:auto auto}
      #stage{height:52vh}
      .panel{max-width:none;border-left:0;border-top:1px solid #1f2430}
    }

    .testlist{display:grid;gap:6px}
    .badge{border:1px solid #283042;background:#111524;border-radius:10px;padding:6px 8px;font-size:12px;color:#aab0be}
    .badge.ok{border-color:#214329;color:#9ae6b4;background:#0f1c14}
    .badge.fail{border-color:#4b1f1f;color:#fecaca;background:#1a0e0e}
  </style>

  <!-- Import map fixes the bare specifier inside OrbitControls ("import ... from 'three'") -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
    }
  }
  </script>
</head>
<body>
<div id="app" role="application" aria-label="Tetrad Tetrahedron Engine">
  <div id="stage" aria-live="polite">
    <div class="legend tiny">
      <b>Tetrad Controls</b><br/>
      • Drag: rotate · Pinch: zoom · Dbl‑tap: snap face · Tilt: rotate (mobile)<br/>
      • Arrow/WASD: rotate · Space: focus current face
    </div>
    <div class="hud" id="hud"></div>
  </div>
  <aside class="panel">
    <header>
      <h1>Tetrad Tetrahedron Engine</h1>
      <div class="sub">three.js + haptics + audio · mobile‑first</div>
    </header>

    <section>
      <label>
        <span>Artefact A</span>
        <input type="text" id="artefact" placeholder="e.g., 'Short‑form video platform'" />
      </label>
      <label>
        <span>Previous answer / context R (optional)</span>
        <textarea id="response" placeholder="Paste a previous answer or short context here."></textarea>
      </label>
      <label>
        <span>Interpretive Mode</span>
        <select id="mode"></select>
      </label>
      <div class="row">
        <button id="run">Run Engine</button>
        <button class="secondary" id="shuffle">Shuffle Mode</button>
        <button class="ghost" id="addMode">Add Mode</button>
      </div>
      <div class="facemap" id="facemap" aria-label="Face status">
        <div class="facepill" data-face="enhance">Enhance</div>
        <div class="facepill" data-face="obsolesce">Obsolesce</div>
        <div class="facepill" data-face="retrieve">Retrieve</div>
        <div class="facepill" data-face="reverse">Reverse</div>
      </div>
    </section>

    <section>
      <div class="outputs">
        <div class="card"><h3>Enhance</h3><pre id="out-enhance">—</pre></div>
        <div class="card"><h3>Obsolesce</h3><pre id="out-obsolesce">—</pre></div>
        <div class="card"><h3>Retrieve</h3><pre id="out-retrieve">—</pre></div>
        <div class="card"><h3>Reverse</h3><pre id="out-reverse">—</pre></div>
      </div>
    </section>

    <section>
      <div class="card">
        <h3>Self‑tests</h3>
        <div class="testlist" id="tests"></div>
      </div>
    </section>

    <section class="savebar">
      <div class="row">
        <button class="secondary" id="exportJson">Export JSON</button>
        <button class="secondary" id="importJson">Import</button>
      </div>
      <div class="tiny">Local autosave is on.</div>
    </section>
  </aside>
</div>

<script type="module">
  // === Imports (use import map for 'three') ===
  import * as THREE from 'three';
  import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

  // === DOM helpers ===
  const qs = (s,el=document)=>el.querySelector(s);
  const qsa=(s,el=document)=>[...el.querySelectorAll(s)];

  // === Audio (WebAudio one-shot beeps per face) ===
  const AudioEngine = (()=>{
    let ctx; let lastAt=0;
    const FACE_TONES = { enhance:523.25, obsolesce:392.00, retrieve:440.00, reverse:329.63 };
    function ensure(){ ctx ||= new (window.AudioContext||window.webkitAudioContext)(); if(ctx.state==='suspended') ctx.resume(); }
    function blip(face){ ensure(); const now = ctx.currentTime; const t = Math.max(now,lastAt+0.01); lastAt=t; const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='triangle'; o.frequency.value = FACE_TONES[face]||440; o.connect(g); g.connect(ctx.destination); const dur=0.18; g.gain.setValueAtTime(0.0001,t); g.gain.exponentialRampToValueAtTime(0.3,t+0.02); g.gain.exponentialRampToValueAtTime(0.0001,t+dur); o.start(t); o.stop(t+dur+0.02); }
    return { blip };
  })();

  // === Haptics ===
  function haptic(face){ if(!('vibrate' in navigator)) return; const m={enhance:[18], obsolesce:[10,30,10], retrieve:[22,12,22], reverse:[8,8,8,8,24]}; navigator.vibrate(m[face]||[12]); }

  // === Modes (extensible); simple templating with {A} and {R} ===
  const DEFAULT_MODES = [
    {
      id:'exploratory', name:'Exploratory Lens — Media Archaeologist',
      enhance:'Overstate what {A} magnifies until it reshapes perception.',
      obsolesce:'Misread {R} to claim what {A} silently makes unnecessary.',
      retrieve:'Recast {R} to uncover what dormant form {A} revives.',
      reverse:'Stretch {R} until {A} inverts into its contradictory figure.'
    },
    {
      id:'stresstest', name:'Stress‑Test Frame — System Stress‑Tester',
      enhance:'Inflate a strength of {A} into an overpowering capability; what breaks?',
      obsolesce:'Treat {R} as the thing {A} burns out under overload.',
      retrieve:'Under failure, what older workaround or folk practice does {A} bring back?',
      reverse:'Push {A} to extremes: when does it flip into its opposite function?'
    },
    {
      id:'policy', name:'Policy Lens — Governance & Risk',
      enhance:'What public good or measurable outcome does {A} amplify?',
      obsolesce:'Which institutions, norms, or gatekeepers does {A} displace?',
      retrieve:'Which earlier regulatory idea or civic value does {A} retrieve?',
      reverse:'At scale, how does {A} reverse into a risk or externality that mandates limits?'
    },
    {
      id:'design', name:'Design Critique — Jobs‑To‑Be‑Done',
      enhance:'Which user job does {A} supercharge? Evidence of success?',
      obsolesce:'Which workarounds or legacy flows vanish in practice?',
      retrieve:'Which vintage affordance or ritual does {A} bring back?',
      reverse:'When over‑optimized, how does {A} create new friction or anti‑pattern?'
    },
    {
      id:'poetics', name:'Poetics — Image & Metaphor',
      enhance:'A vivid image: {A} as a lens that brightens one color of the world.',
      obsolesce:'A fading image: what shade in {R} goes grayscale as {A} arrives?',
      retrieve:'A recovered image: what antique color or grain returns through {A}?',
      reverse:'A flipped image: when saturated, {A} solarizes into its negative.'
    }
  ];

  const store = {
    key:'tetrad-engine-v1',
    load(){ try{ return JSON.parse(localStorage.getItem(this.key)||'{}'); }catch{ return {}; } },
    save(data){ localStorage.setItem(this.key, JSON.stringify(data)); }
  };

  // === UI State ===
  const state = {
    modes: [],
    selectedMode: null,
    face:'enhance',
    A:'',
    R:'',
    outputs: {enhance:'—',obsolesce:'—',retrieve:'—',reverse:'—'}
  };

  function initModes(){
    const saved = store.load();
    state.modes = (saved.modes && saved.modes.length) ? saved.modes : DEFAULT_MODES;
    const sel = qs('#mode'); sel.innerHTML='';
    state.modes.forEach((m)=>{ const o=document.createElement('option'); o.value=m.id; o.textContent=m.name; sel.appendChild(o); });
    const chosen = saved.selectedModeId || state.modes[0].id; sel.value = chosen; state.selectedMode = state.modes.find(m=>m.id===chosen);
    qs('#artefact').value = saved.A || '';
    qs('#response').value = saved.R || '';
    if(saved.outputs){ Object.assign(state.outputs, saved.outputs); renderOutputs(); }
    updateFacePills();
  }

  function saveLocal(){ store.save({ modes: state.modes, selectedModeId: state.selectedMode?.id, A: state.A, R: state.R, outputs: state.outputs }); }

  // === Simple templating ===
  function tpl(s){ return s.replaceAll('{A}', state.A || 'the artefact').replaceAll('{R}', state.R || 'the prior response'); }

  function runEngine(){
    const m = state.selectedMode; if(!m) return;
    const E = tpl(m.enhance);
    const O = tpl(m.obsolesce);
    const T = tpl(m.retrieve);
    const V = tpl(m.reverse);
    state.outputs = { enhance:E, obsolesce:O, retrieve:T, reverse:V };
    renderOutputs(); saveLocal();
  }

  function renderOutputs(){ qs('#out-enhance').textContent = state.outputs.enhance; qs('#out-obsolesce').textContent = state.outputs.obsolesce; qs('#out-retrieve').textContent = state.outputs.retrieve; qs('#out-reverse').textContent = state.outputs.reverse; }

  // === Add custom mode ===
  function addModeDialog(){
    const name = prompt('Name this mode (e.g., "Ethnography Lens")'); if(!name) return;
    const id = name.toLowerCase().replace(/[^a-z0-9]+/g,'-');
    const enhance = prompt('Enhance template. Use {A} and {R}.', 'What does {A} amplify for people like X?');
    const obsolesce = prompt('Obsolesce template.', 'Which habit in {R} does {A} make unnecessary?');
    const retrieve = prompt('Retrieve template.', 'What older practice returns through {A}?');
    const reverse = prompt('Reverse template.', 'When pushed, what opposite does {A} become?');
    const mode = { id, name, enhance, obsolesce, retrieve, reverse };
    state.modes.push(mode);
    const sel = qs('#mode'); const o=document.createElement('option'); o.value=id; o.textContent=name; sel.appendChild(o); sel.value=id; state.selectedMode = mode; saveLocal(); alert('Mode added.');
  }

  // === Export / Import JSON ===
  function exportJson(){
    const blob = new Blob([JSON.stringify({A:state.A,R:state.R,mode:state.selectedMode,outputs:state.outputs,modes:state.modes},null,2)],{type:'application/json'});
    const a = document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='tetrad-export.json'; a.click(); URL.revokeObjectURL(a.href);
  }
  function importJson(){
    const inp = document.createElement('input'); inp.type='file'; inp.accept='.json,application/json'; inp.onchange=()=>{
      const f = inp.files?.[0]; if(!f) return; const r = new FileReader(); r.onload=()=>{
        try{
          const data = JSON.parse(r.result);
          qs('#artefact').value = data.A||''; qs('#response').value = data.R||'';
          state.A=data.A||''; state.R=data.R||''; state.outputs=data.outputs||state.outputs;
          if(data.modes?.length){ state.modes=data.modes; initModes(); }
          renderOutputs(); saveLocal();
        }catch(err){ alert('Import failed: '+err.message); }
      }; r.readAsText(f);
    }; inp.click();
  }

  // === Face label textures ===
  function faceTexture(text, bg, fg){
    const c = document.createElement('canvas'); c.width=512; c.height=512; const g=c.getContext('2d');
    g.fillStyle=bg; g.fillRect(0,0,c.width,c.height);
    g.fillStyle='#ffffff20'; for(let i=0;i<80;i++){ g.fillRect(Math.random()*512,Math.random()*512,1,1); }
    g.fillStyle=fg; g.font='700 64px system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif'; g.textAlign='center'; g.textBaseline='middle';
    g.fillText(text, 256, 256);
    return new THREE.CanvasTexture(c);
  }

  const FACE_META = [
    { key:'enhance',   color:0x4f46e5, label:'Enhance' },
    { key:'obsolesce', color:0x22c55e, label:'Obsolesce' },
    { key:'retrieve',  color:0xf59e0b, label:'Retrieve' },
    { key:'reverse',   color:0xef4444, label:'Reverse' }
  ];

  // === Scene ===
  let scene, camera, renderer, controls, tetra;
  const stage = qs('#stage');
  const hud = qs('#hud');

  let userInteracting = false;

  function init3D(){
    // basic import sanity
    if(!THREE || !THREE.WebGLRenderer) throw new Error('THREE failed to load');

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0c10);
    camera = new THREE.PerspectiveCamera(55, stage.clientWidth/stage.clientHeight, 0.1, 100);
    camera.position.set(2.6, 2.2, 3.0);

    renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    renderer.setSize(stage.clientWidth, stage.clientHeight);
    stage.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xffffff, 0x101018, 1.0); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(3,3,2); scene.add(dir);

    // Subtle grid
    const grid = new THREE.GridHelper(10, 10, 0x222833, 0x1b2130); grid.position.y=-1.2; scene.add(grid);

    // Tetrahedron
    const geo = new THREE.TetrahedronGeometry(1.2, 0);

    // Build face materials using groups (4 faces)
    const materials = FACE_META.map(f=> new THREE.MeshStandardMaterial({ color:f.color, metalness:0.15, roughness:0.35, emissive:0x000000, map:faceTexture(f.label,'#0f1117','#dee3ea') }));
    // Assign groups: 4 faces × 3 indices
    geo.clearGroups();
    for(let i=0;i<4;i++){ geo.addGroup(i*3,3,i); }

    tetra = new THREE.Mesh(geo, materials);
    tetra.castShadow = true; tetra.receiveShadow = true;
    scene.add(tetra);

    // Wireframe edges
    const edges = new THREE.EdgesGeometry(geo);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color:0x202636 }));
    tetra.add(line);

    // Orbit controls + damping
    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.08;
    controls.minDistance = 2; controls.maxDistance = 6.5;

    renderer.domElement.addEventListener('pointerdown', ()=>{ userInteracting = true; });
    window.addEventListener('pointerup', ()=>{ userInteracting = false; });

    // Tap/dblclick to snap to current face text output
    renderer.domElement.addEventListener('dblclick', ()=> focusCurrentFace());

    // Device tilt
    if(window.DeviceOrientationEvent){
      window.addEventListener('deviceorientation', (e)=>{
        const gx = (e.beta||0)/90; // -180..180
        const gy = (e.gamma||0)/90; // -90..90
        tetra.rotation.x += gx*0.002;
        tetra.rotation.y += gy*0.002;
      });
    }

    animate();
  }

  // === Determine which face looks at camera ===
  let currentFaceIndex = -1; let faceCooldown=0;
  function detectFace(){
    const normals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
    const pos = tetra.geometry.attributes.position;
    for(let f=0; f<4; f++){
      const i = f*9; // three vertices per face × 3 components
      const a = new THREE.Vector3(pos.array[i],pos.array[i+1],pos.array[i+2]);
      const b = new THREE.Vector3(pos.array[i+3],pos.array[i+4],pos.array[i+5]);
      const c = new THREE.Vector3(pos.array[i+6],pos.array[i+7],pos.array[i+8]);
      a.applyMatrix4(tetra.matrixWorld); b.applyMatrix4(tetra.matrixWorld); c.applyMatrix4(tetra.matrixWorld);
      const n = new THREE.Vector3().subVectors(c,b).cross(new THREE.Vector3().subVectors(a,b)).normalize();
      normals[f]=n;
    }
    const toCam = new THREE.Vector3().subVectors(camera.position, tetra.position).normalize();
    let best = -Infinity; let idx = 0;
    normals.forEach((n,i)=>{ const d = n.dot(toCam); if(d>best){ best=d; idx=i; } });
    return idx; // 0..3
  }

  function animate(){
    requestAnimationFrame(animate);
    controls.update();
    // idle rotation only when not interacting
    if(!userInteracting){ tetra.rotation.y += 0.001; }

    // face detection with cooldown to prevent spamming haptics/audio
    const f = detectFace();
    if(f!==currentFaceIndex){
      currentFaceIndex=f; faceCooldown=0;
      const faceKey = FACE_META[f].key; onFaceChange(faceKey);
    } else if(faceCooldown<15){ faceCooldown++; }

    renderer.render(scene,camera);
  }

  function onFaceChange(faceKey){
    state.face = faceKey; updateFacePills();
    AudioEngine.blip(faceKey); haptic(faceKey);
    hud.innerHTML = '';
    const chip = document.createElement('div'); chip.className='chip';
    chip.innerHTML = `<strong>${FACE_META.find(f=>f.key===faceKey).label}</strong> · ${state.selectedMode?.name||''}`;
    hud.appendChild(chip);
  }

  function updateFacePills(){ qsa('.facepill').forEach(p=>{ p.classList.toggle('active', p.dataset.face===state.face); }); }

  function focusCurrentFace(){
    const idx = currentFaceIndex>=0 ? currentFaceIndex : 0;
    const center = new THREE.Vector3(0,0,0);
    const dir = new THREE.Vector3().subVectors(camera.position, center).normalize();
    camera.position.addScaledVector(dir, -0.3);
    controls.update();
    const id = ['enhance','obsolesce','retrieve','reverse'][idx];
    const map = {enhance:'#out-enhance', obsolesce:'#out-obsolesce', retrieve:'#out-retrieve', reverse:'#out-reverse'};
    const el = qs(map[id]); if(el){ el.parentElement.scrollIntoView({behavior:'smooth',block:'center'}); }
  }

  // === Event wiring ===
  initModes(); init3D(); runEngine();

  qs('#mode').addEventListener('change', (e)=>{ state.selectedMode = state.modes.find(m=>m.id===e.target.value); saveLocal(); runEngine(); });
  qs('#artefact').addEventListener('input', e=>{ state.A = e.target.value; saveLocal(); });
  qs('#response').addEventListener('input', e=>{ state.R = e.target.value; saveLocal(); });
  qs('#run').addEventListener('click', ()=>{ runEngine(); });
  qs('#shuffle').addEventListener('click', ()=>{
    const i = Math.floor(Math.random()*state.modes.length); qs('#mode').value=state.modes[i].id; state.selectedMode=state.modes[i]; runEngine(); saveLocal();
  });
  qs('#addMode').addEventListener('click', addModeDialog);
  qs('#exportJson').addEventListener('click', exportJson);
  qs('#importJson').addEventListener('click', importJson);

  // Resize handler
  const ro = new ResizeObserver(()=>{
    const w = stage.clientWidth, h = stage.clientHeight; renderer.setSize(w,h); camera.aspect = w/h; camera.updateProjectionMatrix();
  }); ro.observe(stage);

  // Keyboard shortcuts
  window.addEventListener('keydown', (e)=>{
    const step = 0.08;
    if(['ArrowLeft','a','A'].includes(e.key)){ tetra.rotation.y += step; }
    if(['ArrowRight','d','D'].includes(e.key)){ tetra.rotation.y -= step; }
    if(['ArrowUp','w','W'].includes(e.key)){ tetra.rotation.x += step; }
    if(['ArrowDown','s','S'].includes(e.key)){ tetra.rotation.x -= step; }
    if(e.key===' '){ e.preventDefault(); focusCurrentFace(); }
  });

  // First user gesture to unlock audio on some browsers
  ['click','touchstart','keydown'].forEach(ev=>{
    window.addEventListener(ev, ()=>{ try{ AudioEngine.blip('retrieve'); }catch{} }, { once:true });
  });

  // === Self‑tests (basic runtime checks) ===
  function test(name, pass, msg=''){
    const el = document.createElement('div'); el.className='badge ' + (pass?'ok':'fail');
    el.textContent = (pass? 'PASS: ' : 'FAIL: ') + name + (msg? ' — ' + msg : '');
    qs('#tests').appendChild(el);
  }

  function runSelfTests(){
    // T1: THREE import & revision
    test('three.js import', !!THREE && !!THREE.WebGLRenderer, THREE?.REVISION? `r${THREE.REVISION}` : '');
    // T2: OrbitControls import
    test('OrbitControls import', typeof OrbitControls === 'function');
    // T3: Renderer added to DOM
    test('Renderer attached', !!renderer && !!renderer.domElement && renderer.domElement.parentElement===stage);
    // T4: Face detection in range
    try{ const f=detectFace(); test('Face detection index', f>=0 && f<4, `index=${f}`);}catch(e){ test('Face detection index', false, e.message); }
    // T5: Audio engine available
    test('Audio engine blip()', typeof AudioEngine.blip==='function');
  }

  // Defer tests so DOM mounts
  setTimeout(runSelfTests, 100);
</script>
</body>
</html>
